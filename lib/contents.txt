import 'package:flutter/material.dart';

class CanvasInteractionController {
  final TransformationController transformationController;

  Matrix4? _cachedInverseMatrix;
  Matrix4? _lastMatrix;
  Size _canvasSize;

  Offset _canvasOffset;
  static const double canvasPadding = 100.0;
  bool isDragging = false;

  CanvasInteractionController({
    Size initialCanvasSize = const Size(2000, 2000),
    Offset initialCanvasOffset = Offset.zero,
  }) : transformationController = TransformationController(),
       _canvasSize = initialCanvasSize,
       _canvasOffset = initialCanvasOffset {
    transformationController.value = Matrix4.identity();
  }

  Size get canvasSize => _canvasSize;
  Offset get canvasOffset => _canvasOffset;

  void resetView() {
    transformationController.value = Matrix4.identity();
  }

  Offset? getCanvasPositionOptimized(
    Offset globalPosition,
    RenderBox canvasBox,
  ) {
    final Offset localPosition = canvasBox.globalToLocal(globalPosition);
    final matrix = transformationController.value;

    if (_lastMatrix != matrix) {
      _cachedInverseMatrix = Matrix4.inverted(matrix);
      _lastMatrix = matrix.clone();
    }

    final canvasPosition = MatrixUtils.transformPoint(
      _cachedInverseMatrix!,
      localPosition,
    );

    return canvasPosition;
  }

  Rect getViewportBounds(Size viewportSize) {
    final matrix = transformationController.value;
    final inverseMatrix = Matrix4.inverted(matrix);

    final topLeft = MatrixUtils.transformPoint(inverseMatrix, Offset.zero);
    final bottomRight = MatrixUtils.transformPoint(
      inverseMatrix,
      Offset(viewportSize.width, viewportSize.height),
    );

    return Rect.fromPoints(topLeft, bottomRight);
  }

  bool isComponentVisible(
    Offset componentPos,
    Size componentSize,
    Size viewportSize,
  ) {
    final viewportBounds = getViewportBounds(viewportSize);
    final componentRect = Rect.fromLTWH(
      componentPos.dx,
      componentPos.dy,
      componentSize.width,
      componentSize.height,
    );

    return viewportBounds.overlaps(componentRect);
  }

  void clearCache() {
    _cachedInverseMatrix = null;
    _lastMatrix = null;
  }

  bool updateCanvasSize(
    Map<String, Offset> componentPositions,
    Map<String, double> componentWidths,
  ) {
    if (componentPositions.isEmpty) return false;

    double minX = double.infinity;
    double minY = double.infinity;
    double maxX = double.negativeInfinity;
    double maxY = double.negativeInfinity;

    componentPositions.forEach((id, position) {
      final width = componentWidths[id] ?? 160.0;
      const estimatedHeight = 120.0;

      minX = minX < position.dx ? minX : position.dx;
      minY = minY < position.dy ? minY : position.dy;
      maxX = maxX > position.dx + width ? maxX : position.dx + width;
      maxY = maxY > position.dy + estimatedHeight
          ? maxY
          : position.dy + estimatedHeight;
    });

    bool needsUpdate = false;
    Size newCanvasSize = _canvasSize;
    Offset newCanvasOffset = _canvasOffset;

    if (minX < canvasPadding) {
      double extraWidth = canvasPadding - minX;
      newCanvasSize = Size(
        _canvasSize.width + extraWidth,
        newCanvasSize.height,
      );
      newCanvasOffset = Offset(
        _canvasOffset.dx - extraWidth,
        newCanvasOffset.dy,
      );
      needsUpdate = true;
    }

    if (minY < canvasPadding) {
      double extraHeight = canvasPadding - minY;
      newCanvasSize = Size(
        newCanvasSize.width,
        _canvasSize.height + extraHeight,
      );
      newCanvasOffset = Offset(
        newCanvasOffset.dx,
        _canvasOffset.dy - extraHeight,
      );
      needsUpdate = true;
    }

    if (maxX > _canvasSize.width - canvasPadding) {
      double extraWidth = maxX - (_canvasSize.width - canvasPadding);
      newCanvasSize = Size(
        _canvasSize.width + extraWidth,
        newCanvasSize.height,
      );
      needsUpdate = true;
    }

    if (maxY > _canvasSize.height - canvasPadding) {
      double extraHeight = maxY - (_canvasSize.height - canvasPadding);
      newCanvasSize = Size(
        newCanvasSize.width,
        _canvasSize.height + extraHeight,
      );
      needsUpdate = true;
    }

    if (needsUpdate) {
      _canvasSize = newCanvasSize;
      _canvasOffset = newCanvasOffset;
      clearCache();
      return true;
    }

    return false;
  }

  Offset? getCanvasPosition(Offset globalPosition, RenderBox canvasBox) {
    final Offset localPosition = canvasBox.globalToLocal(globalPosition);

    final matrix = transformationController.value;
    final inverseMatrix = Matrix4.inverted(matrix);
    final canvasPosition = MatrixUtils.transformPoint(
      inverseMatrix,
      localPosition,
    );

    return canvasPosition;
  }

  Map<String, Offset> getAdjustedPositions(
    Map<String, Offset> componentPositions,
    Offset offsetChange,
  ) {
    if (offsetChange == Offset.zero) return componentPositions;

    final adjustedPositions = <String, Offset>{};
    componentPositions.forEach((id, position) {
      adjustedPositions[id] = position + offsetChange;
    });

    return adjustedPositions;
  }

  void setCanvasSize(Size size, Offset offset) {
    _canvasSize = size;
    _canvasOffset = offset;
  }
}
import 'package:flutter/material.dart';
import '../models/component.dart';
import '../models/connection.dart';

class ClipboardManager {
  final List<Component> _clipboardComponents = [];
  final List<Offset> _clipboardPositions = [];
  final List<Connection> _clipboardConnections = [];
  Offset? _clipboardReferencePosition;
  List<Component> get clipboardComponents => _clipboardComponents;
  List<Offset> get clipboardPositions => _clipboardPositions;
  List<Connection> get clipboardConnections => _clipboardConnections;
  Offset? get clipboardReferencePosition => _clipboardReferencePosition;
  bool get isEmpty => _clipboardComponents.isEmpty;

  void copyComponent(Component component, Offset position) {
    _clipboardComponents.clear();
    _clipboardPositions.clear();
    _clipboardConnections.clear();

    _clipboardComponents.add(component);
    _clipboardPositions.add(position);
    _clipboardReferencePosition = position;
  }

  void copyMultipleComponents(
    Set<Component> components,
    Map<String, Offset> componentPositions,
    List<Connection> allConnections,
  ) {
    if (components.isEmpty) return;

    _clipboardComponents.clear();
    _clipboardPositions.clear();
    _clipboardConnections.clear();

    Map<String, int> componentIndexMap = {};

    int index = 0;
    for (final component in components) {
      _clipboardComponents.add(component);

      final position = componentPositions[component.id] ?? Offset.zero;
      _clipboardPositions.add(position);

      componentIndexMap[component.id] = index;
      index++;
    }

    for (final connection in allConnections) {
      final fromSelected = componentIndexMap.containsKey(
        connection.fromComponentId,
      );
      final toSelected = componentIndexMap.containsKey(
        connection.toComponentId,
      );

      if (fromSelected && toSelected) {
        _clipboardConnections.add(connection);
      }
    }

    if (_clipboardComponents.isNotEmpty) {
      _clipboardReferencePosition = _clipboardPositions.first;
    }
  }

  void setClipboardReferencePosition(Offset position) {
    _clipboardReferencePosition = position;
  }

  void clear() {
    _clipboardComponents.clear();
    _clipboardPositions.clear();
    _clipboardConnections.clear();
    _clipboardReferencePosition = null;
  }

  List<Offset> getRelativePositions() {
    if (_clipboardReferencePosition == null || _clipboardPositions.isEmpty) {
      return List.filled(_clipboardPositions.length, Offset.zero);
    }

    return _clipboardPositions
        .map((pos) => pos - _clipboardReferencePosition!)
        .toList();
  }

  List<Offset> calculatePastePositions(Offset targetPosition) {
    final relativePositions = getRelativePositions();
    return relativePositions.map((relPos) => targetPosition + relPos).toList();
  }
}
import 'package:flutter/material.dart';
import '../home/component_widget.dart';
import '../models/component.dart';

class DragOperationManager {
  SlotDragInfo? _currentDraggedPort;
  Offset? _tempLineEndPoint;
  Offset? _dragStartPosition;
  SlotDragInfo? get currentDraggedPort => _currentDraggedPort;
  Offset? get tempLineEndPoint => _tempLineEndPoint;
  Offset? get dragStartPosition => _dragStartPosition;

  void startPortDrag(SlotDragInfo slotInfo) {
    _currentDraggedPort = slotInfo;
  }

  void updatePortDragPosition(Offset position) {
    _tempLineEndPoint = position;
  }

  void endPortDrag() {
    _currentDraggedPort = null;
    _tempLineEndPoint = null;
  }

  void startComponentDrag(Offset position) {
    _dragStartPosition = position;
  }

  void endComponentDrag() {
    _dragStartPosition = null;
  }

  Offset calculateDragOffset(Offset currentPosition) {
    if (_dragStartPosition == null) return Offset.zero;
    return currentPosition - _dragStartPosition!;
  }

  bool isComponentDragInProgress() {
    return _dragStartPosition != null;
  }

  bool isPortDragInProgress() {
    return _currentDraggedPort != null;
  }

  Map<String, Offset> moveComponentsByOffset(
    Map<String, Offset> componentPositions,
    Set<Component> selectedComponents,
    Offset offset,
  ) {
    final Map<String, Offset> updatedPositions = Map.from(componentPositions);

    for (var component in selectedComponents) {
      final currentPos = componentPositions[component.id];
      if (currentPos != null) {
        updatedPositions[component.id] = currentPos + offset;
      }
    }

    return updatedPositions;
  }

  Map<String, Offset> moveComponentToPosition(
    Map<String, Offset> componentPositions,
    String componentId,
    Offset newPosition,
  ) {
    final Map<String, Offset> updatedPositions = Map.from(componentPositions);
    updatedPositions[componentId] = newPosition;
    return updatedPositions;
  }
}
import 'package:flutter/material.dart';
import '../models/component.dart';
import '../models/command_history.dart';
import '../home/manager.dart';

class FlowEditorState {
  final FlowManager flowManager;
  final CommandHistory commandHistory;
  final Map<String, Offset> componentPositions = {};
  final Map<String, GlobalKey> componentKeys = {};
  final Map<String, double> componentWidths = {};
  final GlobalKey canvasKey = GlobalKey();
  final GlobalKey interactiveViewerChildKey = GlobalKey();
  bool isPanelExpanded = false;
  FlowEditorState({required this.flowManager, required this.commandHistory});

  void initializeComponentState(
    Component component, {
    Offset position = Offset.zero,
    double width = 160.0,
  }) {
    componentPositions[component.id] = position;
    componentKeys[component.id] = GlobalKey();
    componentWidths[component.id] = width;
  }

  Offset getComponentPosition(String componentId) {
    return componentPositions[componentId] ?? Offset.zero;
  }

  void setComponentPosition(String componentId, Offset position) {
    componentPositions[componentId] = position;
  }

  double getComponentWidth(String componentId) {
    return componentWidths[componentId] ?? 160.0;
  }

  void setComponentWidth(String componentId, double width) {
    componentWidths[componentId] = width;
  }

  GlobalKey getComponentKey(String componentId) {
    if (!componentKeys.containsKey(componentId)) {
      componentKeys[componentId] = GlobalKey();
    }
    return componentKeys[componentId]!;
  }

  bool isPointOverComponent(Offset point) {
    for (final entry in componentPositions.entries) {
      final componentPos = entry.value;
      const double componentWidth = 180.0;
      const double componentHeight = 150.0;

      final componentRect = Rect.fromLTWH(
        componentPos.dx,
        componentPos.dy,
        componentWidth,
        componentHeight,
      );

      if (componentRect.contains(point)) {
        return true;
      }
    }
    return false;
  }

  Component? findComponentAtPoint(Offset point) {
    for (final component in flowManager.components) {
      final componentPos = componentPositions[component.id];
      if (componentPos != null) {
        const double componentWidth = 180.0;
        const double componentHeight = 150.0;

        final componentRect = Rect.fromLTWH(
          componentPos.dx,
          componentPos.dy,
          componentWidth,
          componentHeight,
        );

        if (componentRect.contains(point)) {
          return component;
        }
      }
    }
    return null;
  }

  void clear() {
    componentPositions.clear();
    componentKeys.clear();
    componentWidths.clear();
    flowManager.components.clear();
    flowManager.connections.clear();
    commandHistory.clear();
  }
}
import 'package:flutter/services.dart';
import '../models/component.dart';

typedef SelectionChangedCallback = void Function(Set<Component> selected);

class SelectionManager {
  final Set<Component> _selectedComponents = {};
  SelectionChangedCallback? _onSelectionChanged;

  Offset? _selectionBoxStart;
  Offset? _selectionBoxEnd;
  bool _isDraggingSelectionBox = false;
  Set<Component> get selectedComponents => _selectedComponents;
  bool get isDraggingSelectionBox => _isDraggingSelectionBox;
  Offset? get selectionBoxStart => _selectionBoxStart;
  Offset? get selectionBoxEnd => _selectionBoxEnd;

  Rect? getSelectionRect() {
    if (_selectionBoxStart == null || _selectionBoxEnd == null) return null;
    return Rect.fromPoints(_selectionBoxStart!, _selectionBoxEnd!);
  }

  void clearSelection() {
    if (_selectedComponents.isNotEmpty) {
      _selectedComponents.clear();
      _notifySelectionChanged();
    }
  }

  void selectComponent(Component component) {
    clearSelection();
    _selectedComponents.add(component);
    _notifySelectionChanged();
  }

  void toggleComponentSelection(Component component) {
    if (_selectedComponents.contains(component)) {
      _selectedComponents.remove(component);
    } else {
      _selectedComponents.add(component);
    }
    _notifySelectionChanged();
  }

  bool isComponentSelected(Component component) {
    return _selectedComponents.contains(component);
  }

  void startSelectionBox(Offset position) {
    _selectionBoxStart = position;
    _selectionBoxEnd = position;
    _isDraggingSelectionBox = true;
  }

  void updateSelectionBox(Offset position) {
    if (_isDraggingSelectionBox) {
      _selectionBoxEnd = position;
    }
  }

  void endSelectionBox(
    List<Component> allComponents,
    Map<String, Offset> componentPositions,
  ) {
    if (!_isDraggingSelectionBox ||
        _selectionBoxStart == null ||
        _selectionBoxEnd == null) {
      _isDraggingSelectionBox = false;
      return;
    }

    final selectionRect = getSelectionRect();
    if (selectionRect == null) {
      _isDraggingSelectionBox = false;
      return;
    }

    if (!HardwareKeyboard.instance.isControlPressed) {
      clearSelection();
    }

    for (final component in allComponents) {
      final componentPos = componentPositions[component.id];
      if (componentPos != null) {
        const double componentWidth = 180.0;
        const double componentHeight = 150.0;

        final componentRect = Rect.fromLTWH(
          componentPos.dx,
          componentPos.dy,
          componentWidth,
          componentHeight,
        );

        if (selectionRect.overlaps(componentRect)) {
          _selectedComponents.add(component);
        }
      }
    }

    _isDraggingSelectionBox = false;
    _selectionBoxStart = null;
    _selectionBoxEnd = null;
  }

  void cancelSelectionBox() {
    _isDraggingSelectionBox = false;
    _selectionBoxStart = null;
    _selectionBoxEnd = null;
  }

  void selectAll(List<Component> allComponents) {
    _selectedComponents.clear();
    _selectedComponents.addAll(allComponents);
  }

  void endSelectionBoxWithSizes(
    List<Component> allComponents,
    Map<String, Offset> componentPositions,
    Map<String, double> componentWidths,
    double defaultHeight,
  ) {
    if (!_isDraggingSelectionBox ||
        _selectionBoxStart == null ||
        _selectionBoxEnd == null) {
      _isDraggingSelectionBox = false;
      return;
    }

    final selectionRect = getSelectionRect();
    if (selectionRect == null) {
      _isDraggingSelectionBox = false;
      return;
    }

    if (!HardwareKeyboard.instance.isControlPressed) {
      clearSelection();
    }

    for (final component in allComponents) {
      final componentPos = componentPositions[component.id];
      if (componentPos != null) {
        final componentWidth = componentWidths[component.id] ?? 160.0;
        final componentHeight = defaultHeight;

        final componentRect = Rect.fromLTWH(
          componentPos.dx,
          componentPos.dy,
          componentWidth + 20,
          componentHeight,
        );

        if (selectionRect.overlaps(componentRect)) {
          _selectedComponents.add(component);
        }
      }
    }

    _isDraggingSelectionBox = false;
    _selectionBoxStart = null;
    _selectionBoxEnd = null;
  }

  void setOnSelectionChanged(SelectionChangedCallback callback) {
    _onSelectionChanged = callback;
  }

  void _notifySelectionChanged() {
    _onSelectionChanged?.call(_selectedComponents);
  }
}
import 'package:flutter/widgets.dart';
import '../models/command.dart';
import '../models/component.dart';
import '../models/connection.dart';
import 'manager.dart';

class AddComponentCommand extends Command {
  final FlowManager flowManager;
  final Component component;
  final Map<String, dynamic> state;

  AddComponentCommand(this.flowManager, this.component, this.state);

  @override
  void execute() {
    flowManager.addComponent(component);
    if (state.containsKey('position')) {
      (state['positions'] as Map<String, Offset>)[component.id] =
          state['position'];
    }
    if (state.containsKey('key')) {
      (state['keys'] as Map<String, GlobalKey>)[component.id] = state['key'];
    }
  }

  @override
  void undo() {
    flowManager.removeComponent(component.id);
    if (state.containsKey('positions')) {
      (state['positions'] as Map<String, Offset>).remove(component.id);
    }
    if (state.containsKey('keys')) {
      (state['keys'] as Map<String, GlobalKey>).remove(component.id);
    }
  }

  @override
  String get description => 'Add ${component.id}';
}

class RemoveComponentCommand extends Command {
  final FlowManager flowManager;
  final Component component;
  final Offset position;
  final GlobalKey? key;
  final List<Connection> affectedConnections;

  RemoveComponentCommand(
    this.flowManager,
    this.component,
    this.position,
    this.key,
    this.affectedConnections,
  );

  @override
  void execute() {
    flowManager.removeComponent(component.id);
  }

  @override
  void undo() {
    flowManager.addComponent(component);

    for (var connection in affectedConnections) {
      flowManager.createConnection(
        connection.fromComponentId,
        connection.fromPortIndex,
        connection.toComponentId,
        connection.toPortIndex,
      );
    }
  }

  @override
  String get description => 'Remove ${component.id}';
}

class CreateConnectionCommand extends Command {
  final FlowManager flowManager;
  final String fromComponentId;
  final int fromPortIndex;
  final String toComponentId;
  final int toPortIndex;

  CreateConnectionCommand(
    this.flowManager,
    this.fromComponentId,
    this.fromPortIndex,
    this.toComponentId,
    this.toPortIndex,
  );

  @override
  void execute() {
    flowManager.createConnection(
      fromComponentId,
      fromPortIndex,
      toComponentId,
      toPortIndex,
    );
  }

  @override
  void undo() {
    flowManager.removeConnection(
      fromComponentId,
      fromPortIndex,
      toComponentId,
      toPortIndex,
    );
  }

  @override
  String get description => 'Connect $fromComponentId→$toComponentId';
}

class UpdatePortValueCommand extends Command {
  final FlowManager flowManager;
  final String componentId;
  final int slotIndex;
  final dynamic newValue;
  final dynamic oldValue;

  UpdatePortValueCommand(
    this.flowManager,
    this.componentId,
    this.slotIndex,
    this.newValue,
    this.oldValue,
  );

  @override
  void execute() {
    flowManager.updatePortValue(componentId, slotIndex, newValue);
  }

  @override
  void undo() {
    flowManager.updatePortValue(componentId, slotIndex, oldValue);
  }

  @override
  String get description => 'Change $componentId value';
}

class MoveComponentCommand extends Command {
  final String componentId;
  final Offset newPosition;
  final Offset oldPosition;
  final Map<String, Offset> componentPositions;

  MoveComponentCommand(
    this.componentId,
    this.newPosition,
    this.oldPosition,
    this.componentPositions,
  );

  @override
  void execute() {
    componentPositions[componentId] = newPosition;
  }

  @override
  void undo() {
    componentPositions[componentId] = oldPosition;
  }

  @override
  String get description => 'Move $componentId';
}
import 'package:flutter/material.dart';
import 'package:grms_designer/utils/device_utils.dart';
import '../../utils/general_ui.dart';
import '../models/component.dart';
import '../models/port.dart';
import '../models/port_type.dart';

class SlotDragInfo {
  final String componentId;
  final int slotIndex;

  SlotDragInfo(this.componentId, this.slotIndex);
}

class ComponentWidget extends StatefulWidget {
  final Component component;
  final GlobalKey widgetKey;
  final Offset position;
  final bool isSelected;
  final double width;
  final double height;
  final Function(String, int, dynamic) onValueChanged;
  final Function(SlotDragInfo) onSlotDragStarted;
  final Function(SlotDragInfo) onSlotDragAccepted;
  final Function(String, double) onWidthChanged;

  const ComponentWidget({
    super.key,
    required this.component,
    required this.isSelected,
    required this.widgetKey,
    required this.position,
    required this.width,
    required this.height,
    required this.onValueChanged,
    required this.onSlotDragStarted,
    required this.onSlotDragAccepted,
    required this.onWidthChanged,
  });

  @override
  State<ComponentWidget> createState() => _ComponentWidgetState();
}

class _ComponentWidgetState extends State<ComponentWidget> {
  static const double itemExternalPadding = 4.0;
  static const double itemTitleSectionHeight = 22.0;

  @override
  Widget build(BuildContext context) {
    return Container(
      key: widget.widgetKey,
      padding: const EdgeInsets.all(itemExternalPadding),
      decoration: BoxDecoration(
        color: getComponentColor(widget.component),
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.2 * 255),
            blurRadius: 3,
            offset: const Offset(1, 2),
          ),
        ],
        border: Border.all(
          color: widget.isSelected ? Colors.indigo : Colors.transparent,
          width: widget.isSelected ? 1.5 : 0.3,
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildTitleSection(),
          const SizedBox(height: 1),
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                width: widget.width,
                decoration: BoxDecoration(
                  border: Border.all(
                    color: Colors.black.withValues(alpha: .25 * 255),
                  ),
                  color: Colors.white.withValues(alpha: 0.5 * 255),
                  borderRadius: BorderRadius.circular(3),
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    if (widget.component.properties.isNotEmpty)
                      ..._buildSectionHeader("Properties"),
                    ...widget.component.properties.map(
                      (property) => _buildPropertyRow(property),
                    ),
                    if (widget.component.actions.isNotEmpty)
                      ..._buildSectionHeader("Actions"),
                    ...widget.component.actions.map(
                      (action) => _buildActionRow(action),
                    ),
                    if (widget.component.topics.isNotEmpty)
                      ..._buildSectionHeader("Topics"),
                    ...widget.component.topics.map(
                      (topic) => _buildTopicRow(topic),
                    ),
                  ],
                ),
              ),
              _buildResizeHandle(),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildTitleSection() {
    return SizedBox(
      height: itemTitleSectionHeight,
      width: widget.width,
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Expanded(
            child: Text(
              widget.component.id,
              style: const TextStyle(
                fontSize: 11,
                fontWeight: FontWeight.bold,
                color: Colors.black87,
              ),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 3, vertical: 1),
            margin: const EdgeInsets.only(left: 3),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(3),
              border: Border.all(color: Colors.black45, width: 0.5),
            ),
            child: Text(
              getComponentSymbol(widget.component),
              style: TextStyle(
                fontSize: 9,
                fontWeight: FontWeight.bold,
                color: getComponentTextColor(widget.component),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildResizeHandle() {
    return GestureDetector(
      onHorizontalDragUpdate: (details) {
        double newWidth = widget.width + details.delta.dx;
        if (newWidth >= 80.0) {
          widget.onWidthChanged(widget.component.id, newWidth);
        }
      },
      child: MouseRegion(
        cursor: SystemMouseCursors.resizeLeftRight,
        child: Container(
          width: 6.0,
          height: widget.height,
          color: Colors.transparent,
          child: Center(
            child: Container(
              width: 2.0,
              height: 16.0,
              decoration: BoxDecoration(
                color: Colors.grey.withValues(alpha: 0.7 * 255),
                borderRadius: BorderRadius.circular(1.0),
              ),
            ),
          ),
        ),
      ),
    );
  }

  List<Widget> _buildSectionHeader(String title) {
    return [
      Container(
        color: Colors.grey.shade200,
        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 1),
        child: Text(
          title,
          style: TextStyle(
            fontWeight: FontWeight.bold,
            fontSize: 9,
            color: Colors.grey.shade800,
          ),
        ),
      ),
    ];
  }

  Widget _buildPropertyRow(Property property) {
    final isInput = property.isInput;
    final label = property.name;

    return DragTarget<SlotDragInfo>(
      onAcceptWithDetails: (DragTargetDetails<SlotDragInfo> details) {
        widget.onSlotDragAccepted(
          SlotDragInfo(widget.component.id, property.index),
        );
      },
      builder: (context, candidateData, rejectedData) {
        return LongPressDraggable<SlotDragInfo>(
          data: SlotDragInfo(widget.component.id, property.index),
          feedback: Material(
            elevation: 3.0,
            color: Colors.transparent,
            child: Container(
              height: rowHeight,
              decoration: BoxDecoration(
                color: Colors.indigo.withValues(alpha: 0.2 * 255),
                border: Border.all(color: Colors.indigo, width: 1.0),
                borderRadius: BorderRadius.circular(2.0),
              ),
              child: Center(
                child: Text(
                  label,
                  style: const TextStyle(
                    fontSize: 9,
                    color: Colors.indigo,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          ),
          onDragStarted: () {
            widget.onSlotDragStarted(
              SlotDragInfo(widget.component.id, property.index),
            );
          },
          child: Container(
            height: rowHeight,
            alignment: Alignment.centerLeft,
            padding: const EdgeInsets.symmetric(horizontal: 4.0),
            decoration: BoxDecoration(
              color: (candidateData.isNotEmpty)
                  ? Colors.lightBlue.withValues(alpha: 0.3 * 255)
                  : null,
              border: Border(
                bottom: BorderSide(
                  color: Colors.black.withValues(alpha: .15 * 255),
                  width: 0.5,
                ),
              ),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      isInput ? Icons.arrow_back : Icons.arrow_forward,
                      size: 12,
                      color: Colors.indigo.withValues(alpha: 0.6 * 255),
                    ),
                    const SizedBox(width: 3),
                    Text(
                      label,
                      style: TextStyle(
                        fontSize: 9,
                        color: Colors.black.withValues(alpha: 0.8 * 255),
                      ),
                    ),
                    const SizedBox(width: 3),
                    buildTypeIndicator(property.type),
                  ],
                ),
                _buildPropertyValueDisplay(property),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildActionRow(ActionSlot action) {
    final label = action.name;

    return DragTarget<SlotDragInfo>(
      onAcceptWithDetails: (DragTargetDetails<SlotDragInfo> details) {
        widget.onSlotDragAccepted(
          SlotDragInfo(widget.component.id, action.index),
        );
      },
      builder: (context, candidateData, rejectedData) {
        return LongPressDraggable<SlotDragInfo>(
          data: SlotDragInfo(widget.component.id, action.index),
          feedback: Material(
            elevation: 3.0,
            color: Colors.transparent,
            child: Container(
              height: rowHeight,
              decoration: BoxDecoration(
                color: Colors.amber.withValues(alpha: 0.2 * 255),
                border: Border.all(color: Colors.amber.shade800, width: 1.0),
                borderRadius: BorderRadius.circular(2.0),
              ),
              child: Center(
                child: Text(
                  label,
                  style: TextStyle(
                    fontSize: 9,
                    color: Colors.amber.shade800,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          ),
          onDragStarted: () {
            widget.onSlotDragStarted(
              SlotDragInfo(widget.component.id, action.index),
            );
          },
          child: Container(
            height: rowHeight,
            alignment: Alignment.centerLeft,
            padding: const EdgeInsets.symmetric(horizontal: 4.0),
            decoration: BoxDecoration(
              color: (candidateData.isNotEmpty)
                  ? Colors.amber.withValues(alpha: 0.2 * 255)
                  : null,
              border: Border(
                bottom: BorderSide(
                  color: Colors.black.withValues(alpha: .15 * 255),
                  width: 0.5,
                ),
              ),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.flash_on,
                      size: 12,
                      color: Colors.amber.shade800,
                    ),
                    const SizedBox(width: 3),
                    Text(
                      label,
                      style: TextStyle(
                        fontSize: 9,
                        color: Colors.black.withValues(alpha: 0.8 * 255),
                      ),
                    ),
                    if (action.parameterType != null) ...[
                      const SizedBox(width: 3),
                      buildTypeIndicator(action.parameterType!),
                    ],
                  ],
                ),
                IconButton(
                  icon: Icon(
                    Icons.play_arrow,
                    size: 12,
                    color: Colors.amber.shade800,
                  ),
                  constraints: const BoxConstraints.tightFor(
                    width: 20,
                    height: 20,
                  ),
                  padding: EdgeInsets.zero,
                  onPressed: () {
                    widget.onValueChanged(
                      widget.component.id,
                      action.index,
                      null,
                    );
                  },
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildTopicRow(Topic topic) {
    final label = topic.name;

    return DragTarget<SlotDragInfo>(
      onAcceptWithDetails: (DragTargetDetails<SlotDragInfo> details) {
        widget.onSlotDragAccepted(
          SlotDragInfo(widget.component.id, topic.index),
        );
      },
      builder: (context, candidateData, rejectedData) {
        return LongPressDraggable<SlotDragInfo>(
          data: SlotDragInfo(widget.component.id, topic.index),
          feedback: Material(
            elevation: 3.0,
            color: Colors.transparent,
            child: Container(
              height: rowHeight,
              decoration: BoxDecoration(
                color: Colors.green.withValues(alpha: 0.2 * 255),
                border: Border.all(color: Colors.green.shade800, width: 1.0),
                borderRadius: BorderRadius.circular(2.0),
              ),
              child: Center(
                child: Text(
                  label,
                  style: TextStyle(
                    fontSize: 9,
                    color: Colors.green.shade800,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          ),
          onDragStarted: () {
            widget.onSlotDragStarted(
              SlotDragInfo(widget.component.id, topic.index),
            );
          },
          child: Container(
            height: rowHeight,
            alignment: Alignment.centerLeft,
            padding: const EdgeInsets.symmetric(horizontal: 4.0),
            decoration: BoxDecoration(
              color: (candidateData.isNotEmpty)
                  ? Colors.green.withValues(alpha: 0.2 * 255)
                  : null,
              border: Border(
                bottom: BorderSide(
                  color: Colors.black.withValues(alpha: .15 * 255),
                  width: 0.5,
                ),
              ),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.volume_up,
                      size: 12,
                      color: Colors.green.shade800,
                    ),
                    const SizedBox(width: 3),
                    Text(
                      label,
                      style: TextStyle(
                        fontSize: 9,
                        color: Colors.black.withValues(alpha: 0.8 * 255),
                      ),
                    ),
                    const SizedBox(width: 3),
                    buildTypeIndicator(topic.eventType),
                  ],
                ),
                if (topic.lastEvent != null)
                  Padding(
                    padding: const EdgeInsets.only(right: 6.0),
                    child: Text(
                      _formatEventValue(topic.lastEvent),
                      style: TextStyle(
                        fontSize: 8,
                        color: Colors.green.shade800,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
              ],
            ),
          ),
        );
      },
    );
  }

  String _formatEventValue(dynamic value) {
    if (value == null) return "null";
    if (value is bool) return value ? "T" : "F";
    if (value is num) return value.toStringAsFixed(1);
    if (value is String) {
      return '"${value.length > 4 ? '${value.substring(0, 4)}...' : value}"';
    }
    return value.toString();
  }

  Widget _buildPropertyValueDisplay(Property property) {
    Component component = widget.component;
    bool canEdit =
        !property.isInput && component.inputConnections[property.index] == null;

    switch (property.type.type) {
      case PortType.BOOLEAN:
        return GestureDetector(
          onTap: canEdit
              ? () {
                  widget.onValueChanged(
                    widget.component.id,
                    property.index,
                    !(property.value as bool),
                  );
                }
              : null,
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                width: 28,
                height: 14,
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(7),
                  color: property.value as bool
                      ? Colors.green
                      : Colors.red[300],
                  border: Border.all(color: Colors.black45, width: 0.5),
                ),
                child: AnimatedAlign(
                  duration: const Duration(milliseconds: 150),
                  alignment: property.value as bool
                      ? Alignment.centerRight
                      : Alignment.centerLeft,
                  child: Container(
                    width: 14,
                    height: 14,
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      color: Colors.white,
                      border: Border.all(color: Colors.black45, width: 0.5),
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 3),
              Text(
                property.value as bool ? 'T' : 'F',
                style: TextStyle(
                  fontSize: 8,
                  fontWeight: FontWeight.bold,
                  color: property.value as bool
                      ? Colors.green[800]
                      : Colors.red[800],
                ),
              ),
            ],
          ),
        );

      case PortType.NUMERIC:
        return Padding(
          padding: const EdgeInsets.only(right: 6.0),
          child: Text(
            (property.value as num).toStringAsFixed(1),
            style: TextStyle(
              fontSize: 9,
              fontWeight: FontWeight.bold,
              color: Colors.teal[800],
            ),
          ),
        );

      case PortType.STRING:
        return Container(
          width: 50,
          padding: const EdgeInsets.only(right: 6.0),
          child: Tooltip(
            message: property.value as String,
            child: Text(
              '"${(property.value as String).length > 4 ? '${(property.value as String).substring(0, 4)}...' : property.value as String}"',
              style: TextStyle(
                fontSize: 9,
                fontWeight: FontWeight.bold,
                color: Colors.orange[800],
              ),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
              textAlign: TextAlign.right,
            ),
          ),
        );

      case PortType.ANY:
        if (property.value is bool) {
          return Text(
            property.value as bool ? 'true' : 'false',
            style: TextStyle(
              fontSize: 8,
              fontWeight: FontWeight.bold,
              color: Colors.purple[800],
            ),
          );
        } else if (property.value is num) {
          return Text(
            (property.value as num).toStringAsFixed(1),
            style: TextStyle(
              fontSize: 8,
              fontWeight: FontWeight.bold,
              color: Colors.purple[800],
            ),
          );
        } else if (property.value is String) {
          return Text(
            '"${(property.value as String).length > 6 ? '${(property.value as String).substring(0, 6)}...' : property.value as String}"',
            style: TextStyle(
              fontSize: 8,
              fontWeight: FontWeight.bold,
              color: Colors.purple[800],
            ),
          );
        } else {
          return Text(
            "null",
            style: TextStyle(
              fontSize: 8,
              fontWeight: FontWeight.bold,
              color: Colors.purple[800],
            ),
          );
        }
    }
    return const SizedBox();
  }
}
import 'dart:math';
import 'package:flutter/material.dart';
import '../models/component.dart';
import '../models/connection.dart';
import '../models/port.dart';
import '../models/port_type.dart';
import 'component_widget.dart';
import 'manager.dart';

class ConnectionPainter extends CustomPainter {
  final FlowManager flowManager;
  final Map<String, Offset> componentPositions;
  final Map<String, GlobalKey> componentKeys;
  final Map<String, double> componentWidths;
  final SlotDragInfo? tempLineStartInfo;
  final Offset? tempLineEndPoint;

  static const double rowVerticalOffset = 28.0;
  static const double rowHeight = 36.0;
  static const double itemPadding = 8.0;

  ConnectionPainter({
    required this.flowManager,
    required this.componentPositions,
    required this.componentKeys,
    required this.componentWidths,
    this.tempLineStartInfo,
    this.tempLineEndPoint,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final Paint propertyPaint = Paint()
      ..color = Colors.indigo
      ..strokeWidth = 2.0
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;

    final Paint actionPaint = Paint()
      ..color = Colors.amber.shade700
      ..strokeWidth = 2.0
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;

    final Paint topicPaint = Paint()
      ..color = Colors.green.shade700
      ..strokeWidth = 2.0
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;

    final Paint tempLinePaint = Paint()
      ..color = Colors.blue.withValues(alpha: 0.7 * 255)
      ..strokeWidth = 1.5
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;

    for (final connection in flowManager.connections) {
      _drawConnection(
        canvas,
        connection,
        propertyPaint,
        actionPaint,
        topicPaint,
      );
    }

    if (tempLineStartInfo != null && tempLineEndPoint != null) {
      _drawTempLine(
        canvas,
        tempLineStartInfo!,
        tempLineEndPoint!,
        tempLinePaint,
      );
    }
  }

  void _drawConnection(
    Canvas canvas,
    Connection connection,
    Paint propertyPaint,
    Paint actionPaint,
    Paint topicPaint,
  ) {
    final Component? fromComponent = flowManager.findComponentById(
      connection.fromComponentId,
    );
    final Component? toComponent = flowManager.findComponentById(
      connection.toComponentId,
    );

    if (fromComponent == null || toComponent == null) return;

    final Offset? fromPosition = componentPositions[connection.fromComponentId];
    final Offset? toPosition = componentPositions[connection.toComponentId];

    if (fromPosition == null || toPosition == null) return;

    Slot? fromSlot = fromComponent.getSlotByIndex(connection.fromPortIndex);
    Slot? toSlot = toComponent.getSlotByIndex(connection.toPortIndex);

    if (fromSlot == null || toSlot == null) return;

    Paint paint;
    if (fromSlot is Property && toSlot is Property) {
      paint = propertyPaint;
    } else if (fromSlot is Action || toSlot is Action) {
      paint = actionPaint;
    } else if (fromSlot is Topic || toSlot is Topic) {
      paint = topicPaint;
    } else {
      paint = propertyPaint;
    }

    bool isFromOutput = false;
    if (fromSlot is Property) {
      isFromOutput = !fromSlot.isInput;
    } else if (fromSlot is Action) {
      isFromOutput = false;
    } else if (fromSlot is Topic) {
      isFromOutput = true;
    }

    bool isToOutput = false;
    if (toSlot is Property) {
      isToOutput = !toSlot.isInput;
    } else if (toSlot is Action) {
      isToOutput = false;
    } else if (toSlot is Topic) {
      isToOutput = true;
    }

    int fromRowIndex = _calculateRowIndex(
      fromComponent,
      connection.fromPortIndex,
    );
    int toRowIndex = _calculateRowIndex(toComponent, connection.toPortIndex);

    final fromSlotPos = _calculateSlotPosition(
      fromPosition,
      fromRowIndex,
      isFromOutput,
      fromComponent.id,
    );

    final toSlotPos = _calculateSlotPosition(
      toPosition,
      toRowIndex,
      isToOutput,
      toComponent.id,
    );

    _drawArrowLine(canvas, fromSlotPos, toSlotPos, paint);

    if (fromSlot is Property) {
      _drawTransferredValue(canvas, fromSlotPos, toSlotPos, fromSlot);
    } else if (fromSlot is Topic && fromSlot.lastEvent != null) {
      _drawTransferredTopicEvent(canvas, fromSlotPos, toSlotPos, fromSlot);
    }
  }

  int _calculateRowIndex(Component component, int slotIndex) {
    Slot? slot = component.getSlotByIndex(slotIndex);
    if (slot == null) return 0;

    int propertiesBeforeIndex = 0;
    for (var prop in component.properties) {
      if (prop.index == slotIndex) break;
      propertiesBeforeIndex++;
    }

    int actionsBeforeIndex = 0;
    for (var action in component.actions) {
      if (action.index == slotIndex) break;
      actionsBeforeIndex++;
    }

    int topicsBeforeIndex = 0;
    for (var topic in component.topics) {
      if (topic.index == slotIndex) break;
      topicsBeforeIndex++;
    }

    int rowIndex = 0;

    if (component.properties.isNotEmpty &&
        component.properties.contains(slot)) {
      rowIndex = propertiesBeforeIndex;
      if (component.actions.isNotEmpty || component.topics.isNotEmpty) {
        rowIndex += 1;
      }
    } else if (component.actions.isNotEmpty &&
        component.actions.contains(slot)) {
      rowIndex = component.properties.length + actionsBeforeIndex;
      if (component.properties.isNotEmpty) {
        rowIndex += 1;
      }
      if (component.topics.isNotEmpty) {
        rowIndex += 1;
      }
    } else if (component.topics.isNotEmpty && component.topics.contains(slot)) {
      rowIndex =
          component.properties.length +
          component.actions.length +
          topicsBeforeIndex;
      if (component.properties.isNotEmpty) {
        rowIndex += 1;
      }
      if (component.actions.isNotEmpty) {
        rowIndex += 1;
      }
    }

    return rowIndex;
  }

  void _drawTempLine(
    Canvas canvas,
    SlotDragInfo startInfo,
    Offset endPoint,
    Paint paint,
  ) {
    final Component? fromComponent = flowManager.findComponentById(
      startInfo.componentId,
    );
    if (fromComponent == null) return;

    final Offset? fromPosition = componentPositions[startInfo.componentId];
    if (fromPosition == null) return;

    Slot? fromSlot = fromComponent.getSlotByIndex(startInfo.slotIndex);
    if (fromSlot == null) return;

    bool isOutput = false;
    if (fromSlot is Property) {
      isOutput = !fromSlot.isInput;
    } else if (fromSlot is Topic) {
      isOutput = true;
    }

    int rowIndex = _calculateRowIndex(fromComponent, startInfo.slotIndex);

    final fromSlotPos = _calculateSlotPosition(
      fromPosition,
      rowIndex,
      isOutput,
      fromComponent.id,
    );

    _drawDashedLine(canvas, fromSlotPos, endPoint, paint);
  }

  Offset _calculateSlotPosition(
    Offset itemPosition,
    int rowIndex,
    bool isRightSide,
    String componentId,
  ) {
    final double itemWidth = componentWidths[componentId] ?? 160.0;
    final double totalWidth = itemWidth + (itemPadding * 2);

    final double portX = isRightSide
        ? itemPosition.dx + totalWidth
        : itemPosition.dx;

    final double portY =
        itemPosition.dy +
        itemPadding +
        rowVerticalOffset +
        (rowIndex * rowHeight) +
        (rowHeight / 2);

    return Offset(portX, portY);
  }

  void _drawArrowLine(Canvas canvas, Offset start, Offset end, Paint paint) {
    canvas.drawLine(start, end, paint);

    const double arrowSize = 8.0;
    final double angle = atan2(end.dy - start.dy, end.dx - start.dx);

    final Path arrowPath = Path();
    arrowPath.moveTo(
      end.dx - arrowSize * cos(angle - pi / 7),
      end.dy - arrowSize * sin(angle - pi / 7),
    );
    arrowPath.lineTo(end.dx, end.dy);
    arrowPath.lineTo(
      end.dx - arrowSize * cos(angle + pi / 7),
      end.dy - arrowSize * sin(angle + pi / 7),
    );

    canvas.drawPath(arrowPath, paint);
  }

  void _drawDashedLine(Canvas canvas, Offset start, Offset end, Paint paint) {
    const double dashWidth = 5;
    const double dashSpace = 3;

    final double dx = end.dx - start.dx;
    final double dy = end.dy - start.dy;
    final double distance = sqrt(dx * dx + dy * dy);

    final int dashCount = (distance / (dashWidth + dashSpace)).floor();
    if (dashCount <= 0) return;

    final double stepX = dx / dashCount;
    final double stepY = dy / dashCount;

    final Paint backgroundPaint = Paint()
      ..color = Colors.white.withValues(alpha: 0.5 * 255)
      ..strokeWidth = paint.strokeWidth + 1.0
      ..style = PaintingStyle.stroke
      ..strokeCap = paint.strokeCap;

    canvas.drawLine(start, end, backgroundPaint);

    for (int i = 0; i < dashCount; i++) {
      final double startX =
          start.dx + i * (stepX + stepX * dashSpace / dashWidth);
      final double startY =
          start.dy + i * (stepY + stepY * dashSpace / dashWidth);

      final double endX = startX + stepX;
      final double endY = startY + stepY;

      canvas.drawLine(Offset(startX, startY), Offset(endX, endY), paint);
    }
  }

  void _drawTransferredValue(
    Canvas canvas,
    Offset start,
    Offset end,
    Property property,
  ) {
    final Offset midpoint = Offset(
      (start.dx + end.dx) / 2,
      (start.dy + end.dy) / 2,
    );

    final Paint backgroundPaint = Paint()
      ..color = Colors.white.withValues(alpha: .85 * 255)
      ..style = PaintingStyle.fill;

    Color? borderColor;
    String? displayValue;

    switch (property.type.type) {
      case PortType.BOOLEAN:
        borderColor = (property.value as bool)
            ? Colors.green.withValues(alpha: 0.6 * 255)
            : Colors.red.withValues(alpha: 0.6 * 255);
        displayValue = (property.value as bool) ? 'T' : 'F';
        break;
      case PortType.NUMERIC:
        borderColor = Colors.teal.withValues(alpha: 0.6 * 255);
        num value = property.value as num;
        displayValue = value.toStringAsFixed(1);
        break;
      case PortType.STRING:
        borderColor = Colors.orange.withValues(alpha: 0.6 * 255);
        displayValue =
            '"${(property.value as String).length > 3 ? '${(property.value as String).substring(0, 3)}...' : property.value as String}"';
        break;
      case PortType.ANY:
        borderColor = Colors.purple.withValues(alpha: 0.6 * 255);
        if (property.value == null) {
          displayValue = 'null';
        } else if (property.value is bool) {
          displayValue = (property.value as bool) ? 'T' : 'F';
        } else if (property.value is num) {
          displayValue = (property.value as num).toStringAsFixed(1);
        } else {
          displayValue = '${property.value}';
        }
        break;
    }

    final Paint borderPaint = Paint()
      ..color = borderColor!
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;

    const double bubbleRadius = 14.0;
    canvas.drawCircle(midpoint, bubbleRadius, backgroundPaint);
    canvas.drawCircle(midpoint, bubbleRadius, borderPaint);

    final textSpan = TextSpan(
      text: displayValue,
      style: TextStyle(
        color: borderColor,
        fontSize: 10,
        fontWeight: FontWeight.bold,
      ),
    );

    final textPainter = TextPainter(
      text: textSpan,
      textDirection: TextDirection.ltr,
    );

    textPainter.layout();
    textPainter.paint(
      canvas,
      Offset(
        midpoint.dx - textPainter.width / 2,
        midpoint.dy - textPainter.height / 2,
      ),
    );
  }

  void _drawTransferredTopicEvent(
    Canvas canvas,
    Offset start,
    Offset end,
    Topic topic,
  ) {
    final Offset midpoint = Offset(
      (start.dx + end.dx) / 2,
      (start.dy + end.dy) / 2,
    );

    final Paint backgroundPaint = Paint()
      ..color = Colors.white.withValues(alpha: .85 * 255)
      ..style = PaintingStyle.fill;

    Color borderColor = Colors.green.withValues(alpha: 0.6 * 255);
    String displayValue = _formatEventValue(topic.lastEvent);

    final Paint borderPaint = Paint()
      ..color = borderColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;

    const double bubbleSize = 20.0;
    final Rect bubbleRect = Rect.fromCenter(
      center: midpoint,
      width: bubbleSize,
      height: bubbleSize,
    );
    canvas.drawRect(bubbleRect, backgroundPaint);
    canvas.drawRect(bubbleRect, borderPaint);

    final textSpan = TextSpan(
      text: displayValue,
      style: TextStyle(
        color: borderColor,
        fontSize: 10,
        fontWeight: FontWeight.bold,
      ),
    );

    final textPainter = TextPainter(
      text: textSpan,
      textDirection: TextDirection.ltr,
    );

    textPainter.layout();

    textPainter.paint(
      canvas,
      Offset(
        midpoint.dx - textPainter.width / 2,
        midpoint.dy - textPainter.height / 2,
      ),
    );
  }

  String _formatEventValue(dynamic value) {
    if (value == null) return "null";
    if (value is bool) return value ? "T" : "F";
    if (value is num) return value.toStringAsFixed(1);
    if (value is String) {
      return '"${value.length > 3 ? '${value.substring(0, 3)}...' : value}"';
    }
    return value.toString();
  }

  @override
  bool shouldRepaint(covariant ConnectionPainter oldDelegate) {
    return true; // Simplifying - always repaint on state changes
  }
}
import 'package:flutter/material.dart';

class GridPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.grey[300]!
      ..strokeWidth = 0.5;

    for (double i = 0; i < size.width; i += 20) {
      canvas.drawLine(Offset(i, 0), Offset(i, size.height), paint);
    }

    for (double i = 0; i < size.height; i += 20) {
      canvas.drawLine(Offset(0, i), Offset(size.width, i), paint);
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}
import 'package:flutter/material.dart';
import '../models/command_history.dart';
import '../models/component.dart';
import '../models/connection.dart';
import '../models/port.dart';
import '../models/port_type.dart';
import 'manager.dart';
import 'command.dart';
import 'resize_component_command.dart';

class FlowHandlers {
  final FlowManager flowManager;
  final CommandHistory commandHistory;
  final Map<String, Offset> componentPositions;
  final Map<String, GlobalKey> componentKeys;
  final Map<String, double> componentWidths;
  final Function(void Function()) setState;
  final Function() updateCanvasSize;
  final Set<Component> selectedComponents;
  final List<Component> clipboardComponents;
  final List<Offset> clipboardPositions;
  final List<Connection> clipboardConnections;
  final Function(Offset) setClipboardComponentPosition;

  FlowHandlers({
    required this.flowManager,
    required this.commandHistory,
    required this.componentPositions,
    required this.componentKeys,
    required this.componentWidths,
    required this.setState,
    required this.updateCanvasSize,
    required this.selectedComponents,
    required this.clipboardComponents,
    required this.clipboardPositions,
    required this.clipboardConnections,
    required this.setClipboardComponentPosition,
  });

  void handleWidthChanged(String componentId, double newWidth) {
    setState(() {
      componentWidths[componentId] = newWidth;
    });
  }

  void handleComponentResize(String componentId, double newWidth) {
    final oldWidth = componentWidths[componentId] ?? 160.0;

    setState(() {
      final command = ResizeComponentCommand(
        componentId,
        newWidth,
        oldWidth,
        componentWidths,
      );
      commandHistory.execute(command);
    });
  }

  void handleValueChanged(String componentId, int slotIndex, dynamic newValue) {
    Component? component = flowManager.findComponentById(componentId);
    if (component != null) {
      Slot? slot = component.getSlotByIndex(slotIndex);

      if (slot != null) {
        dynamic oldValue;
        if (slot is Property) {
          oldValue = slot.value;
        } else if (slot is ActionSlot) {
          oldValue = slot.parameter;
        }

        if (oldValue != newValue) {
          setState(() {
            final command = UpdatePortValueCommand(
              flowManager,
              componentId,
              slotIndex,
              newValue,
              oldValue,
            );
            commandHistory.execute(command);
          });
        }
      }
    }
  }

  void handleDeleteComponent(Component component) {
    final affectedConnections = flowManager.connections
        .where((connection) =>
            connection.fromComponentId == component.id ||
            connection.toComponentId == component.id)
        .toList();

    setState(() {
      final oldPosition = componentPositions[component.id] ?? Offset.zero;
      final oldKey = componentKeys[component.id];

      final command = RemoveComponentCommand(
        flowManager,
        component,
        oldPosition,
        oldKey,
        affectedConnections,
      );
      commandHistory.execute(command);

      updateCanvasSize();
    });
  }

  void handleEditComponent(BuildContext context, Component component) {
    TextEditingController nameController =
        TextEditingController(text: component.id);

    Map<int, TextEditingController> propertyControllers = {};
    List<Property> editableProperties = component.properties
        .where((prop) =>
            !prop.isInput &&
            !component.inputConnections.containsKey(prop.index))
        .toList();

    for (var property in editableProperties) {
      if (property.type.type != PortType.BOOLEAN) {
        String valueText = property.value?.toString() ?? '';
        propertyControllers[property.index] =
            TextEditingController(text: valueText);
      }
    }

    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setDialogState) {
          return AlertDialog(
            title: const Text('Edit Component'),
            content: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  TextField(
                    controller: nameController,
                    decoration:
                        const InputDecoration(labelText: 'Component Name'),
                    autofocus: true,
                  ),
                  const SizedBox(height: 16),
                  if (editableProperties.isNotEmpty) ...[
                    const Text(
                      'Properties',
                      style: TextStyle(fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 8),
                    ...editableProperties.map((property) {
                      if (property.type.type == PortType.BOOLEAN) {
                        return const SizedBox.shrink();
                      }

                      return Padding(
                        padding: const EdgeInsets.only(bottom: 8.0),
                        child: TextField(
                          controller: propertyControllers[property.index],
                          decoration: InputDecoration(
                            labelText: '${property.name} Value',
                            helperText: 'Type: ${property.type.type}',
                          ),
                          keyboardType: property.type.type == PortType.NUMERIC
                              ? TextInputType.number
                              : TextInputType.text,
                        ),
                      );
                    }),
                  ],
                ],
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text('Cancel'),
              ),
              TextButton(
                onPressed: () {
                  String newName = nameController.text.trim();
                  if (newName.isNotEmpty && newName != component.id) {
                    component.id = newName;
                  }

                  for (var property in editableProperties) {
                    if (property.type.type != PortType.BOOLEAN &&
                        propertyControllers.containsKey(property.index)) {
                      String newValueText =
                          propertyControllers[property.index]!.text;

                      dynamic newValue;

                      if (property.type.type == PortType.NUMERIC) {
                        newValue = num.tryParse(newValueText) ?? property.value;
                      } else if (property.type.type == PortType.STRING) {
                        newValue = newValueText;
                      } else if (property.type.type == PortType.ANY) {
                        newValue = num.tryParse(newValueText);
                        newValue ??= newValueText;
                      }

                      if (newValue != property.value) {
                        handleValueChanged(
                            component.id, property.index, newValue);
                      }
                    }
                  }

                  Navigator.pop(context);
                  setState(() {});
                },
                child: const Text('Save'),
              ),
            ],
          );
        },
      ),
    );
  }

  void handleCopyComponent(Component component) {
    clipboardComponents.clear();
    clipboardPositions.clear();
    clipboardConnections.clear();

    clipboardComponents.add(component);
    clipboardPositions.add(componentPositions[component.id] ?? Offset.zero);
    setClipboardComponentPosition(
        componentPositions[component.id] ?? Offset.zero);
  }

  void handleCopyMultipleComponents() {
    if (selectedComponents.isEmpty) return;

    clipboardComponents.clear();
    clipboardPositions.clear();
    clipboardConnections.clear();

    Map<String, int> componentIndexMap = {};

    for (int i = 0; i < selectedComponents.length; i++) {
      var component = selectedComponents.elementAt(i);
      clipboardComponents.add(component);
      clipboardPositions.add(componentPositions[component.id] ?? Offset.zero);
      componentIndexMap[component.id] = i;
    }

    for (var connection in flowManager.connections) {
      bool fromSelected =
          componentIndexMap.containsKey(connection.fromComponentId);
      bool toSelected = componentIndexMap.containsKey(connection.toComponentId);

      if (fromSelected && toSelected) {
        clipboardConnections.add(connection);
      }
    }

    if (clipboardComponents.isNotEmpty) {
      setClipboardComponentPosition(clipboardPositions.first);
    }
  }

  void handlePasteComponent(Offset position) {
    if (clipboardComponents.isEmpty) return;

    Map<String, String> idMap = {};

    for (int i = 0; i < clipboardComponents.length; i++) {
      var originalComponent = clipboardComponents[i];
      var originalPosition = clipboardPositions[i];

      Offset relativeToPastePoint = originalPosition - clipboardPositions[0];
      Offset newPosition = position + relativeToPastePoint;

      String newName = '${originalComponent.id} (Copy)';
      int counter = 1;
      while (flowManager.components.any((comp) => comp.id == newName)) {
        counter++;
        newName = '${originalComponent.id} (Copy $counter)';
      }

      Component newComponent = flowManager.createComponentByType(
          newName, originalComponent.type.type);

      for (var sourceProperty in originalComponent.properties) {
        if (!originalComponent.inputConnections
            .containsKey(sourceProperty.index)) {
          for (var targetProperty in newComponent.properties) {
            if (targetProperty.index == sourceProperty.index) {
              targetProperty.value = sourceProperty.value;
              break;
            }
          }
        }
      }

      final newKey = GlobalKey();

      Map<String, dynamic> state = {
        'position': newPosition,
        'key': newKey,
        'positions': componentPositions,
        'keys': componentKeys,
      };

      idMap[originalComponent.id] = newComponent.id;
      final command = AddComponentCommand(flowManager, newComponent, state);
      commandHistory.execute(command);

      componentPositions[newComponent.id] = newPosition;
      componentKeys[newComponent.id] = newKey;
    }

    for (var connection in clipboardConnections) {
      String? newFromId = idMap[connection.fromComponentId];
      String? newToId = idMap[connection.toComponentId];

      if (newFromId != null && newToId != null) {
        final command = CreateConnectionCommand(
          flowManager,
          newFromId,
          connection.fromPortIndex,
          newToId,
          connection.toPortIndex,
        );
        commandHistory.execute(command);
      }
    }

    setState(() {
      updateCanvasSize();
    });
  }

  void handlePasteSpecialComponent(
      Offset position, int numberOfCopies, bool keepAllLinks) {
    if (clipboardComponents.isEmpty) return;

    const double offsetX = 50.0;
    const double offsetY = 50.0;

    for (int copyIndex = 0; copyIndex < numberOfCopies; copyIndex++) {
      final double baseOffsetX = copyIndex * offsetX;
      final double baseOffsetY = copyIndex * offsetY;

      Map<String, String> idMap = {};

      for (int i = 0; i < clipboardComponents.length; i++) {
        var originalComponent = clipboardComponents[i];
        var originalPosition = clipboardPositions[i];

        Offset relativeToPastePoint = originalPosition - clipboardPositions[0];

        Offset newPosition = Offset(
          position.dx + baseOffsetX + relativeToPastePoint.dx,
          position.dy + baseOffsetY + relativeToPastePoint.dy,
        );

        String newName = '${originalComponent.id} (Copy)';
        int counter = 1;
        while (flowManager.components.any((comp) => comp.id == newName)) {
          counter++;
          newName = '${originalComponent.id} (Copy $counter)';
        }

        Component newComponent = flowManager.createComponentByType(
            newName, originalComponent.type.type);

        for (var sourceProperty in originalComponent.properties) {
          if (!originalComponent.inputConnections
                  .containsKey(sourceProperty.index) ||
              !keepAllLinks) {
            for (var targetProperty in newComponent.properties) {
              if (targetProperty.index == sourceProperty.index) {
                targetProperty.value = sourceProperty.value;
                break;
              }
            }
          }
        }

        final newKey = GlobalKey();

        Map<String, dynamic> state = {
          'position': newPosition,
          'key': newKey,
          'positions': componentPositions,
          'keys': componentKeys,
        };

        idMap[originalComponent.id] = newComponent.id;
        final command = AddComponentCommand(flowManager, newComponent, state);
        commandHistory.execute(command);

        componentPositions[newComponent.id] = newPosition;
        componentKeys[newComponent.id] = newKey;
      }

      if (keepAllLinks) {
        for (var connection in clipboardConnections) {
          String? newFromId = idMap[connection.fromComponentId];
          String? newToId = idMap[connection.toComponentId];

          if (newFromId != null && newToId != null) {
            final command = CreateConnectionCommand(
              flowManager,
              newFromId,
              connection.fromPortIndex,
              newToId,
              connection.toPortIndex,
            );
            commandHistory.execute(command);
          }
        }
      }
    }

    setState(() {
      updateCanvasSize();
    });
  }

  void handleMoveComponentDown(Component component) {
    Offset? canvasPosition = componentPositions[component.id];
    if (canvasPosition != null) {
      canvasPosition = Offset(canvasPosition.dx, canvasPosition.dy + 20);
      setState(() {
        final command = MoveComponentCommand(
          component.id,
          canvasPosition!,
          componentPositions[component.id]!,
          componentPositions,
        );
        commandHistory.execute(command);
        updateCanvasSize();
      });
    }
  }

  void handleMoveComponentUp(Component component) {
    Offset? canvasPosition = componentPositions[component.id];
    if (canvasPosition != null) {
      canvasPosition = Offset(canvasPosition.dx, canvasPosition.dy - 20);
      setState(() {
        final command = MoveComponentCommand(
          component.id,
          canvasPosition!,
          componentPositions[component.id]!,
          componentPositions,
        );
        commandHistory.execute(command);
        updateCanvasSize();
      });
    }
  }

  void handleMoveComponentLeft(Component component) {
    Offset? canvasPosition = componentPositions[component.id];
    if (canvasPosition != null) {
      canvasPosition = Offset(canvasPosition.dx - 20, canvasPosition.dy);
      setState(() {
        final command = MoveComponentCommand(
          component.id,
          canvasPosition!,
          componentPositions[component.id]!,
          componentPositions,
        );
        commandHistory.execute(command);
        updateCanvasSize();
      });
    }
  }

  void handleMoveComponentRight(Component component) {
    Offset? canvasPosition = componentPositions[component.id];
    if (canvasPosition != null) {
      canvasPosition = Offset(canvasPosition.dx + 20, canvasPosition.dy);
      setState(() {
        final command = MoveComponentCommand(
          component.id,
          canvasPosition!,
          componentPositions[component.id]!,
          componentPositions,
        );
        commandHistory.execute(command);
        updateCanvasSize();
      });
    }
  }
}
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class UndoIntent extends Intent {
  const UndoIntent();
}

class RedoIntent extends Intent {
  const RedoIntent();
}

class CopyIntent extends Intent {
  const CopyIntent();
}

class PasteIntent extends Intent {
  const PasteIntent();
}

class DeleteIntent extends Intent {
  const DeleteIntent();
}

class MoveUpIntent extends Intent {
  const MoveUpIntent();
}

class MoveDownIntent extends Intent {
  const MoveDownIntent();
}

class MoveLeftIntent extends Intent {
  const MoveLeftIntent();
}

class MoveRightIntent extends Intent {
  const MoveRightIntent();
}

class SelectAllIntent extends Intent {
  const SelectAllIntent();
}

Map<LogicalKeySet, Intent> getShortcuts() {
  // TODO: include MAC shortcuts
  return <LogicalKeySet, Intent>{
    LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyZ):
        const UndoIntent(),
    LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyY):
        const RedoIntent(),
    LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyC):
        const CopyIntent(),
    LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyV):
        const PasteIntent(),
    LogicalKeySet(LogicalKeyboardKey.delete): const DeleteIntent(),
    LogicalKeySet(LogicalKeyboardKey.arrowDown): const MoveDownIntent(),
    LogicalKeySet(LogicalKeyboardKey.arrowLeft): const MoveLeftIntent(),
    LogicalKeySet(LogicalKeyboardKey.arrowRight): const MoveRightIntent(),
    LogicalKeySet(LogicalKeyboardKey.arrowUp): const MoveUpIntent(),
    LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyA):
        const SelectAllIntent(),
  };
}
import '../models/component.dart';
import '../models/connection.dart';
import '../models/component_type.dart';
import '../models/helvar_device_component.dart';
import '../models/logic_components.dart';
import '../models/math_components.dart';
import '../models/point_components.dart';
import '../models/port_type.dart';
import '../models/port.dart';
import '../models/rectangle.dart';

class FlowManager {
  List<Component> components = [];
  List<Connection> connections = [];

  void addComponent(Component component) {
    components.add(component);
  }

  void removeComponent(String componentId) {
    components.removeWhere((component) => component.id == componentId);
    connections.removeWhere(
      (connection) =>
          connection.fromComponentId == componentId ||
          connection.toComponentId == componentId,
    );

    recalculateAll();
  }

  Component? findComponentById(String id) {
    try {
      return components.firstWhere((component) => component.id == id);
    } catch (e) {
      return null;
    }
  }

  bool canCreateConnection(
    String fromComponentId,
    int fromPortIndex,
    String toComponentId,
    int toPortIndex,
  ) {
    Component? fromComponent = findComponentById(fromComponentId);
    Component? toComponent = findComponentById(toComponentId);

    if (fromComponent == null || toComponent == null) return false;

    Slot? fromSlot = fromComponent.getSlotByIndex(fromPortIndex);
    Slot? toSlot = toComponent.getSlotByIndex(toPortIndex);

    if (fromSlot == null || toSlot == null) return false;

    if (fromSlot is Property && toSlot is Property) {
      if (fromSlot.isInput || !toSlot.isInput) return false;
      return fromSlot.canConnectTo(toSlot);
    } else if (fromSlot is Property && toSlot is ActionSlot) {
      if (fromSlot.isInput) return false;
      return toSlot.parameterType == null ||
          toSlot.parameterType!.type == PortType.ANY ||
          fromSlot.type.type == toSlot.parameterType!.type;
    } else if (fromSlot is ActionSlot && toSlot is ActionSlot) {
      return true;
    } else if (fromSlot is ActionSlot && toSlot is Topic) {
      return fromSlot.returnType == null ||
          fromSlot.returnType!.type == PortType.ANY ||
          toSlot.eventType.type == fromSlot.returnType!.type;
    } else if (fromSlot is Topic && toSlot is ActionSlot) {
      return toSlot.parameterType == null ||
          toSlot.parameterType!.type == PortType.ANY ||
          fromSlot.eventType.type == toSlot.parameterType!.type;
    } else if (fromSlot is Topic && toSlot is Topic) {
      return toSlot.eventType.type == PortType.ANY ||
          fromSlot.eventType.type == PortType.ANY ||
          toSlot.eventType.type == fromSlot.eventType.type;
    }

    return false;
  }

  void createConnection(
    String fromComponentId,
    int fromPortIndex,
    String toComponentId,
    int toPortIndex,
  ) {
    if (!canCreateConnection(
      fromComponentId,
      fromPortIndex,
      toComponentId,
      toPortIndex,
    )) {
      return;
    }

    bool connectionExists = connections.any(
      (connection) =>
          connection.fromComponentId == fromComponentId &&
          connection.fromPortIndex == fromPortIndex &&
          connection.toComponentId == toComponentId &&
          connection.toPortIndex == toPortIndex,
    );

    if (!connectionExists) {
      Component? fromComponent = findComponentById(fromComponentId);
      Component? toComponent = findComponentById(toComponentId);

      if (fromComponent != null && toComponent != null) {
        connections.add(
          Connection(
            fromComponentId: fromComponentId,
            fromPortIndex: fromPortIndex,
            toComponentId: toComponentId,
            toPortIndex: toPortIndex,
          ),
        );

        toComponent.addInputConnection(
          toPortIndex,
          ConnectionEndpoint(
            componentId: fromComponentId,
            portIndex: fromPortIndex,
          ),
        );

        Slot? fromSlot = fromComponent.getSlotByIndex(fromPortIndex);
        Slot? toSlot = toComponent.getSlotByIndex(toPortIndex);

        if (fromSlot is Property && toSlot is Property) {
          propagatePropertyValue(fromComponent, fromPortIndex);
        }
      }
    }
  }

  void removeConnection(
    String fromComponentId,
    int fromPortIndex,
    String toComponentId,
    int toPortIndex,
  ) {
    connections.removeWhere(
      (connection) =>
          connection.fromComponentId == fromComponentId &&
          connection.fromPortIndex == fromPortIndex &&
          connection.toComponentId == toComponentId &&
          connection.toPortIndex == toPortIndex,
    );

    Component? toComponent = findComponentById(toComponentId);
    if (toComponent != null) {
      toComponent.removeInputConnection(toPortIndex);
    }

    recalculateAll();
  }

  void updatePortValue(String componentId, int portIndex, dynamic value) {
    Component? component = findComponentById(componentId);
    if (component == null) return;

    Slot? slot = component.getSlotByIndex(portIndex);
    if (slot == null) return;

    if (slot is Property) {
      slot.value = value;

      if (slot.isInput) {
        component.calculate();

        for (var property in component.properties.where((p) => !p.isInput)) {
          propagatePropertyValue(component, property.index);
        }

        for (var topic in component.topics) {
          propagateTopicEvent(component, topic.index);
        }
      } else {
        propagatePropertyValue(component, portIndex);
      }
    } else if (slot is ActionSlot) {
      slot.parameter = value;
      dynamic result = slot.execute(parameter: value);

      if (slot.returnType != null && result != null) {
        for (var connection in connections.where(
          (connection) => connection.isFromComponent(componentId, portIndex),
        )) {
          Component? targetComponent = findComponentById(
            connection.toComponentId,
          );
          if (targetComponent != null) {
            Slot? targetSlot = targetComponent.getSlotByIndex(
              connection.toPortIndex,
            );

            if (targetSlot is ActionSlot) {
              updatePortValue(
                connection.toComponentId,
                connection.toPortIndex,
                result,
              );
            } else if (targetSlot is Topic) {
              targetSlot.fire(result);
              propagateTopicEvent(targetComponent, connection.toPortIndex);
            }
          }
        }
      }
    }
  }

  void propagatePropertyValue(
    Component sourceComponent,
    int sourcePropertyIndex,
  ) {
    Property? sourceProperty = sourceComponent.getPropertyByIndex(
      sourcePropertyIndex,
    );
    if (sourceProperty == null || sourceProperty.isInput) return;

    dynamic valueToPropagate = sourceProperty.value;

    List<Connection> outgoingConnections = connections
        .where(
          (connection) => connection.isFromComponent(
            sourceComponent.id,
            sourcePropertyIndex,
          ),
        )
        .toList();

    for (var connection in outgoingConnections) {
      Component? targetComponent = findComponentById(connection.toComponentId);
      if (targetComponent == null) continue;

      Slot? targetSlot = targetComponent.getSlotByIndex(connection.toPortIndex);
      if (targetSlot == null) continue;

      if (targetSlot is Property) {
        targetSlot.value = valueToPropagate;
        targetComponent.calculate();

        for (var property in targetComponent.properties.where(
          (p) => !p.isInput,
        )) {
          propagatePropertyValue(targetComponent, property.index);
        }

        for (var topic in targetComponent.topics) {
          propagateTopicEvent(targetComponent, topic.index);
        }
      } else if (targetSlot is ActionSlot) {
        dynamic result = targetSlot.execute(parameter: valueToPropagate);

        if (result != null) {
          for (var actionConnection in connections.where(
            (conn) => conn.isFromComponent(
              targetComponent.id,
              connection.toPortIndex,
            ),
          )) {
            Component? actionTargetComponent = findComponentById(
              actionConnection.toComponentId,
            );
            if (actionTargetComponent == null) continue;

            Slot? actionTargetSlot = actionTargetComponent.getSlotByIndex(
              actionConnection.toPortIndex,
            );

            if (actionTargetSlot is ActionSlot) {
              actionTargetSlot.execute(parameter: result);
            } else if (actionTargetSlot is Topic) {
              actionTargetSlot.fire(result);
              propagateTopicEvent(
                actionTargetComponent,
                actionConnection.toPortIndex,
              );
            }
          }
        }
      }
    }
  }

  void propagateTopicEvent(Component sourceComponent, int sourceTopicIndex) {
    Topic? sourceTopic = sourceComponent.getTopicByIndex(sourceTopicIndex);
    if (sourceTopic == null) return;

    dynamic eventToPropagate = sourceTopic.lastEvent;
    if (eventToPropagate == null) return;

    List<Connection> outgoingConnections = connections
        .where(
          (connection) =>
              connection.isFromComponent(sourceComponent.id, sourceTopicIndex),
        )
        .toList();

    for (var connection in outgoingConnections) {
      Component? targetComponent = findComponentById(connection.toComponentId);
      if (targetComponent == null) continue;

      Slot? targetSlot = targetComponent.getSlotByIndex(connection.toPortIndex);
      if (targetSlot == null) continue;

      if (targetSlot is ActionSlot) {
        dynamic result = targetSlot.execute(parameter: eventToPropagate);

        if (result != null) {
          for (var actionConnection in connections.where(
            (conn) => conn.isFromComponent(
              targetComponent.id,
              connection.toPortIndex,
            ),
          )) {
            Component? actionTargetComponent = findComponentById(
              actionConnection.toComponentId,
            );
            if (actionTargetComponent == null) continue;

            Slot? actionTargetSlot = actionTargetComponent.getSlotByIndex(
              actionConnection.toPortIndex,
            );

            if (actionTargetSlot is ActionSlot) {
              actionTargetSlot.execute(parameter: result);
            } else if (actionTargetSlot is Topic) {
              actionTargetSlot.fire(result);
              propagateTopicEvent(
                actionTargetComponent,
                actionConnection.toPortIndex,
              );
            }
          }
        }
      } else if (targetSlot is Topic) {
        (targetSlot).fire(eventToPropagate);
        propagateTopicEvent(targetComponent, connection.toPortIndex);
      }
    }
  }

  void recalculateAll() {
    for (var component in components) {
      for (var entry in component.inputConnections.entries) {
        int slotIndex = entry.key;
        Slot? slot = component.getSlotByIndex(slotIndex);

        if (slot is Property && slot.isInput) {
          if (slot.type.type == PortType.BOOLEAN) {
            slot.value = false;
          } else if (slot.type.type == PortType.NUMERIC) {
            slot.value = 0.0;
          } else if (slot.type.type == PortType.STRING) {
            slot.value = '';
          } else if (slot.type.type == PortType.ANY) {
            slot.value = null;
          }
        }
      }
    }

    for (var component in components) {
      if (component.type.isPoint) {
        component.calculate();
      }
    }

    for (var component in components) {
      if (component.type.isPoint) {
        for (var property in component.properties.where((p) => !p.isInput)) {
          propagatePropertyValue(component, property.index);
        }
      }
    }

    for (var component in components) {
      if (!component.type.isPoint) {
        component.calculate();

        for (var property in component.properties.where((p) => !p.isInput)) {
          propagatePropertyValue(component, property.index);
        }

        for (var topic in component.topics) {
          propagateTopicEvent(component, topic.index);
        }
      }
    }
  }

  Component createComponentByType(String id, String typeStr) {
    final type = ComponentType(typeStr);

    if (typeStr == RectangleComponent.RECTANGLE) {
      return RectangleComponent(id: id);
    } else if (type.isLogicGate) {
      return LogicComponent(id: id, type: type);
    } else if (type.isMathOperation) {
      return MathComponent(id: id, type: type);
    } else if (type.isPoint) {
      return PointComponent(id: id, type: type);
    } else if (typeStr == ComponentType.HELVAR_DEVICE ||
        typeStr == ComponentType.HELVAR_INPUT ||
        typeStr == ComponentType.HELVAR_OUTPUT ||
        typeStr == ComponentType.HELVAR_EMERGENCY) {
      // For device components when creating from type (not from an actual device)
      // TODO
      String deviceType = "unknown";
      if (typeStr == ComponentType.HELVAR_INPUT) {
        deviceType = "input";
      } else if (typeStr == ComponentType.HELVAR_OUTPUT) {
        deviceType = "output";
      } else if (typeStr == ComponentType.HELVAR_EMERGENCY) {
        deviceType = "emergency";
      }

      return HelvarDeviceComponent(
        id: id,
        deviceId: 0, // Default ID
        deviceAddress: "", // Empty address
        deviceType: deviceType,
        description: id,
        type: type,
      );
    }

    return PointComponent(
      id: id,
      type: const ComponentType(ComponentType.BOOLEAN_WRITABLE),
    );
  }
}
import 'package:flutter/material.dart';

class PasteSpecialDialog extends StatefulWidget {
  final Function(int, bool, bool) onPasteConfirmed;

  const PasteSpecialDialog({
    super.key,
    required this.onPasteConfirmed,
  });

  @override
  State<PasteSpecialDialog> createState() => _PasteSpecialDialogState();
}

class _PasteSpecialDialogState extends State<PasteSpecialDialog> {
  int numberOfCopies = 1;
  bool keepAllLinks = true;
  bool keepAllRelations = false;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Row(
        children: [
          Icon(Icons.copy, size: 20),
          SizedBox(width: 8),
          Text('Paste Special'),
        ],
      ),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              const Text('Number of copies'),
              const SizedBox(width: 12),
              SizedBox(
                width: 50,
                child: TextField(
                  textAlign: TextAlign.center,
                  keyboardType: TextInputType.number,
                  decoration: const InputDecoration(
                    contentPadding:
                        EdgeInsets.symmetric(horizontal: 6, vertical: 0),
                    border: OutlineInputBorder(),
                  ),
                  controller:
                      TextEditingController(text: numberOfCopies.toString()),
                  onChanged: (value) {
                    int? parsedValue = int.tryParse(value);
                    if (parsedValue != null && parsedValue > 0) {
                      setState(() {
                        numberOfCopies = parsedValue;
                      });
                    }
                  },
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              Checkbox(
                value: keepAllLinks,
                onChanged: (value) {
                  setState(() {
                    keepAllLinks = value ?? true;
                  });
                },
              ),
              const Text('Keep all links'),
            ],
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Cancel'),
        ),
        TextButton(
          onPressed: () {
            widget.onPasteConfirmed(
                numberOfCopies, keepAllLinks, keepAllRelations);
            Navigator.of(context).pop();
          },
          child: const Text('OK'),
        ),
      ],
    );
  }
}
import '../models/command.dart';

class ResizeComponentCommand extends Command {
  final String componentId;
  final double newWidth;
  final double oldWidth;
  final Map<String, double> componentWidths;

  ResizeComponentCommand(
    this.componentId,
    this.newWidth,
    this.oldWidth,
    this.componentWidths,
  );

  @override
  void execute() {
    componentWidths[componentId] = newWidth;
  }

  @override
  void undo() {
    componentWidths[componentId] = oldWidth;
  }

  @override
  String get description => 'Resize $componentId';
}
import 'package:flutter/material.dart';

class SelectionBoxPainter extends CustomPainter {
  final Offset? start;
  final Offset? end;

  SelectionBoxPainter({this.start, this.end});

  @override
  void paint(Canvas canvas, Size size) {
    if (start == null || end == null) return;

    final paint = Paint()
      ..color = Colors.blue.withValues(alpha: 0.2 * 255)
      ..style = PaintingStyle.fill;

    final borderPaint = Paint()
      ..color = Colors.blue
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;

    final rect = Rect.fromPoints(start!, end!);
    canvas.drawRect(rect, paint);
    canvas.drawRect(rect, borderPaint);
  }

  @override
  bool shouldRepaint(SelectionBoxPainter oldDelegate) {
    return oldDelegate.start != start || oldDelegate.end != end;
  }
}
abstract class Command {
  void execute();

  void undo();

  void redo() {
    execute();
  }

  String get description;
}
import 'command.dart';

class CommandHistory {
  final List<Command> _undoStack = [];
  final List<Command> _redoStack = [];
  final int _maxHistorySize;

  CommandHistory({int maxHistorySize = 100}) : _maxHistorySize = maxHistorySize;

  bool get canUndo => _undoStack.isNotEmpty;
  bool get canRedo => _redoStack.isNotEmpty;

  void execute(Command command) {
    command.execute();
    _undoStack.add(command);

    _redoStack.clear();

    if (_undoStack.length > _maxHistorySize) {
      _undoStack.removeAt(0);
    }
  }

  void undo() {
    if (canUndo) {
      final command = _undoStack.removeLast();
      command.undo();
      _redoStack.add(command);
    }
  }

  void redo() {
    if (canRedo) {
      final command = _redoStack.removeLast();
      command.redo();
      _undoStack.add(command);
    }
  }

  void clear() {
    _undoStack.clear();
    _redoStack.clear();
  }

  String? get lastUndoDescription =>
      canUndo ? _undoStack.last.description : null;

  String? get lastRedoDescription =>
      canRedo ? _redoStack.last.description : null;
}
import 'port.dart';
import 'connection.dart';
import 'component_type.dart';

abstract class Component {
  String id;
  final ComponentType type;
  final List<Property> properties;
  final List<ActionSlot> actions;
  final List<Topic> topics;
  Map<int, ConnectionEndpoint> inputConnections = {};

  Component({
    required this.id,
    required this.type,
    List<Property>? properties,
    List<ActionSlot>? actions,
    List<Topic>? topics,
  }) : properties = properties ?? [],
       actions = actions ?? [],
       topics = topics ?? [];

  List<Slot> get allSlots {
    List<Slot> slots = [];
    slots.addAll(properties);
    slots.addAll(actions);
    slots.addAll(topics);
    return slots;
  }

  Property? getPropertyByIndex(int index) {
    try {
      return properties.firstWhere((prop) => prop.index == index);
    } catch (e) {
      return null;
    }
  }

  ActionSlot? getActionByIndex(int index) {
    try {
      return actions.firstWhere((action) => action.index == index);
    } catch (e) {
      return null;
    }
  }

  Topic? getTopicByIndex(int index) {
    try {
      return topics.firstWhere((topic) => topic.index == index);
    } catch (e) {
      return null;
    }
  }

  Slot? getSlotByIndex(int index) {
    Property? property = getPropertyByIndex(index);
    if (property != null) return property;

    ActionSlot? action = getActionByIndex(index);
    if (action != null) return action;

    return getTopicByIndex(index);
  }

  void addInputConnection(int slotIndex, ConnectionEndpoint endpoint) {
    inputConnections[slotIndex] = endpoint;
  }

  void removeInputConnection(int slotIndex) {
    inputConnections.remove(slotIndex);
  }

  void calculate();
}
class ComponentType {
  // Logic gates
  static const String AND_GATE = "AND_GATE";
  static const String OR_GATE = "OR_GATE";
  static const String XOR_GATE = "XOR_GATE";
  static const String NOT_GATE = "NOT_GATE";
  static const String IS_GREATER_THAN = "IS_GREATER_THAN";
  static const String IS_LESS_THAN = "IS_LESS_THAN";
  static const String IS_EQUAL = "IS_EQUAL";

  // Math operations
  static const String ADD = "ADD";
  static const String SUBTRACT = "SUBTRACT";
  static const String MULTIPLY = "MULTIPLY";
  static const String DIVIDE = "DIVIDE";
  static const String MAX = "MAX";
  static const String MIN = "MIN";
  static const String POWER = "POWER";
  static const String ABS = "ABS";

  // Writable points (inputs)
  static const String BOOLEAN_WRITABLE = "BOOLEAN_WRITABLE";
  static const String NUMERIC_WRITABLE = "NUMERIC_WRITABLE";
  static const String STRING_WRITABLE = "STRING_WRITABLE";

  // Read-only points
  static const String BOOLEAN_POINT = "BOOLEAN_POINT";
  static const String NUMERIC_POINT = "NUMERIC_POINT";
  static const String STRING_POINT = "STRING_POINT";

  // Helvar device types
  static const String HELVAR_DEVICE = "HELVAR_DEVICE";
  static const String HELVAR_OUTPUT = "HELVAR_OUTPUT";
  static const String HELVAR_INPUT = "HELVAR_INPUT";
  static const String HELVAR_EMERGENCY = "HELVAR_EMERGENCY";

  final String type;

  const ComponentType(this.type);

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is ComponentType && other.type == type;

  @override
  int get hashCode => type.hashCode;

  bool get isLogicGate =>
      type == AND_GATE ||
      type == OR_GATE ||
      type == NOT_GATE ||
      type == AND_GATE ||
      type == IS_EQUAL ||
      type == IS_LESS_THAN ||
      type == IS_GREATER_THAN;

  bool get isMathOperation =>
      type == ADD ||
      type == SUBTRACT ||
      type == MULTIPLY ||
      type == DIVIDE ||
      type == MAX ||
      type == MIN ||
      type == POWER ||
      type == ABS;

  bool get isWritablePoint =>
      type == BOOLEAN_WRITABLE ||
      type == NUMERIC_WRITABLE ||
      type == STRING_WRITABLE;

  bool get isReadOnlyPoint =>
      type == BOOLEAN_POINT || type == NUMERIC_POINT || type == STRING_POINT;

  bool get isPoint => isWritablePoint || isReadOnlyPoint;

  bool get isBooleanType =>
      type == BOOLEAN_WRITABLE ||
      type == BOOLEAN_POINT ||
      type == AND_GATE ||
      type == OR_GATE ||
      type == XOR_GATE ||
      type == NOT_GATE ||
      type == IS_GREATER_THAN ||
      type == IS_LESS_THAN ||
      type == IS_EQUAL;

  bool get isNumericType =>
      type == NUMERIC_WRITABLE || type == NUMERIC_POINT || isMathOperation;

  bool get isStringType => type == STRING_WRITABLE || type == STRING_POINT;

  static ComponentType fromString(String type) {
    return ComponentType(type);
  }
}
class Connection {
  String fromComponentId;
  int fromPortIndex;
  String toComponentId;
  int toPortIndex;

  Connection({
    required this.fromComponentId,
    required this.fromPortIndex,
    required this.toComponentId,
    required this.toPortIndex,
  });

  bool isFromComponent(String componentId, int portIndex) {
    return fromComponentId == componentId && fromPortIndex == portIndex;
  }

  bool isToComponent(String componentId, int portIndex) {
    return toComponentId == componentId && toPortIndex == portIndex;
  }
}

class ConnectionEndpoint {
  String componentId;
  int portIndex;

  ConnectionEndpoint({required this.componentId, required this.portIndex});
}
import '../models/component.dart';
import '../models/component_type.dart';
import '../models/port.dart';
import '../models/port_type.dart';

class HelvarDeviceComponent extends Component {
  final int deviceId;
  final String deviceAddress;
  final String deviceType;
  final String description;

  HelvarDeviceComponent({
    required super.id,
    required this.deviceId,
    required this.deviceAddress,
    required this.deviceType,
    required this.description,
    ComponentType? type,
  }) : super(type: type ?? const ComponentType(ComponentType.HELVAR_DEVICE)) {
    _setupPorts();
  }

  void _setupPorts() {
    properties.add(
      Property.withDefaultValue(
        name: "Status",
        index: 0,
        isInput: false,
        type: const PortType(PortType.STRING),
      ),
    );

    switch (deviceType) {
      case 'output':
        _setupOutputDevicePorts();
        break;
      case 'input':
        _setupInputDevicePorts();
        break;
      case 'emergency':
        _setupEmergencyDevicePorts();
        break;
    }
  }

  void _setupOutputDevicePorts() {
    actions.add(
      ActionSlot(
        name: "Clear Result",
        index: 1,
        parameterType: const PortType(PortType.BOOLEAN),
      ),
    );

    actions.add(
      ActionSlot(
        name: "Recall Scene",
        index: 2,
        parameterType: const PortType(PortType.NUMERIC),
      ),
    );

    actions.add(
      ActionSlot(
        name: "Direct Level",
        index: 3,
        parameterType: const PortType(PortType.NUMERIC),
      ),
    );

    actions.add(
      ActionSlot(
        name: "Direct Proportion",
        index: 4,
        parameterType: const PortType(PortType.NUMERIC),
      ),
    );

    actions.add(
      ActionSlot(
        name: "Modify Proportion",
        index: 5,
        parameterType: const PortType(PortType.NUMERIC),
      ),
    );
  }

  void _setupInputDevicePorts() {
    actions.add(
      ActionSlot(
        name: "Clear Result",
        index: 1,
        parameterType: const PortType(PortType.BOOLEAN),
      ),
    );

    for (int i = 1; i <= 5; i++) {
      topics.add(
        Topic(
          name: "Button $i",
          index: i + 5,
          eventType: const PortType(PortType.BOOLEAN),
        ),
      );
    }

    topics.add(
      Topic(
        name: "Presence",
        index: 11,
        eventType: const PortType(PortType.BOOLEAN),
      ),
    );
  }

  void _setupEmergencyDevicePorts() {
    actions.add(
      ActionSlot(
        name: "Clear Result",
        index: 1,
        parameterType: const PortType(PortType.BOOLEAN),
      ),
    );

    actions.add(
      ActionSlot(
        name: "Emergency Function Test",
        index: 2,
        parameterType: const PortType(PortType.BOOLEAN),
      ),
    );

    actions.add(
      ActionSlot(
        name: "Emergency Duration Test",
        index: 3,
        parameterType: const PortType(PortType.BOOLEAN),
      ),
    );

    actions.add(
      ActionSlot(
        name: "Stop Emergency Test",
        index: 4,
        parameterType: const PortType(PortType.BOOLEAN),
      ),
    );

    actions.add(
      ActionSlot(
        name: "Reset Emergency Battery",
        index: 5,
        parameterType: const PortType(PortType.BOOLEAN),
      ),
    );

    topics.add(
      Topic(
        name: "Emergency State",
        index: 6,
        eventType: const PortType(PortType.BOOLEAN),
      ),
    );

    topics.add(
      Topic(
        name: "Battery Level",
        index: 7,
        eventType: const PortType(PortType.NUMERIC),
      ),
    );
  }

  @override
  void calculate() {
    // In a real implementation, this would interact with the actual device
    // For now, just a placeholder
  }
}
import 'component.dart';
import 'component_type.dart';
import 'port.dart';
import 'port_type.dart';

class LogicComponent extends Component {
  LogicComponent({required super.id, required super.type}) {
    _setupPorts();
  }

  void _setupPorts() {
    switch (type.type) {
      case ComponentType.AND_GATE:
      case ComponentType.OR_GATE:
      case ComponentType.XOR_GATE:
        properties.add(
          Property.withDefaultValue(
            name: "Input A",
            index: 0,
            isInput: true,
            type: const PortType(PortType.BOOLEAN),
          ),
        );
        properties.add(
          Property.withDefaultValue(
            name: "Input B",
            index: 1,
            isInput: true,
            type: const PortType(PortType.BOOLEAN),
          ),
        );
        properties.add(
          Property.withDefaultValue(
            name: "Output",
            index: 2,
            isInput: false,
            type: const PortType(PortType.BOOLEAN),
          ),
        );
        break;

      case ComponentType.NOT_GATE:
        properties.add(
          Property.withDefaultValue(
            name: "Input",
            index: 0,
            isInput: true,
            type: const PortType(PortType.BOOLEAN),
          ),
        );
        properties.add(
          Property.withDefaultValue(
            name: "Output",
            index: 1,
            isInput: false,
            type: const PortType(PortType.BOOLEAN),
          ),
        );
        break;

      case ComponentType.IS_GREATER_THAN:
      case ComponentType.IS_LESS_THAN:
        properties.add(
          Property.withDefaultValue(
            name: "Input A",
            index: 0,
            isInput: true,
            type: const PortType(PortType.NUMERIC),
          ),
        );
        properties.add(
          Property.withDefaultValue(
            name: "Input B",
            index: 1,
            isInput: true,
            type: const PortType(PortType.NUMERIC),
          ),
        );
        properties.add(
          Property.withDefaultValue(
            name: "Output",
            index: 2,
            isInput: false,
            type: const PortType(PortType.BOOLEAN),
          ),
        );
        break;

      case ComponentType.IS_EQUAL:
        properties.add(
          Property.withDefaultValue(
            name: "Input A",
            index: 0,
            isInput: true,
            type: const PortType(PortType.ANY),
          ),
        );
        properties.add(
          Property.withDefaultValue(
            name: "Input B",
            index: 1,
            isInput: true,
            type: const PortType(PortType.ANY),
          ),
        );
        properties.add(
          Property.withDefaultValue(
            name: "Output",
            index: 2,
            isInput: false,
            type: const PortType(PortType.BOOLEAN),
          ),
        );
        break;
    }
  }

  @override
  void calculate() {
    switch (type.type) {
      // Logic Gates
      case ComponentType.AND_GATE:
        final bool inputA = properties[0].value as bool;
        final bool inputB = properties[1].value as bool;
        properties[2].value = inputA && inputB;
        break;

      case ComponentType.OR_GATE:
        final bool inputA = properties[0].value as bool;
        final bool inputB = properties[1].value as bool;
        properties[2].value = inputA || inputB;
        break;

      case ComponentType.XOR_GATE:
        final bool inputA = properties[0].value as bool;
        final bool inputB = properties[1].value as bool;
        properties[2].value = inputA != inputB;
        break;

      case ComponentType.NOT_GATE:
        final bool input = properties[0].value as bool;
        properties[1].value = !input;
        break;

      // Comparison Components
      case ComponentType.IS_GREATER_THAN:
        final num inputA = properties[0].value as num;
        final num inputB = properties[1].value as num;
        properties[2].value = inputA > inputB;
        break;

      case ComponentType.IS_LESS_THAN:
        final num inputA = properties[0].value as num;
        final num inputB = properties[1].value as num;
        properties[2].value = inputA < inputB;
        break;

      case ComponentType.IS_EQUAL:
        final dynamic inputA = properties[0].value;
        final dynamic inputB = properties[1].value;
        properties[2].value = inputA == inputB;
        break;
    }
  }
}
// math_components.dart
import 'dart:math' show pow;
import 'component.dart';
import 'component_type.dart';
import 'port.dart';
import 'port_type.dart';

class MathComponent extends Component {
  MathComponent({required super.id, required super.type}) {
    _setupPorts();
  }

  void _setupPorts() {
    switch (type.type) {
      case ComponentType.ADD:
      case ComponentType.SUBTRACT:
      case ComponentType.MULTIPLY:
      case ComponentType.DIVIDE:
      case ComponentType.MAX:
      case ComponentType.MIN:
        properties.add(
          Property.withDefaultValue(
            name: "Input A",
            index: 0,
            isInput: true,
            type: const PortType(PortType.NUMERIC),
          ),
        );
        properties.add(
          Property.withDefaultValue(
            name: "Input B",
            index: 1,
            isInput: true,
            type: const PortType(PortType.NUMERIC),
          ),
        );
        properties.add(
          Property.withDefaultValue(
            name: "Output",
            index: 2,
            isInput: false,
            type: const PortType(PortType.NUMERIC),
          ),
        );
        break;

      case ComponentType.POWER:
        properties.add(
          Property.withDefaultValue(
            name: "Base",
            index: 0,
            isInput: true,
            type: const PortType(PortType.NUMERIC),
          ),
        );
        properties.add(
          Property.withDefaultValue(
            name: "Exponent",
            index: 1,
            isInput: true,
            type: const PortType(PortType.NUMERIC),
          ),
        );
        properties.add(
          Property.withDefaultValue(
            name: "Output",
            index: 2,
            isInput: false,
            type: const PortType(PortType.NUMERIC),
          ),
        );
        break;

      case ComponentType.ABS:
        properties.add(
          Property.withDefaultValue(
            name: "Input",
            index: 0,
            isInput: true,
            type: const PortType(PortType.NUMERIC),
          ),
        );
        properties.add(
          Property.withDefaultValue(
            name: "Output",
            index: 1,
            isInput: false,
            type: const PortType(PortType.NUMERIC),
          ),
        );
        break;
    }
  }

  @override
  void calculate() {
    switch (type.type) {
      case ComponentType.ADD:
        final num inputA = properties[0].value as num;
        final num inputB = properties[1].value as num;
        properties[2].value = inputA + inputB;
        break;

      case ComponentType.SUBTRACT:
        final num inputA = properties[0].value as num;
        final num inputB = properties[1].value as num;
        properties[2].value = inputA - inputB;
        break;

      case ComponentType.MULTIPLY:
        final num inputA = properties[0].value as num;
        final num inputB = properties[1].value as num;
        properties[2].value = inputA * inputB;
        break;

      case ComponentType.DIVIDE:
        final num inputA = properties[0].value as num;
        final num inputB = properties[1].value as num;
        properties[2].value = inputB != 0 ? inputA / inputB : double.infinity;
        break;

      case ComponentType.MAX:
        final num inputA = properties[0].value as num;
        final num inputB = properties[1].value as num;
        properties[2].value = inputA > inputB ? inputA : inputB;
        break;

      case ComponentType.MIN:
        final num inputA = properties[0].value as num;
        final num inputB = properties[1].value as num;
        properties[2].value = inputA < inputB ? inputA : inputB;
        break;

      case ComponentType.POWER:
        final num base = properties[0].value as num;
        final num exponent = properties[1].value as num;
        properties[2].value = pow(base, exponent);
        break;

      case ComponentType.ABS:
        final num input = properties[0].value as num;
        properties[1].value = input.abs();
        break;
    }
  }
}
import 'component.dart';
import 'component_type.dart';
import 'port.dart';
import 'port_type.dart';

class PointComponent extends Component {
  PointComponent({required super.id, required super.type}) {
    _setupPorts();
  }

  void _setupPorts() {
    switch (type.type) {
      case ComponentType.BOOLEAN_WRITABLE:
        properties.add(
          Property.withDefaultValue(
            name: "Output",
            index: 0,
            isInput: false,
            type: const PortType(PortType.BOOLEAN),
          ),
        );

        properties.add(
          Property.withDefaultValue(
            name: "In1",
            index: 1,
            isInput: true,
            type: const PortType(PortType.BOOLEAN),
          ),
        );

        properties.add(
          Property.withDefaultValue(
            name: "In2",
            index: 2,
            isInput: true,
            type: const PortType(PortType.BOOLEAN),
          ),
        );

        properties.add(
          Property.withDefaultValue(
            name: "In3",
            index: 3,
            isInput: true,
            type: const PortType(PortType.BOOLEAN),
          ),
        );

        properties.add(
          Property.withDefaultValue(
            name: "In4",
            index: 4,
            isInput: true,
            type: const PortType(PortType.BOOLEAN),
          ),
        );
        break;

      case ComponentType.NUMERIC_WRITABLE:
        properties.add(
          Property.withDefaultValue(
            name: "Output",
            index: 0,
            isInput: false,
            type: const PortType(PortType.NUMERIC),
          ),
        );

        properties.add(
          Property.withDefaultValue(
            name: "In1",
            index: 1,
            isInput: true,
            type: const PortType(PortType.NUMERIC),
          ),
        );

        properties.add(
          Property.withDefaultValue(
            name: "In2",
            index: 2,
            isInput: true,
            type: const PortType(PortType.NUMERIC),
          ),
        );

        properties.add(
          Property.withDefaultValue(
            name: "In3",
            index: 3,
            isInput: true,
            type: const PortType(PortType.NUMERIC),
          ),
        );

        properties.add(
          Property.withDefaultValue(
            name: "In4",
            index: 4,
            isInput: true,
            type: const PortType(PortType.NUMERIC),
          ),
        );
        break;

      case ComponentType.STRING_WRITABLE:
        properties.add(
          Property.withDefaultValue(
            name: "Output",
            index: 0,
            isInput: false,
            type: const PortType(PortType.STRING),
          ),
        );

        properties.add(
          Property.withDefaultValue(
            name: "In1",
            index: 1,
            isInput: true,
            type: const PortType(PortType.STRING),
          ),
        );

        properties.add(
          Property.withDefaultValue(
            name: "In2",
            index: 2,
            isInput: true,
            type: const PortType(PortType.STRING),
          ),
        );

        properties.add(
          Property.withDefaultValue(
            name: "In3",
            index: 3,
            isInput: true,
            type: const PortType(PortType.STRING),
          ),
        );

        properties.add(
          Property.withDefaultValue(
            name: "In4",
            index: 4,
            isInput: true,
            type: const PortType(PortType.STRING),
          ),
        );
        break;

      case ComponentType.BOOLEAN_POINT:
        properties.add(
          Property.withDefaultValue(
            name: "Input",
            index: 0,
            isInput: true,
            type: const PortType(PortType.BOOLEAN),
          ),
        );
        break;

      case ComponentType.NUMERIC_POINT:
        properties.add(
          Property.withDefaultValue(
            name: "Input",
            index: 0,
            isInput: true,
            type: const PortType(PortType.NUMERIC),
          ),
        );
        break;

      case ComponentType.STRING_POINT:
        properties.add(
          Property.withDefaultValue(
            name: "Input",
            index: 0,
            isInput: true,
            type: const PortType(PortType.STRING),
          ),
        );
        break;
    }
  }

  @override
  void calculate() {
    if (type.type == ComponentType.BOOLEAN_WRITABLE ||
        type.type == ComponentType.NUMERIC_WRITABLE ||
        type.type == ComponentType.STRING_WRITABLE) {
      Property outputProperty = properties[0];

      dynamic currentValue = outputProperty.value;

      for (int i = 1; i <= 4; i++) {
        Property inputProperty = properties[i];

        if (inputConnections.containsKey(inputProperty.index)) {
          if (inputProperty.value != null) {
            currentValue = inputProperty.value;
            break;
          }
        }
      }

      outputProperty.value = currentValue;
    }
  }
}
import 'port_type.dart';

abstract class Slot {
  final String name;
  final int index;

  Slot({required this.name, required this.index});
}

class Property extends Slot {
  final bool isInput;
  final PortType type;
  dynamic value;

  Property({
    required super.name,
    required super.index,
    required this.isInput,
    required this.type,
    this.value,
  });

  factory Property.withDefaultValue({
    required String name,
    required int index,
    required bool isInput,
    required PortType type,
  }) {
    dynamic defaultValue;
    switch (type.type) {
      case PortType.BOOLEAN:
        defaultValue = false;
        break;
      case PortType.NUMERIC:
        defaultValue = 0.0;
        break;
      case PortType.STRING:
        defaultValue = '';
        break;
      case PortType.ANY:
        defaultValue = null;
        break;
    }

    return Property(
      name: name,
      index: index,
      isInput: isInput,
      type: type,
      value: defaultValue,
    );
  }

  bool canConnectTo(Property otherProperty) {
    if (isInput == otherProperty.isInput) return false;

    return type.type == PortType.ANY ||
        otherProperty.type.type == PortType.ANY ||
        type == otherProperty.type;
  }
}

class ActionSlot extends Slot {
  final PortType? parameterType;
  final PortType? returnType;
  dynamic parameter;
  dynamic returnValue;

  ActionSlot({
    required super.name,
    required super.index,
    this.parameterType,
    this.returnType,
    this.parameter,
    this.returnValue,
  });

  dynamic execute({dynamic parameter}) {
    this.parameter = parameter;
    return returnValue;
  }
}

class Topic extends Slot {
  final PortType eventType;
  dynamic lastEvent;

  Topic({required super.name, required super.index, required this.eventType});

  void fire(dynamic event) {
    lastEvent = event;
  }
}
class PortType {
  static const String BOOLEAN = "BOOLEAN";
  static const String NUMERIC = "NUMERIC";
  static const String STRING = "STRING";
  static const String ANY = "ANY";

  final String type;

  const PortType(this.type);

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is PortType && other.type == type;

  @override
  int get hashCode => type.hashCode;

  static PortType fromString(String type) {
    return PortType(type);
  }
}
import 'dart:async';
import 'dart:math';
import 'component.dart';
import 'component_type.dart';
import 'port.dart';
import 'port_type.dart';

class RampComponent extends Component {
  static const String RAMP = "RAMP";

  Timer? _timer;
  double _stepAmount = 0.0;
  final double _stepRange = 10.0;
  final double _min = 0.0;
  final double _max = 100.0;
  bool _running = false;

  RampComponent({required super.id}) : super(type: const ComponentType(RAMP)) {
    _setupPorts();
    _startRamping();
  }

  void _setupPorts() {
    properties.add(
      Property(
        name: "Output",
        index: 0,
        isInput: false,
        type: const PortType(PortType.NUMERIC),
        value: 0.0,
      ),
    );
  }

  @override
  void calculate() {
    properties[0].value += properties[0].value + _stepAmount;
    if (properties[0].value >= _max) {
      properties[0].value = _min;
    }
  }

  void _startRamping() {
    if (_running) return;

    _running = true;
    _timer = Timer.periodic(const Duration(seconds: 2), (timer) {
      final random = Random();
      _stepAmount = random.nextDouble() * _stepRange;
      calculate();
    });
  }

  void stopRamping() {
    _running = false;
    _timer?.cancel();
    _timer = null;
  }

  void dispose() {
    stopRamping();
  }
}
import 'component.dart';
import 'component_type.dart';
import 'port.dart';
import 'port_type.dart';

class RectangleComponent extends Component {
  static const String RECTANGLE = "RECTANGLE";

  RectangleComponent({required super.id})
    : super(type: const ComponentType(RECTANGLE)) {
    _setupPorts();
  }

  void _setupPorts() {
    properties.add(
      Property(
        name: "Length",
        index: 0,
        isInput: true,
        type: const PortType(PortType.NUMERIC),
        value: 0.0,
      ),
    );

    properties.add(
      Property(
        name: "Width",
        index: 1,
        isInput: true,
        type: const PortType(PortType.NUMERIC),
        value: 0.0,
      ),
    );

    properties.add(
      Property(
        name: "Threshold",
        index: 2,
        isInput: true,
        type: const PortType(PortType.NUMERIC),
        value: 1000.0,
      ),
    );

    topics.add(
      Topic(
        name: "Detected",
        index: 3,
        eventType: const PortType(PortType.NUMERIC),
      ),
    );
  }

  @override
  void calculate() {
    double length = properties[0].value as double;
    double width = properties[1].value as double;
    double threshold = properties[2].value as double;

    double area = length * width;

    if (area > threshold) {
      topics[0].fire(area);
    }
  }
}
