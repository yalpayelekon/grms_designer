// File: \.dart_tool\flutter_build\dart_plugin_registrant.dart
import 'dart:io';  import 'package:file_picker/file_picker.dart'; import 'package:path_provider_android/path_provider_android.dart'; import 'package:shared_preferences_android/shared_preferences_android.dart'; import 'package:file_picker/file_picker.dart'; import 'package:path_provider_foundation/path_provider_foundation.dart'; import 'package:shared_preferences_foundation/shared_preferences_foundation.dart'; import 'package:file_picker/file_picker.dart'; import 'package:path_provider_linux/path_provider_linux.dart'; import 'package:shared_preferences_linux/shared_preferences_linux.dart'; import 'package:file_picker/file_picker.dart'; import 'package:path_provider_foundation/path_provider_foundation.dart'; import 'package:shared_preferences_foundation/shared_preferences_foundation.dart'; import 'package:file_picker/file_picker.dart'; import 'package:path_provider_windows/path_provider_windows.dart'; import 'package:shared_preferences_windows/shared_preferences_windows.dart'; @pragma('vm:entry-point') class _PluginRegistrant { @pragma('vm:entry-point') static void register() { if (Platform.isAndroid) { try { FilePickerIO.registerWith(); } catch (err) { print( '`file_picker` threw an error: $err. ' 'The app may not function as expected until you remove this plugin from pubspec.yaml' ); } try { PathProviderAndroid.registerWith(); } catch (err) { print( '`path_provider_android` threw an error: $err. ' 'The app may not function as expected until you remove this plugin from pubspec.yaml' ); } try { SharedPreferencesAndroid.registerWith(); } catch (err) { print( '`shared_preferences_android` threw an error: $err. ' 'The app may not function as expected until you remove this plugin from pubspec.yaml' ); } } else if (Platform.isIOS) { try { FilePickerIO.registerWith(); } catch (err) { print( '`file_picker` threw an error: $err. ' 'The app may not function as expected until you remove this plugin from pubspec.yaml' ); } try { PathProviderFoundation.registerWith(); } catch (err) { print( '`path_provider_foundation` threw an error: $err. ' 'The app may not function as expected until you remove this plugin from pubspec.yaml' ); } try { SharedPreferencesFoundation.registerWith(); } catch (err) { print( '`shared_preferences_foundation` threw an error: $err. ' 'The app may not function as expected until you remove this plugin from pubspec.yaml' ); } } else if (Platform.isLinux) { try { FilePickerLinux.registerWith(); } catch (err) { print( '`file_picker` threw an error: $err. ' 'The app may not function as expected until you remove this plugin from pubspec.yaml' ); } try { PathProviderLinux.registerWith(); } catch (err) { print( '`path_provider_linux` threw an error: $err. ' 'The app may not function as expected until you remove this plugin from pubspec.yaml' ); } try { SharedPreferencesLinux.registerWith(); } catch (err) { print( '`shared_preferences_linux` threw an error: $err. ' 'The app may not function as expected until you remove this plugin from pubspec.yaml' ); } } else if (Platform.isMacOS) { try { FilePickerMacOS.registerWith(); } catch (err) { print( '`file_picker` threw an error: $err. ' 'The app may not function as expected until you remove this plugin from pubspec.yaml' ); } try { PathProviderFoundation.registerWith(); } catch (err) { print( '`path_provider_foundation` threw an error: $err. ' 'The app may not function as expected until you remove this plugin from pubspec.yaml' ); } try { SharedPreferencesFoundation.registerWith(); } catch (err) { print( '`shared_preferences_foundation` threw an error: $err. ' 'The app may not function as expected until you remove this plugin from pubspec.yaml' ); } } else if (Platform.isWindows) { try { FilePickerWindows.registerWith(); } catch (err) { print( '`file_picker` threw an error: $err. ' 'The app may not function as expected until you remove this plugin from pubspec.yaml' ); } try { PathProviderWindows.registerWith(); } catch (err) { print( '`path_provider_windows` threw an error: $err. ' 'The app may not function as expected until you remove this plugin from pubspec.yaml' ); } try { SharedPreferencesWindows.registerWith(); } catch (err) { print( '`shared_preferences_windows` threw an error: $err. ' 'The app may not function as expected until you remove this plugin from pubspec.yaml' ); } } } } 

// File: \lib\comm\command_executor.dart
import 'dart:async'; import '../comm/models/command_models.dart'; import '../comm/router_connection.dart'; class CommandExecutor { static Future<CommandResult> executeWithRetries({ required RouterConnection connection, required QueuedCommand command, required Duration timeout, required int maxRetries, required void Function(QueuedCommand updated) onStatusUpdate, }) async { for (int attempt = 0; attempt <= maxRetries; attempt++) { command.attemptsMade++; if (attempt > 0) { await Future.delayed(Duration(milliseconds: 200 * (1 << attempt))); } try { final completer = Completer<String>(); final sub = connection.messageStream.listen((msg) { if (!completer.isCompleted) { completer.complete(msg); } }); final sent = await connection.sendFireAndForget(command.command); if (!sent) { await sub.cancel(); continue; } final response = await completer.future.timeout(timeout); await sub.cancel(); command.status = CommandStatus.completed; command.response = response; command.completedAt = DateTime.now(); onStatusUpdate(command); return CommandResult.success(response, command.attemptsMade); } catch (e) { if (attempt == maxRetries) { command.status = CommandStatus.failed; command.errorMessage = e.toString(); command.completedAt = DateTime.now(); onStatusUpdate(command); return CommandResult.failure(e.toString(), command.attemptsMade); } } } return CommandResult.failure("Unknown error", command.attemptsMade); } } 

// File: \lib\comm\command_queue_controller.dart
import 'dart:async'; import 'command_executor.dart'; import 'models/command_models.dart'; import 'router_connection.dart'; class CommandQueueController { final RouterConnection connection; final Duration commandTimeout; final int maxRetries; final List<QueuedCommand> _queue = []; final _executing = <String>{}; final StreamController<QueuedCommand> _statusController; CommandQueueController({ required this.connection, required this.commandTimeout, required this.maxRetries, required StreamController<QueuedCommand> statusController, }) : _statusController = statusController; void enqueue(QueuedCommand command) { _queue.add(command); _queue.sort((a, b) => a.compareTo(b)); _statusController.add(command); _startQueueExecution(); } bool cancel(String commandId) { final index = _queue.indexWhere((c) => c.id == commandId); if (index != -1) { final command = _queue.removeAt(index); command.status = CommandStatus.cancelled; command.completedAt = DateTime.now(); _statusController.add(command); return true; } return false; } Future<void> _startQueueExecution() async { while (_queue.isNotEmpty) { if (_executing.length >= 3) { await Future.delayed(const Duration(milliseconds: 100)); continue; } final cmd = _queue.removeAt(0); _executing.add(cmd.id); CommandExecutor.executeWithRetries( connection: connection, command: cmd, timeout: commandTimeout, maxRetries: maxRetries, onStatusUpdate: (updatedCmd) => _statusController.add(updatedCmd), ); await Future.delayed(const Duration(milliseconds: 10)); } while (_executing.isNotEmpty) { await Future.delayed(const Duration(milliseconds: 100)); } } } 

// File: \lib\comm\discovery_manager.dart
import 'dart:io'; import 'dart:typed_data'; import 'package:grms_designer/protocol/query_commands.dart'; import 'package:grms_designer/utils/logger.dart'; import '../protocol/protocol_constants.dart'; class DiscoveryManager { RawDatagramSocket? _socket; final List<String> workgroupList = []; final List<String> ipList = []; bool isRunning = false; Future<void> start(String interfaceIp) async { try { _socket = await RawDatagramSocket.bind( InternetAddress(interfaceIp), defaultUdpPort); isRunning = true; _socket!.listen((RawSocketEvent event) { if (event == RawSocketEvent.read && isRunning) { Datagram? datagram = _socket!.receive(); if (datagram != null) { String response = String.fromCharCodes(datagram.data).trim(); for (int i = 0; i < datagram.data.length; i++) { if (datagram.data[i] == 63) { String ip = datagram.address.address; workgroupList.add(response); ipList.add(ip); break; } } } } }); } catch (e) { logError( 'Error starting discovery: $e. Check Anydesk or other programs that might be using the port'); rethrow; } } Future<void> sendDiscoveryRequest(int timeout, String targetNetwork) async { if (_socket == null) { throw StateError('Socket not initialized. Call start() first.'); } try { String command = HelvarNetCommands.queryWorkgroupName(); List<int> commandBytes = List<int>.from(command.codeUnits); Uint8List data = Uint8List.fromList(commandBytes); _socket!.send(data, InternetAddress(targetNetwork), defaultUdpPort); await Future.delayed(Duration(milliseconds: timeout)); } catch (e) { logError('Error sending discovery request: $e'); rethrow; } } List<Map<String, String>> getDiscoveredRouters() { List<Map<String, String>> result = []; for (int i = 0; i < ipList.length; i++) { String workgroupName = "Unknown"; if (i < workgroupList.length) { String response = workgroupList[i]; if (response.contains('=')) { workgroupName = response.split('=')[1].replaceAll('#', ''); } } result.add({'ip': ipList[i], 'workgroup': workgroupName}); } return result; } void stop() { isRunning = false; if (_socket != null) { _socket!.close(); _socket = null; } } } 

// File: \lib\comm\models\command_models.dart
enum CommandPriority { low, normal, high, critical } enum CommandStatus { queued, executing, completed, failed, timedOut, cancelled } class CommandResult { final bool success; final String? response; final String? errorMessage; final int attemptsMade; final DateTime completedAt; CommandResult({ required this.success, this.response, this.errorMessage, required this.attemptsMade, required this.completedAt, }); factory CommandResult.success(String? response, int attempts) { return CommandResult( success: true, response: response, attemptsMade: attempts, completedAt: DateTime.now(), ); } factory CommandResult.failure(String errorMessage, int attempts) { return CommandResult( success: false, errorMessage: errorMessage, attemptsMade: attempts, completedAt: DateTime.now(), ); } factory CommandResult.timeout(int attempts) { return CommandResult( success: false, errorMessage: 'Command execution timed out', attemptsMade: attempts, completedAt: DateTime.now(), ); } } class QueuedCommand { final String id; final String routerIp; final String command; final CommandPriority priority; final String? groupId; final DateTime queuedAt; DateTime? executedAt; DateTime? completedAt; CommandStatus status; String? response; String? errorMessage; int attemptsMade = 0; QueuedCommand({ required this.id, required this.routerIp, required this.command, required this.priority, this.groupId, required this.queuedAt, this.status = CommandStatus.queued, }); QueuedCommand copyWith({ CommandStatus? status, DateTime? executedAt, DateTime? completedAt, String? response, String? errorMessage, int? attemptsMade, }) { return QueuedCommand( id: id, routerIp: routerIp, command: command, priority: priority, groupId: groupId, queuedAt: queuedAt, ) ..status = status ?? this.status ..executedAt = executedAt ?? this.executedAt ..completedAt = completedAt ?? this.completedAt ..response = response ?? this.response ..errorMessage = errorMessage ?? this.errorMessage ..attemptsMade = attemptsMade ?? this.attemptsMade; } int compareTo(QueuedCommand other) { final priorityComparison = other.priority.index.compareTo(priority.index); if (priorityComparison != 0) { return priorityComparison; } return queuedAt.compareTo(other.queuedAt); } @override String toString() { return 'QueuedCommand{' 'id: $id, ' 'routerIp: $routerIp, ' 'command: $command, ' 'priority: $priority, ' 'groupId: $groupId, ' 'queuedAt: $queuedAt, ' 'executedAt: $executedAt, ' 'completedAt: $completedAt, ' 'status: $status, ' 'response: ${response != null ? '${response!.length} chars' : null}, ' 'errorMessage: $errorMessage, ' 'attemptsMade: $attemptsMade' '}'; } } 

// File: \lib\comm\models\connection_config.dart
import '../../models/project_settings.dart'; class ConnectionConfig { final Duration timeout; final Duration heartbeatInterval; final Duration commandTimeout; final int maxRetries; final int maxConcurrentCommands; final int historySize; final int maxConnections; const ConnectionConfig({ this.timeout = const Duration(seconds: 5), this.heartbeatInterval = const Duration(seconds: 30), this.commandTimeout = const Duration(seconds: 10), this.maxRetries = 3, this.maxConcurrentCommands = 5, this.historySize = 100, this.maxConnections = 10, }); factory ConnectionConfig.fromProjectSettings(ProjectSettings? settings) { if (settings == null) { return const ConnectionConfig(); } return ConnectionConfig( timeout: Duration(milliseconds: settings.socketTimeoutMs), heartbeatInterval: Duration(seconds: settings.heartbeatIntervalSeconds), commandTimeout: Duration(milliseconds: settings.commandTimeoutMs), maxRetries: settings.maxCommandRetries, maxConcurrentCommands: settings.maxConcurrentCommandsPerRouter, historySize: settings.commandHistorySize, maxConnections: settings.maxConcurrentCommandsPerRouter * 2, ); } } 

// File: \lib\comm\models\router_connection_status.dart
enum RouterConnectionState { disconnected, connecting, connected, reconnecting, failed } class RouterConnectionStatus { final String routerIp; final RouterConnectionState state; final DateTime lastStateChange; final String? errorMessage; final int reconnectAttempts; RouterConnectionStatus({ required this.routerIp, required this.state, required this.lastStateChange, this.errorMessage, this.reconnectAttempts = 0, }); RouterConnectionStatus copyWith({ RouterConnectionState? state, String? errorMessage, int? reconnectAttempts, }) { return RouterConnectionStatus( routerIp: routerIp, state: state ?? this.state, lastStateChange: DateTime.now(), errorMessage: errorMessage ?? this.errorMessage, reconnectAttempts: reconnectAttempts ?? this.reconnectAttempts, ); } } 

// File: \lib\comm\router_command_service.dart
import 'dart:async'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:uuid/uuid.dart'; import '../providers/router_connection_provider.dart'; import '../utils/logger.dart'; import 'command_executor.dart'; import 'command_queue_controller.dart'; import 'models/command_models.dart'; import 'models/connection_config.dart'; import 'router_connection.dart'; import 'router_connection_manager.dart'; import '../services/command_history_service.dart'; class RouterCommandService { final RouterConnectionManager _connectionManager; final ConnectionConfig _config; final Map<String, CommandQueueController> _queueControllers = {}; final _commandStatusController = StreamController<QueuedCommand>.broadcast(); late final CommandHistoryService _history = CommandHistoryService( maxHistorySize: _config.historySize, ); void _addToHistory(QueuedCommand command) => _history.add(command); List<QueuedCommand> get commandHistory => _history.all; void clearHistory() => _history.clear(); RouterCommandService(this._connectionManager, this._config); Stream<QueuedCommand> get commandStatusStream => _commandStatusController.stream; Future<bool> ensureConnection(String routerIp) async { try { await _connectionManager.getConnection(routerIp); return true; } catch (e) { logError('Error ensuring connection to $routerIp: $e'); return false; } } CommandQueueController _getQueueController(RouterConnection connection) { return _queueControllers.putIfAbsent(connection.ipAddress, () { return CommandQueueController( connection: connection, commandTimeout: _config.commandTimeout, maxRetries: _config.maxRetries, statusController: _commandStatusController, ); }); } bool isRouterConnected(String routerIp) { return _connectionManager.hasConnection(routerIp); } Future<CommandResult> sendCommand( String routerIp, String command, { Duration? timeout, int? maxRetries, CommandPriority priority = CommandPriority.normal, String? groupId, }) async { final commandId = const Uuid().v4(); final queuedCommand = QueuedCommand( id: commandId, routerIp: routerIp, command: command, priority: priority, groupId: groupId, queuedAt: DateTime.now(), ); queuedCommand.status = CommandStatus.executing; queuedCommand.executedAt = DateTime.now(); _updateCommandStatus(queuedCommand); RouterConnection? connection; try { connection = await _connectionManager.getConnection(routerIp); } catch (e) { return _handleConnectionError(queuedCommand, e); } final localMaxRetries = maxRetries ?? _config.maxRetries; final localTimeout = timeout ?? _config.commandTimeout; return CommandExecutor.executeWithRetries( connection: connection, command: queuedCommand, timeout: localTimeout, maxRetries: localMaxRetries, onStatusUpdate: _updateCommandStatus, ); } CommandResult _handleConnectionError(QueuedCommand command, dynamic error) { command.status = CommandStatus.failed; command.completedAt = DateTime.now(); command.errorMessage = 'Connection error: ${error.toString()}'; _updateCommandStatus(command); _addToHistory(command); return CommandResult.failure( 'Failed to establish connection: ${error.toString()}', command.attemptsMade, ); } Future<String> queueCommand( String routerIp, String command, { CommandPriority priority = CommandPriority.normal, String? groupId, }) async { final commandId = const Uuid().v4(); final queuedCommand = QueuedCommand( id: commandId, routerIp: routerIp, command: command, priority: priority, groupId: groupId, queuedAt: DateTime.now(), ); final conn = await _connectionManager.getConnection(routerIp); final controller = _getQueueController(conn); controller.enqueue(queuedCommand); return commandId; } bool cancelCommand(String commandId) { for (final controller in _queueControllers.values) { final result = controller.cancel(commandId); if (result) return true; } return false; } Future<List<CommandResult>> batchExecute( String routerIp, List<String> commands, { String? routerId, CommandPriority priority = CommandPriority.normal, }) async { final results = <CommandResult>[]; for (final command in commands) { final result = await sendCommand(routerIp, command, priority: priority); results.add(result); if (!result.success) { break; } } return results; } void _updateCommandStatus(QueuedCommand command) { logInfo('Command status updated: ${command.toString()}'); _commandStatusController.add(command); } } void unawaited(Future<void> future) { future.catchError((error) { logError('Unhandled async error: $error', tag: "RouterCommandService"); }); } final commandStatusStreamProvider = StreamProvider<QueuedCommand>((ref) { final service = ref.watch(routerCommandServiceProvider); return service.commandStatusStream; }); 

// File: \lib\comm\router_connection.dart
import 'dart:async'; import 'models/router_connection_status.dart'; import '../protocol/protocol_constants.dart'; import 'router_socket_handler.dart'; class RouterConnection { final String ipAddress; final int port; final Duration heartbeatInterval; final Duration connectionTimeout; final RouterSocketHandler _socketHandler; RouterConnectionStatus _status; int _reconnectAttempts = 0; bool _isClosing = false; RouterConnection({ required this.ipAddress, this.port = defaultTcpPort, this.heartbeatInterval = const Duration(seconds: 30), this.connectionTimeout = const Duration(seconds: 5), })  : _status = RouterConnectionStatus( routerIp: ipAddress, state: RouterConnectionState.disconnected, lastStateChange: DateTime.now(), ), _socketHandler = RouterSocketHandler( ipAddress: ipAddress, port: port, heartbeatInterval: heartbeatInterval, timeout: connectionTimeout, ) { _socketHandler.statusStream.listen(_onSocketStatusChange); } bool get isConnected => _status.state == RouterConnectionState.connected; RouterConnectionStatus get status => _status; Stream<String> get messageStream => _socketHandler.messageStream; Stream<RouterConnectionStatus> get statusStream => _statusController.stream; final _statusController = StreamController<RouterConnectionStatus>.broadcast(); Future<void> connect() async { await _socketHandler.connect(); } Future<void> disconnect() async { await _socketHandler.disconnect(); } Future<bool> sendFireAndForget(String text) async { return _socketHandler.send(text); } Future<void> dispose() async { _isClosing = true; await _socketHandler.dispose(); await _statusController.close(); } void _onSocketStatusChange(SocketStatus status) { if (_isClosing) return; switch (status) { case SocketStatus.connected: _reconnectAttempts = 0; _updateStatus(RouterConnectionState.connected); break; case SocketStatus.connecting: _updateStatus(RouterConnectionState.connecting); break; case SocketStatus.reconnecting: _reconnectAttempts++; _updateStatus(RouterConnectionState.reconnecting); break; case SocketStatus.failed: _updateStatus(RouterConnectionState.failed, errorMessage: 'Socket connection failed'); break; case SocketStatus.disconnected: _updateStatus(RouterConnectionState.disconnected); break; } } void _updateStatus(RouterConnectionState state, {String? errorMessage}) { _status = _status.copyWith( state: state, errorMessage: errorMessage, reconnectAttempts: _reconnectAttempts, ); _statusController.add(_status); } } 

// File: \lib\comm\router_connection_manager.dart
import 'dart:async'; import 'package:grms_designer/protocol/protocol_constants.dart'; import 'models/connection_config.dart'; import 'router_connection.dart'; import 'models/router_connection_status.dart'; class RouterConnectionManager { final ConnectionConfig config; final Map<String, RouterConnection> connections = {}; final connectionStatusController = StreamController<RouterConnectionStatus>.broadcast(); RouterConnectionManager([this.config = const ConnectionConfig()]); int get _maxConcurrentConnections => config.maxConnections; Stream<RouterConnectionStatus> get connectionStatusStream => connectionStatusController.stream; List<RouterConnectionStatus> get allConnectionStatuses => connections.values.map((conn) => conn.status).toList(); int get connectionCount => connections.length; int get maxConnections => _maxConcurrentConnections; Future<RouterConnection> getConnection( String ipAddress, { bool forceReconnect = false, int port = defaultTcpPort, }) async { final connectionKey = '$ipAddress:$port'; try { if (connections.containsKey(connectionKey) && !forceReconnect) { final connection = connections[connectionKey]!; if (!connection.isConnected) { await connection.connect(); } return connection; } if (connections.length >= config.maxConcurrentCommands * 2) { throw Exception( 'Maximum connection limit reached (${config.maxConcurrentCommands * 2})'); } final connection = RouterConnection( ipAddress: ipAddress, port: port, heartbeatInterval: config.heartbeatInterval, connectionTimeout: config.timeout, ); connection.statusStream.listen((status) { connectionStatusController.add(status); }); connections[connectionKey] = connection; await connection.connect(); return connection; } catch (e) { throw Exception('Failed to establish connection to $ipAddress: $e'); } } bool hasConnection(String ipAddress, [int port = 50000]) { final connectionKey = '$ipAddress:$port'; return connections.containsKey(connectionKey); } Future<void> closeConnection(String ipAddress, [int port = 50000]) async { final connectionKey = '$ipAddress:$port'; if (connections.containsKey(connectionKey)) { final connection = connections[connectionKey]!; await connection.dispose(); connections.remove(connectionKey); } } Future<void> closeAllConnections() async { final futures = connections.values.map((connection) => connection.dispose()); await Future.wait(futures); connections.clear(); } Future<void> dispose() async { await closeAllConnections(); await connectionStatusController.close(); } Map<String, dynamic> getConnectionStats() { int connected = 0; int connecting = 0; int reconnecting = 0; int failed = 0; int disconnected = 0; for (var connection in connections.values) { switch (connection.status.state) { case RouterConnectionState.connected: connected++; break; case RouterConnectionState.connecting: connecting++; break; case RouterConnectionState.reconnecting: reconnecting++; break; case RouterConnectionState.failed: failed++; break; case RouterConnectionState.disconnected: disconnected++; break; } } return { 'total': connections.length, 'connected': connected, 'connecting': connecting, 'reconnecting': reconnecting, 'failed': failed, 'disconnected': disconnected, }; } } 

// File: \lib\comm\router_socket_handler.dart
import 'dart:async'; import 'dart:convert'; import 'dart:io'; import 'dart:typed_data'; import '../protocol/protocol_constants.dart'; import '../protocol/query_commands.dart'; import '../utils/logger.dart'; enum SocketStatus { disconnected, connecting, connected, reconnecting, failed } class RouterSocketHandler { final String ipAddress; final int port; final Duration timeout; final Duration heartbeatInterval; Socket? _socket; StreamSubscription? _subscription; final _messageStream = StreamController<String>.broadcast(); final _statusStream = StreamController<SocketStatus>.broadcast(); Timer? _heartbeatTimer; DateTime _lastActivity = DateTime.now(); bool _isReconnecting = false; int _reconnectAttempts = 0; final _buffer = StringBuffer(); RouterSocketHandler({ required this.ipAddress, this.port = defaultTcpPort, this.timeout = const Duration(seconds: 5), this.heartbeatInterval = const Duration(seconds: 30), }); Stream<String> get messageStream => _messageStream.stream; Stream<SocketStatus> get statusStream => _statusStream.stream; Future<void> connect() async { if (_socket != null) await disconnect(); _setStatus(SocketStatus.connecting); try { _socket = await Socket.connect(ipAddress, port, timeout: timeout); _subscription = _socket!.listen( _handleData, onError: _handleError, onDone: _handleDisconnect, ); _reconnectAttempts = 0; _startHeartbeat(); _setStatus(SocketStatus.connected); } catch (e) { logError('Connection error: $e'); _setStatus(SocketStatus.failed); _scheduleReconnect(); } } Future<void> disconnect() async { _stopHeartbeat(); await _subscription?.cancel(); await _socket?.close(); _socket = null; _setStatus(SocketStatus.disconnected); } Future<bool> send(String text) async { if (_socket == null) return false; try { _socket!.write(text); _lastActivity = DateTime.now(); return true; } catch (e) { _handleError(e); return false; } } void _handleData(Uint8List data) { _lastActivity = DateTime.now(); final msg = utf8.decode(data, allowMalformed: true); _buffer.write(msg); _flushBuffer(); } void _flushBuffer() { final buffer = _buffer.toString(); final endIdx = buffer.indexOf(MessageType.terminator); if (endIdx != -1) { final complete = buffer.substring(0, endIdx + 1); _messageStream.add(complete); _buffer.clear(); if (endIdx + 1 < buffer.length) { _buffer.write(buffer.substring(endIdx + 1)); _flushBuffer();  } } } void _handleError(dynamic e) { logError('Socket error for $ipAddress: $e'); _setStatus(SocketStatus.failed); _scheduleReconnect(); } void _handleDisconnect() { logInfo('Socket closed from $ipAddress'); _setStatus(SocketStatus.disconnected); _scheduleReconnect(); } void _startHeartbeat() { _heartbeatTimer?.cancel(); _heartbeatTimer = Timer.periodic(heartbeatInterval, (_) { final diff = DateTime.now().difference(_lastActivity); if (diff >= heartbeatInterval) { send(HelvarNetCommands.queryHelvarNetVersion()); } }); } void _stopHeartbeat() => _heartbeatTimer?.cancel(); void _scheduleReconnect() { if (_isReconnecting) return; _isReconnecting = true; _reconnectAttempts++; final backoff = Duration(seconds: (1 << _reconnectAttempts).clamp(1, 300)); _setStatus(SocketStatus.reconnecting); Future.delayed(backoff, () { _isReconnecting = false; connect(); }); } void _setStatus(SocketStatus status) { _statusStream.add(status); } Future<void> dispose() async { await disconnect(); await _messageStream.close(); await _statusStream.close(); } } 

// File: \lib\extensions\device_address_extensions.dart
import '../models/helvar_models/helvar_device.dart'; extension HelvarDeviceAddressParsing on HelvarDevice { List<int> get parsedAddress { final parts = address.split('.'); if (parts.length != 4) { throw FormatException('Invalid Helvar device address: $address'); } return parts.map(int.parse).toList(); } int get cluster => parsedAddress[0]; int get router => parsedAddress[1]; int get subnet => parsedAddress[2]; int get device => parsedAddress[3]; String get routerAddress => '@$cluster.$router'; } 

// File: \lib\extensions\group_extensions.dart
import '../../models/helvar_models/helvar_group.dart'; import '../../models/helvar_models/workgroup.dart'; extension HelvarGroupExtensions on HelvarGroup { int? get parsedGroupId { return int.tryParse(groupId); } String resolveRouterIp(Workgroup workgroup) { if (gatewayRouterIpAddress.isNotEmpty) return gatewayRouterIpAddress; if (workgroup.routers.isNotEmpty) return workgroup.routers.first.ipAddress; return ''; } } 

// File: \lib\factories\helvar_device_factory.dart
import 'package:grms_designer/utils/device_utils.dart'; import '../models/helvar_models/helvar_device.dart'; import '../models/helvar_models/input_device.dart'; import '../models/helvar_models/output_device.dart'; import '../models/helvar_models/emergency_device.dart'; class HelvarDeviceFactory { static HelvarDevice createDevice({ required int deviceId, required String deviceAddress, required String deviceState, required String description, required String deviceTypeString, required int typeCode, int? deviceStateCode, int? loadLevel, bool isButton = false, bool isMultisensor = false, }) { HelvarDevice? device; if (isButton || deviceTypeString.toLowerCase().contains('button')) { device = HelvarDriverInputDevice( deviceId: deviceId, address: deviceAddress, state: deviceState, description: description, props: deviceTypeString, deviceTypeCode: typeCode, deviceStateCode: deviceStateCode, isButtonDevice: isButton, isMultisensor: isMultisensor, ); } else if (deviceTypeString.toLowerCase().contains('emergency')) { device = HelvarDriverEmergencyDevice( deviceId: deviceId, address: deviceAddress, state: deviceState, description: description, props: deviceTypeString, deviceTypeCode: typeCode, deviceStateCode: deviceStateCode, emergency: true, ); } else { device = HelvarDriverOutputDevice( deviceId: deviceId, address: deviceAddress, state: deviceState, description: description, props: deviceTypeString, deviceTypeCode: typeCode, deviceStateCode: deviceStateCode, level: loadLevel ?? 0, ); } device.started(); return device; } static List<ButtonPoint> generateButtonPoints(String deviceName) { return generateStandardButtonPoints(deviceName); } static HelvarDevice createBasicDevice({ required int deviceId, required String deviceAddress, required String helvarType, String? description, }) { final deviceDescription = description ?? 'Device $deviceId'; switch (helvarType.toLowerCase()) { case 'input': return HelvarDriverInputDevice( deviceId: deviceId, address: deviceAddress, description: deviceDescription, helvarType: 'input', ); case 'emergency': return HelvarDriverEmergencyDevice( deviceId: deviceId, address: deviceAddress, description: deviceDescription, helvarType: 'emergency', emergency: true, ); case 'output': default: return HelvarDriverOutputDevice( deviceId: deviceId, address: deviceAddress, description: deviceDescription, helvarType: 'output', ); } } } 

// File: \lib\main.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/models/helvar_models/workgroup.dart'; import 'package:grms_designer/providers/group_polling_provider.dart'; import 'package:grms_designer/providers/workgroups_provider.dart'; import 'screens/home_screen.dart'; import 'providers/settings_provider.dart'; import 'services/app_initialization.dart'; import 'services/log_service.dart'; import 'utils/logger.dart'; void main() async { WidgetsFlutterBinding.ensureInitialized(); final container = ProviderContainer(); final logService = container.read(logServiceProvider.notifier); initLogger(logService); logInfo('Application starting', tag: 'App'); try { await AppInitializationService.initialize(); logInfo('Application initialized successfully', tag: 'App'); runApp( UncontrolledProviderScope( container: container, child: const HelvarNetApp(), ), ); } catch (e, stackTrace) { logError('Initialization error: $e', tag: 'App', stackTrace: stackTrace); await AppInitializationService.handleInitializationFailure(e); runApp( UncontrolledProviderScope( container: container, child: const HelvarNetApp(), ), ); } } class HelvarNetApp extends ConsumerStatefulWidget { const HelvarNetApp({super.key}); @override HelvarNetAppState createState() => HelvarNetAppState(); } class HelvarNetAppState extends ConsumerState<HelvarNetApp> { bool _pollingListenerInitialized = false; @override Widget build(BuildContext context) { final themeMode = ref.watch(themeModeProvider); if (!_pollingListenerInitialized) { ref.listen<List<Workgroup>>(workgroupsProvider, (previous, next) { if ((previous == null || previous.isEmpty) && next.isNotEmpty) { WidgetsBinding.instance.addPostFrameCallback((_) { ref.read(pollingStateProvider.notifier).initializePolling(); }); } }); _pollingListenerInitialized = true; } return MaterialApp( title: 'HelvarNet Manager', themeMode: themeMode, theme: ThemeData( primarySwatch: Colors.blue, visualDensity: VisualDensity.adaptivePlatformDensity, brightness: Brightness.light, ), darkTheme: ThemeData( primarySwatch: Colors.blue, visualDensity: VisualDensity.adaptivePlatformDensity, brightness: Brightness.dark, ), home: const HomeScreen(), ); } } 

// File: \lib\models\flowsheet.dart
import 'package:flutter/material.dart'; import 'package:grms_designer/niagara/models/port_type.dart'; import '../niagara/models/component.dart'; import '../niagara/models/connection.dart'; import '../niagara/models/component_type.dart'; import '../niagara/models/logic_components.dart'; import '../niagara/models/math_components.dart'; import '../niagara/models/point_components.dart'; import '../niagara/models/port.dart'; import '../niagara/models/rectangle.dart'; import '../niagara/models/ramp_component.dart'; import '../utils/helpers.dart'; class Flowsheet { String id; String name; DateTime createdAt; DateTime modifiedAt; List<Component> components; Size canvasSize; Offset canvasOffset; List<Connection> connections; final Map<String, Offset> componentPositions = {}; final Map<String, double> componentWidths = {}; final Map<String, Map<String, dynamic>> componentProperties = {}; final Map<String, dynamic> canvasProperties = {}; Flowsheet({ required this.id, required this.name, DateTime? createdAt, DateTime? modifiedAt, List<Component>? components, Size? canvasSize, Offset? canvasOffset, List<Connection>? connections, })  : createdAt = createdAt ?? DateTime.now(), modifiedAt = modifiedAt ?? DateTime.now(), components = components ?? [], canvasSize = canvasSize ?? const Size(2000, 2000), connections = connections ?? [], canvasOffset = canvasOffset ?? const Offset(0, 0); void updateComponentPosition(String componentId, Offset position) { if (!componentPositions.containsKey(componentId)) { componentPositions[componentId] = position; } else { componentPositions[componentId] = position; } modifiedAt = DateTime.now(); } void updateComponentWidth(String componentId, double width) { if (!componentWidths.containsKey(componentId)) { componentWidths[componentId] = width; } else { componentWidths[componentId] = width; } modifiedAt = DateTime.now(); } void updatePortValue(String componentId, int slotIndex, dynamic value) { final componentIndex = components.indexWhere((comp) => comp.id == componentId); if (componentIndex >= 0) { final component = components[componentIndex]; Slot? slot; for (var prop in component.properties) { if (prop.index == slotIndex) { slot = prop; break; } } if (slot == null) { for (var action in component.actions) { if (action.index == slotIndex) { slot = action; break; } } } if (slot == null) { for (var topic in component.topics) { if (topic.index == slotIndex) { slot = topic; break; } } } if (slot is Property) { slot.value = value; } else if (slot is ActionSlot) { slot.parameter = value; } modifiedAt = DateTime.now(); } } static Flowsheet fromJsonSuper(Map<String, dynamic> json) { List<Component> parsedComponents = []; if (json['components'] != null) { final componentsList = json['components'] as List; for (var componentJson in componentsList) { final component = _componentFromJson(componentJson as Map<String, dynamic>); if (componentJson['properties'] != null) { component.properties.clear(); for (var propJson in componentJson['properties'] as List) { final Map<String, dynamic> propMap = propJson as Map<String, dynamic>; component.properties.add(Property( name: propMap['name'] as String, index: propMap['index'] as int, isInput: propMap['isInput'] as bool, type: PortType(propMap['type']['type'] as String), value: propMap['value'], )); } } if (componentJson['actions'] != null) { component.actions.clear(); for (var actionJson in componentJson['actions'] as List) { final Map<String, dynamic> actionMap = actionJson as Map<String, dynamic>; PortType? parameterType; if (actionMap['parameterType'] != null) { parameterType = PortType(actionMap['parameterType']['type'] as String); } PortType? returnType; if (actionMap['returnType'] != null) { returnType = PortType(actionMap['returnType']['type'] as String); } component.actions.add(ActionSlot( name: actionMap['name'] as String, index: actionMap['index'] as int, parameterType: parameterType, returnType: returnType, parameter: actionMap['parameter'], returnValue: actionMap['returnValue'], )); } } if (componentJson['topics'] != null) { component.topics.clear(); for (var topicJson in componentJson['topics'] as List) { final Map<String, dynamic> topicMap = topicJson as Map<String, dynamic>; component.topics.add(Topic( name: topicMap['name'] as String, index: topicMap['index'] as int, eventType: PortType(topicMap['eventType']['type'] as String), )); if (topicMap['lastEvent'] != null) { final topic = component.topics.last; topic.fire(topicMap['lastEvent']); } } } if (componentJson['inputConnections'] != null) { final inputConnections = componentJson['inputConnections'] as Map<String, dynamic>; for (var entry in inputConnections.entries) { final slotIndex = int.parse(entry.key); final connectionData = entry.value as Map<String, dynamic>; component.inputConnections[slotIndex] = ConnectionEndpoint( componentId: connectionData['componentId'] as String, portIndex: connectionData['portIndex'] as int, ); } } parsedComponents.add(component); } } List<Connection> parsedConnections = []; if (json['connections'] != null) { final connectionsList = json['connections'] as List; for (var connectionJson in connectionsList) { final Map<String, dynamic> connMap = connectionJson as Map<String, dynamic>; parsedConnections.add(Connection( fromComponentId: connMap['fromComponentId'] as String, fromPortIndex: connMap['fromPortIndex'] as int, toComponentId: connMap['toComponentId'] as String, toPortIndex: connMap['toPortIndex'] as int, )); } } if (json['inputConnectionsMap'] != null) { final inputConnectionsMap = json['inputConnectionsMap'] as Map<String, dynamic>; for (var entry in inputConnectionsMap.entries) { final componentId = entry.key; final connectionsList = entry.value as Map<String, dynamic>; final component = parsedComponents.firstWhere( (comp) => comp.id == componentId, orElse: () => null as Component, ); for (var connEntry in connectionsList.entries) { final slotIndex = int.parse(connEntry.key); final Map<String, dynamic> endpointData = connEntry.value as Map<String, dynamic>; component.inputConnections[slotIndex] = ConnectionEndpoint( componentId: endpointData['componentId'] as String, portIndex: endpointData['portIndex'] as int, ); } } } return Flowsheet( id: json['id'] as String, name: json['name'] as String, createdAt: DateTime.parse(json['createdAt'] as String), modifiedAt: DateTime.parse(json['modifiedAt'] as String), components: parsedComponents, connections: parsedConnections, canvasSize: Size( (json['canvasSize']['width'] as num).toDouble(), (json['canvasSize']['height'] as num).toDouble(), ), canvasOffset: Offset( (json['canvasOffset']['dx'] as num).toDouble(), (json['canvasOffset']['dy'] as num).toDouble(), ), ); } void addComponent(Component component) { components.add(component); modifiedAt = DateTime.now(); } void removeComponent(String componentId) { components.removeWhere((component) => component.id == componentId); connections.removeWhere( (connection) => connection.fromComponentId == componentId || connection.toComponentId == componentId, ); modifiedAt = DateTime.now(); } void updateComponent(String componentId, Component updatedComponent) { final index = components.indexWhere((component) => component.id == componentId); if (index >= 0) { components[index] = updatedComponent; modifiedAt = DateTime.now(); } } void addConnection(Connection connection) { connections.add(connection); modifiedAt = DateTime.now(); } void removeConnection(String fromComponentId, int fromPortIndex, String toComponentId, int toPortIndex) { connections.removeWhere( (connection) => connection.fromComponentId == fromComponentId && connection.fromPortIndex == fromPortIndex && connection.toComponentId == toComponentId && connection.toPortIndex == toPortIndex, ); modifiedAt = DateTime.now(); } void updateCanvasSize(Size newSize) { canvasSize = newSize; modifiedAt = DateTime.now(); } void updateCanvasOffset(Offset newOffset) { canvasOffset = newOffset; modifiedAt = DateTime.now(); } static Component _componentFromJson(Map<String, dynamic> json) { final String componentType = json['type']['type'] as String; final String id = json['id'] as String; switch (componentType) { case ComponentType.AND_GATE: case ComponentType.OR_GATE: case ComponentType.XOR_GATE: case ComponentType.NOT_GATE: case ComponentType.IS_GREATER_THAN: case ComponentType.IS_LESS_THAN: case ComponentType.IS_EQUAL: return LogicComponent( id: id, type: ComponentType(componentType), ); case ComponentType.ADD: case ComponentType.SUBTRACT: case ComponentType.MULTIPLY: case ComponentType.DIVIDE: case ComponentType.MAX: case ComponentType.MIN: case ComponentType.POWER: case ComponentType.ABS: return MathComponent( id: id, type: ComponentType(componentType), ); case ComponentType.BOOLEAN_WRITABLE: case ComponentType.NUMERIC_WRITABLE: case ComponentType.STRING_WRITABLE: case ComponentType.BOOLEAN_POINT: case ComponentType.NUMERIC_POINT: case ComponentType.STRING_POINT: return PointComponent( id: id, type: ComponentType(componentType), ); case RectangleComponent.RECTANGLE: return RectangleComponent( id: id, ); case RampComponent.RAMP: return RampComponent( id: id, ); default: return PointComponent( id: id, type: const ComponentType(ComponentType.NUMERIC_POINT), ); } } static Map<String, dynamic> _componentToJson(Component component) { final Map<String, dynamic> json = { 'id': component.id, 'type': { 'type': component.type.type, }, 'properties': component.properties .map((prop) => { 'name': prop.name, 'index': prop.index, 'isInput': prop.isInput, 'type': { 'type': prop.type.type, }, 'value': prop.value, }) .toList(), 'actions': component.actions .map((action) => { 'name': action.name, 'index': action.index, 'parameterType': action.parameterType != null ? { 'type': action.parameterType!.type, } : null, 'returnType': action.returnType != null ? { 'type': action.returnType!.type, } : null, }) .toList(), 'topics': component.topics .map((topic) => { 'name': topic.name, 'index': topic.index, 'eventType': { 'type': topic.eventType.type, }, }) .toList(), 'inputConnections': component.inputConnections.map((key, value) => MapEntry( key.toString(), { 'componentId': value.componentId, 'portIndex': value.portIndex, }, )), }; return json; } factory Flowsheet.fromJson(Map<String, dynamic> json) { final flowsheet = Flowsheet.fromJsonSuper(json); if (json['componentPositions'] != null) { (json['componentPositions'] as Map<String, dynamic>) .forEach((key, value) { flowsheet.componentPositions[key] = Offset( (value['dx'] as num).toDouble(), (value['dy'] as num).toDouble(), ); }); } if (json['componentWidths'] != null) { (json['componentWidths'] as Map<String, dynamic>).forEach((key, value) { flowsheet.componentWidths[key] = (value as num).toDouble(); }); } return flowsheet; } Map<String, dynamic> toJson() { final Map<String, Map<String, dynamic>> inputConnectionsMap = {}; for (var component in components) { if (component.inputConnections.isNotEmpty) { inputConnectionsMap[component.id] = {}; for (var entry in component.inputConnections.entries) { inputConnectionsMap[component.id]![entry.key.toString()] = { 'componentId': entry.value.componentId, 'portIndex': entry.value.portIndex, }; } } } var json = { 'id': id, 'name': name, 'createdAt': createdAt.toIso8601String(), 'modifiedAt': modifiedAt.toIso8601String(), 'components': components.map((component) => _componentToJson(component)).toList(), 'connections': connections .map((connection) => { 'fromComponentId': connection.fromComponentId, 'fromPortIndex': connection.fromPortIndex, 'toComponentId': connection.toComponentId, 'toPortIndex': connection.toPortIndex, }) .toList(), 'canvasSize': { 'width': canvasSize.width, 'height': canvasSize.height, }, 'canvasOffset': { 'dx': canvasOffset.dx, 'dy': canvasOffset.dy, }, 'inputConnectionsMap': inputConnectionsMap, }; json['componentPositions'] = componentPositions.map((key, value) => MapEntry( key, { 'dx': value.dx, 'dy': value.dy, }, )); json['componentWidths'] = componentWidths; return json; } Flowsheet copy() { Map<String, String> oldToNewIdMap = {}; List<Component> componentCopies = []; for (var component in components) { final String oldId = component.id; final String newId = "${component.id}_copy"; oldToNewIdMap[oldId] = newId; Component componentCopy = deepCopyComponent(component, newId); componentCopies.add(componentCopy); } List<Connection> connectionCopies = []; for (var connection in connections) { if (oldToNewIdMap.containsKey(connection.fromComponentId) && oldToNewIdMap.containsKey(connection.toComponentId)) { connectionCopies.add(Connection( fromComponentId: oldToNewIdMap[connection.fromComponentId]!, fromPortIndex: connection.fromPortIndex, toComponentId: oldToNewIdMap[connection.toComponentId]!, toPortIndex: connection.toPortIndex, )); } } Map<String, Offset> positionCopies = {}; Map<String, double> widthCopies = {}; componentPositions.forEach((oldId, position) { if (oldToNewIdMap.containsKey(oldId)) { positionCopies[oldToNewIdMap[oldId]!] = position; } }); componentWidths.forEach((oldId, width) { if (oldToNewIdMap.containsKey(oldId)) { widthCopies[oldToNewIdMap[oldId]!] = width; } }); Flowsheet flowsheetCopy = Flowsheet( id: id, name: name, createdAt: createdAt, modifiedAt: modifiedAt, components: componentCopies, connections: connectionCopies, canvasSize: canvasSize, canvasOffset: canvasOffset, ); positionCopies.forEach((id, position) { flowsheetCopy.componentPositions[id] = position; }); widthCopies.forEach((id, width) { flowsheetCopy.componentWidths[id] = width; }); return flowsheetCopy; } } 

// File: \lib\models\helvar_models\device_action.dart
import '../../niagara/models/port_type.dart'; enum DeviceAction { clearResult, recallScene, directLevel, directProportion, modifyProportion, emergencyFunctionTest, emergencyDurationTest, stopEmergencyTest, resetEmergencyBattery, } extension DeviceActionExtension on DeviceAction { String get displayName { switch (this) { case DeviceAction.clearResult: return 'Clear Result'; case DeviceAction.recallScene: return 'Recall Scene'; case DeviceAction.directLevel: return 'Direct Level'; case DeviceAction.directProportion: return 'Direct Proportion'; case DeviceAction.modifyProportion: return 'Modify Proportion'; case DeviceAction.emergencyFunctionTest: return 'Emergency Function Test'; case DeviceAction.emergencyDurationTest: return 'Emergency Duration Test'; case DeviceAction.stopEmergencyTest: return 'Stop Emergency Test'; case DeviceAction.resetEmergencyBattery: return 'Reset Emergency Battery'; } } PortType get portType { switch (this) { case DeviceAction.clearResult: return const PortType(PortType.BOOLEAN); case DeviceAction.recallScene: return const PortType(PortType.NUMERIC); case DeviceAction.directLevel: return const PortType(PortType.NUMERIC); case DeviceAction.directProportion: return const PortType(PortType.NUMERIC); case DeviceAction.modifyProportion: return const PortType(PortType.NUMERIC); case DeviceAction.emergencyFunctionTest: return const PortType(PortType.BOOLEAN); case DeviceAction.emergencyDurationTest: return const PortType(PortType.BOOLEAN); case DeviceAction.stopEmergencyTest: return const PortType(PortType.BOOLEAN); case DeviceAction.resetEmergencyBattery: return const PortType(PortType.BOOLEAN); } } } 

// File: \lib\models\helvar_models\emergency_device.dart
import '../../utils/logger.dart'; import 'device_action.dart'; import 'helvar_device.dart'; class HelvarDriverEmergencyDevice extends HelvarDevice { String missing; String faulty; HelvarDriverEmergencyDevice({ super.deviceId, super.address, super.state, super.description, super.props, super.iconPath, super.hexId, super.addressingScheme, super.emergency = true, super.blockId, super.sceneId, super.out, super.helvarType = "emergency", super.deviceTypeCode, super.deviceStateCode, super.isButtonDevice, super.isMultisensor, super.sensorInfo, super.additionalInfo, this.missing = "", this.faulty = "", }); @override void recallScene(String sceneParams) { throw UnimplementedError("Emergency devices do not support scene recall"); } @override void performAction(DeviceAction action, dynamic value) { switch (action) { case DeviceAction.clearResult: clearResult(); break; case DeviceAction.emergencyFunctionTest: emergencyFunctionTest(); break; case DeviceAction.emergencyDurationTest: emergencyDurationTest(); break; case DeviceAction.stopEmergencyTest: stopEmergencyTest(); break; case DeviceAction.resetEmergencyBattery: resetEmergencyBatteryTotalLampTime(); break; default: logWarning("Action $action not supported for emergency device"); } } void emergencyFunctionTest() { try { String timestamp = DateTime.now().toString(); String s = "Success ($timestamp) Emergency Test for device $address"; out = s; } catch (e) { logError(e.toString()); out = e.toString(); } } void emergencyDurationTest() { try { String timestamp = DateTime.now().toString(); String s = "Success ($timestamp) Emergency Test for device $address"; out = s; } catch (e) { logError(e.toString()); out = e.toString(); } } void stopEmergencyTest() { try { String timestamp = DateTime.now().toString(); String s = "Success ($timestamp) Emergency Test for device $address"; out = s; } catch (e) { logError(e.toString()); out = e.toString(); } } void queryEmergencyFunctionTestTime() { try {} catch (e) { logError(e.toString()); out = e.toString(); } } void queryEmergencyFunctionTestState() { try {} catch (e) { logError(e.toString()); out = e.toString(); } } void queryEmergencyDurationTestTime() { try {} catch (e) { logError(e.toString()); out = e.toString(); } } void queryEmergencyDurationTestState() { try {} catch (e) { logError(e.toString()); out = e.toString(); } } void queryEmergencyBatteryCharge() { try {} catch (e) { logError(e.toString()); out = e.toString(); } } void queryEmergencyBatteryTime() { try {} catch (e) { logError(e.toString()); out = e.toString(); } } void queryEmergencyTotalLampTime() { try {} catch (e) { logError(e.toString()); out = e.toString(); } } void queryEmergencyBatteryEndurance() { try {} catch (e) { logError(e.toString()); out = e.toString(); } } void queryEmdtActualTestDuration() { try {} catch (e) { logError(e.toString()); out = e.toString(); } } void resetEmergencyBatteryTotalLampTime() { try { String timestamp = DateTime.now().toString(); String s = "Success ($timestamp) Reset Emergency Battery and Total Lamp Time for device $address"; out = s; } catch (e) { logError(e.toString()); out = e.toString(); } } @override void started() { createOutputEmergencyPoints(address, "name"); } @override void stopped() {} void createOutputEmergencyPoints(String deviceAddress, String name) {} @override Map<String, dynamic> toJson() { final json = super.toJson(); json['missing'] = missing; json['faulty'] = faulty; return json; } } 

// File: \lib\models\helvar_models\helvar_device.dart
import 'package:flutter_simple_treeview/flutter_simple_treeview.dart'; import 'package:grms_designer/models/helvar_models/output_point.dart'; import 'package:grms_designer/utils/logger.dart'; import 'emergency_device.dart'; import 'device_action.dart'; import 'input_device.dart'; import 'output_device.dart'; abstract class HelvarDevice extends TreeNode { int cluster; int routerId; int subnet; int deviceIndex; int deviceId; String address; String state; String description; String props; String iconPath; String hexId; String addressingScheme; bool emergency; String blockId; String sceneId; String out; String helvarType; int? deviceTypeCode; int? deviceStateCode; bool isButtonDevice; bool isMultisensor; Map<String, dynamic> sensorInfo; Map<String, dynamic> additionalInfo; HelvarDevice({ this.cluster = 1, this.routerId = 1, this.subnet = 1, this.deviceIndex = 1, this.deviceId = 1, this.address = "@", this.state = "", this.description = "", this.props = "", this.iconPath = "", this.hexId = "", this.addressingScheme = "", this.emergency = false, this.blockId = "1", this.sceneId = "", this.out = "", this.helvarType = "output", this.deviceTypeCode, this.deviceStateCode, this.isButtonDevice = false, this.isMultisensor = false, Map<String, dynamic>? sensorInfo, Map<String, dynamic>? additionalInfo, }) : sensorInfo = sensorInfo ?? {}, additionalInfo = additionalInfo ?? {} { if (address.startsWith('@')) { address = address.substring(1); } final parts = address.split('.'); if (parts.length == 4) { try { cluster = int.parse(parts[0]); routerId = int.parse(parts[1]); subnet = int.parse(parts[2]); deviceIndex = int.parse(parts[3]); } catch (e) { logError("Error in HelvarDevice creation:$e"); } } } factory HelvarDevice.fromJson(Map<String, dynamic> json) { final helvarType = json['helvarType'] as String? ?? 'output'; final buttonPoints = <ButtonPoint>[]; if (json['buttonPoints'] != null) { for (var point in (json['buttonPoints'] as List)) { buttonPoints.add(ButtonPoint.fromJson(point)); } } if (helvarType == "input") { return HelvarDriverInputDevice( deviceId: json['deviceId'] as int? ?? 1, address: json['address'] as String? ?? '@', state: json['state'] as String? ?? '', description: json['description'] as String? ?? '', props: json['props'] as String? ?? '', iconPath: json['iconPath'] as String? ?? '', hexId: json['hexId'] as String? ?? '', addressingScheme: json['addressingScheme'] as String? ?? '', emergency: json['emergency'] as bool? ?? false, blockId: json['blockId'] as String? ?? '1', sceneId: json['sceneId'] as String? ?? '', out: json['out'] as String? ?? '', helvarType: json['helvarType'] as String? ?? 'input', deviceTypeCode: json['deviceTypeCode'] as int?, deviceStateCode: json['deviceStateCode'] as int?, isButtonDevice: json['isButtonDevice'] as bool? ?? false, isMultisensor: json['isMultisensor'] as bool? ?? false, buttonPoints: buttonPoints, sensorInfo: json['sensorInfo'] as Map<String, dynamic>? ?? {}, additionalInfo: json['additionalInfo'] as Map<String, dynamic>? ?? {}, ); } if (helvarType == "output") { final outputPoints = <OutputPoint>[]; if (json['outputPoints'] != null) { for (var point in (json['outputPoints'] as List)) { outputPoints.add(OutputPoint.fromJson(point)); } } return HelvarDriverOutputDevice( deviceId: json['deviceId'] as int? ?? 1, address: json['address'] as String? ?? '@', state: json['state'] as String? ?? '', description: json['description'] as String? ?? '', props: json['props'] as String? ?? '', iconPath: json['iconPath'] as String? ?? '', hexId: json['hexId'] as String? ?? '', addressingScheme: json['addressingScheme'] as String? ?? '', emergency: json['emergency'] as bool? ?? false, blockId: json['blockId'] as String? ?? '1', sceneId: json['sceneId'] as String? ?? '', out: json['out'] as String? ?? '', helvarType: json['helvarType'] as String? ?? 'output', missing: json['missing'] as String? ?? '', faulty: json['faulty'] as String? ?? '', level: json['level'] as int? ?? 100, proportion: json['proportion'] as int? ?? 0, deviceTypeCode: json['deviceTypeCode'] as int?, deviceStateCode: json['deviceStateCode'] as int?, isButtonDevice: json['isButtonDevice'] as bool? ?? false, isMultisensor: json['isMultisensor'] as bool? ?? false, sensorInfo: json['sensorInfo'] as Map<String, dynamic>? ?? {}, additionalInfo: json['additionalInfo'] as Map<String, dynamic>? ?? {}, outputPoints: outputPoints, ); } else { return HelvarDriverEmergencyDevice( deviceId: json['deviceId'] as int? ?? 1, address: json['address'] as String? ?? '@', state: json['state'] as String? ?? '', description: json['description'] as String? ?? '', props: json['props'] as String? ?? '', iconPath: json['iconPath'] as String? ?? '', hexId: json['hexId'] as String? ?? '', addressingScheme: json['addressingScheme'] as String? ?? '', emergency: json['emergency'] as bool? ?? true, blockId: json['blockId'] as String? ?? '1', sceneId: json['sceneId'] as String? ?? '', out: json['out'] as String? ?? '', helvarType: json['helvarType'] as String? ?? 'emergency', missing: json['missing'] as String? ?? '', faulty: json['faulty'] as String? ?? '', deviceTypeCode: json['deviceTypeCode'] as int?, deviceStateCode: json['deviceStateCode'] as int?, isButtonDevice: json['isButtonDevice'] as bool? ?? false, isMultisensor: json['isMultisensor'] as bool? ?? false, sensorInfo: json['sensorInfo'] as Map<String, dynamic>? ?? {}, additionalInfo: json['additionalInfo'] as Map<String, dynamic>? ?? {}, ); } } void started(); void stopped(); void recallScene(String sceneParams); void clearResult() { out = ""; } void performAction(DeviceAction action, dynamic value); Map<String, dynamic> toJson() { return { 'deviceId': deviceId, 'address': address, 'state': state, 'description': description, 'props': props, 'iconPath': iconPath, 'hexId': hexId, 'addressingScheme': addressingScheme, 'emergency': emergency, 'blockId': blockId, 'sceneId': sceneId, 'out': out, 'helvarType': helvarType, 'deviceTypeCode': deviceTypeCode, 'deviceStateCode': deviceStateCode, 'isButtonDevice': isButtonDevice, 'isMultisensor': isMultisensor, 'sensorInfo': sensorInfo, 'additionalInfo': additionalInfo, }; } String getIconPath() => iconPath; void setIconPath(String path) { iconPath = path; } } 

// File: \lib\models\helvar_models\helvar_group.dart
import 'package:flutter/material.dart'; import 'package:flutter_simple_treeview/flutter_simple_treeview.dart'; class HelvarGroup extends TreeNode { final String id; final String groupId; final String description; final String type; final int? lsig; final int? lsib1; final int? lsib2; final List<double> blockValues; final List<int> sceneTable; final double powerConsumption; final int powerPollingMinutes; final String gatewayRouterIpAddress; final bool refreshPropsAfterAction; final String actionResult; final String lastMessage; final DateTime? lastMessageTime; final DateTime? lastPowerUpdateTime; HelvarGroup({ required this.id, required this.groupId, this.description = '', this.type = 'Group', this.lsig, this.lsib1, this.lsib2, this.blockValues = const [], this.sceneTable = const [], this.powerConsumption = 0.0, this.powerPollingMinutes = 15, this.gatewayRouterIpAddress = '', this.refreshPropsAfterAction = false, this.actionResult = '', this.lastMessage = '', this.lastMessageTime, this.lastPowerUpdateTime, }) : super( content: Text(description.isEmpty ? "Group $groupId" : description), ); @override bool operator ==(Object other) => identical(this, other) || other is HelvarGroup && runtimeType == other.runtimeType && id == other.id; @override int get hashCode => id.hashCode; factory HelvarGroup.fromJson(Map<String, dynamic> json) { return HelvarGroup( id: json['id'] as String, groupId: json['groupId'] as String, description: json['description'] as String? ?? '', type: json['type'] as String? ?? 'Group', lsig: json['lsig'] as int?, lsib1: json['lsib1'] as int?, lsib2: json['lsib2'] as int?, blockValues: (json['blockValues'] as List?) ?.map((e) => (e as num).toDouble()) .toList() ?? [], sceneTable: (json['sceneTable'] as List?)?.map((e) => e as int).toList() ?? [], powerConsumption: (json['powerConsumption'] as num?)?.toDouble() ?? 0.0, powerPollingMinutes: json['powerPollingMinutes'] as int? ?? 15, gatewayRouterIpAddress: json['gatewayRouterIpAddress'] as String? ?? '', refreshPropsAfterAction: json['refreshPropsAfterAction'] as bool? ?? false, actionResult: json['actionResult'] as String? ?? '', lastMessage: json['lastMessage'] as String? ?? '', lastMessageTime: json['lastMessageTime'] != null ? DateTime.parse(json['lastMessageTime'] as String) : null, lastPowerUpdateTime: json['lastPowerUpdateTime'] != null ? DateTime.parse(json['lastPowerUpdateTime'] as String) : null, ); } Map<String, dynamic> toJson() { return { 'id': id, 'groupId': groupId, 'description': description, 'type': type, 'lsig': lsig, 'lsib1': lsib1, 'lsib2': lsib2, 'blockValues': blockValues, 'sceneTable': sceneTable, 'powerConsumption': powerConsumption, 'powerPollingMinutes': powerPollingMinutes, 'gatewayRouterIpAddress': gatewayRouterIpAddress, 'refreshPropsAfterAction': refreshPropsAfterAction, 'actionResult': actionResult, 'lastMessage': lastMessage, 'lastMessageTime': lastMessageTime?.toIso8601String(), 'lastPowerUpdateTime': lastPowerUpdateTime?.toIso8601String(), }; } HelvarGroup copyWith({ String? id, String? groupId, String? description, String? type, int? lsig, int? lsib1, int? lsib2, List<double>? blockValues, List<int>? sceneTable, double? powerConsumption, int? powerPollingMinutes, String? gatewayRouterIpAddress, bool? refreshPropsAfterAction, String? actionResult, String? lastMessage, DateTime? lastMessageTime, DateTime? lastPowerUpdateTime, }) { return HelvarGroup( id: id ?? this.id, groupId: groupId ?? this.groupId, description: description ?? this.description, type: type ?? this.type, lsig: lsig ?? this.lsig, lsib1: lsib1 ?? this.lsib1, lsib2: lsib2 ?? this.lsib2, blockValues: blockValues ?? this.blockValues, sceneTable: sceneTable ?? this.sceneTable, powerConsumption: powerConsumption ?? this.powerConsumption, powerPollingMinutes: powerPollingMinutes ?? this.powerPollingMinutes, gatewayRouterIpAddress: gatewayRouterIpAddress ?? this.gatewayRouterIpAddress, refreshPropsAfterAction: refreshPropsAfterAction ?? this.refreshPropsAfterAction, actionResult: actionResult ?? this.actionResult, lastMessage: lastMessage ?? this.lastMessage, lastMessageTime: lastMessageTime ?? this.lastMessageTime, lastPowerUpdateTime: lastPowerUpdateTime ?? this.lastPowerUpdateTime, ); } } 

// File: \lib\models\helvar_models\helvar_router.dart
import '../../utils/logger.dart'; import 'helvar_device.dart'; class HelvarRouter { final String type; String address; final String ipAddress; String description; List<String>? deviceAddresses; bool isNormal; bool isMissing; bool isFaulty; int version; int clusterId; int clusterMemberId; int? deviceTypeCode; String? deviceState; int? deviceStateCode; Map<int, List<HelvarDevice>> devicesBySubnet = {}; String? deviceType; List<HelvarDevice> devices; HelvarRouter({ this.type = 'HelvarRouter', this.address = "", required this.ipAddress, this.version = 2, this.description = '', this.isNormal = true, this.isMissing = false, this.isFaulty = false, this.clusterId = 1, this.clusterMemberId = 1, this.deviceTypeCode, this.deviceState, this.deviceType, this.deviceStateCode, List<HelvarDevice>? devices, }) : devices = devices ?? [] { if (ipAddress.contains('.')) { final ipParts = ipAddress.split('.'); if (ipParts.length == 4) { try { clusterId = int.parse(ipParts[2]); clusterMemberId = int.parse(ipParts[3]); address = '@${ipParts[2]}.${ipParts[3]}'; } catch (e) { logError(e.toString()); } } } if (devices != null && devices.isNotEmpty) { organizeDevicesBySubnet(); } } void organizeDevicesBySubnet() { devicesBySubnet.clear(); for (final device in devices) { final parts = device.address.split('.'); if (parts.length >= 3) { final subnet = int.parse(parts[2]); if (!devicesBySubnet.containsKey(subnet)) { devicesBySubnet[subnet] = []; } devicesBySubnet[subnet]!.add(device); } } } void addDevice(HelvarDevice device) { devices.add(device); final subnet = device.subnet; if (!devicesBySubnet.containsKey(subnet)) { devicesBySubnet[subnet] = []; } devicesBySubnet[subnet]!.add(device); } void removeDevice(HelvarDevice device) { devices.remove(device); final subnet = device.subnet; if (devicesBySubnet.containsKey(subnet)) { devicesBySubnet[subnet]!.remove(device); if (devicesBySubnet[subnet]!.isEmpty) { devicesBySubnet.remove(subnet); } } } List<HelvarDevice> getDevicesByType(String deviceType) { return devices.where((device) => device.helvarType == deviceType).toList(); } List<HelvarDevice> getDevicesBySubnet(int subnet) { return devicesBySubnet[subnet] ?? []; } @override bool operator ==(Object other) => identical(this, other) || other is HelvarRouter && runtimeType == other.runtimeType && description == other.description && address == other.address; @override int get hashCode => description.hashCode ^ address.hashCode; factory HelvarRouter.fromJson(Map<String, dynamic> json) { return HelvarRouter( type: json['type'] as String? ?? 'HelvarRouter', address: json['address'] as String, ipAddress: json['ipAddress'] as String? ?? '', description: json['description'] as String? ?? '', isNormal: json['isNormal'] as bool? ?? true, isMissing: json['isMissing'] as bool? ?? false, isFaulty: json['isFaulty'] as bool? ?? false, clusterId: json['clusterId'] as int? ?? 1, clusterMemberId: json['clusterMemberId'] as int? ?? 1, deviceTypeCode: json['deviceTypeCode'] as int?, deviceState: json['deviceState'] as String?, deviceStateCode: json['deviceStateCode'] as int?, devices: (json['devices'] as List?) ?.map((deviceJson) => HelvarDevice.fromJson(deviceJson)) .whereType<HelvarDevice>() .toList() ?? [], ); } Map<String, dynamic> toJson() { final subnetsJson = <String, List<Map<String, dynamic>>>{}; devicesBySubnet.forEach((subnet, subnetDevices) { subnetsJson['subnet$subnet'] = subnetDevices.map((device) => device.toJson()).toList(); }); return { 'type': type, 'address': address, 'ipAddress': ipAddress, 'description': description, 'isNormal': isNormal, 'isMissing': isMissing, 'isFaulty': isFaulty, 'clusterId': clusterId, 'clusterMemberId': clusterMemberId, 'deviceTypeCode': deviceTypeCode, 'deviceState': deviceState, 'deviceStateCode': deviceStateCode, 'devicesBySubnet': subnetsJson, 'devices': devices.map((device) => device.toJson()).toList(), }; } void updateState({bool? isNormal, bool? isMissing, bool? isFaulty}) { if (isNormal != null) this.isNormal = isNormal; if (isMissing != null) this.isMissing = isMissing; if (isFaulty != null) this.isFaulty = isFaulty; } } 

// File: \lib\models\helvar_models\input_device.dart
import 'package:grms_designer/utils/device_utils.dart'; import '../../utils/logger.dart'; import 'device_action.dart'; import 'helvar_device.dart'; class HelvarDriverInputDevice extends HelvarDevice { List<ButtonPoint> buttonPoints; HelvarDriverInputDevice({ super.deviceId, super.address, super.state, super.description, super.props, super.iconPath, super.hexId, super.addressingScheme, super.emergency, super.blockId, super.sceneId, super.out, super.helvarType = "input", super.deviceTypeCode, super.deviceStateCode, super.isButtonDevice, super.isMultisensor, super.sensorInfo, super.additionalInfo, List<ButtonPoint>? buttonPoints, }) : buttonPoints = buttonPoints ?? []; @override void recallScene(String sceneParams) { out = handleRecallScene(sceneParams, logInfoOutput: false); } @override void started() { createInputPoints(address, props, addressingScheme); if (isButtonDevice && buttonPoints.isEmpty) { generateButtonPoints(); } if (isMultisensor && sensorInfo.isEmpty) { sensorInfo = { 'hasPresence': true, 'hasLightLevel': true, 'hasTemperature': false, }; } } @override void stopped() {} @override void performAction(DeviceAction action, dynamic value) { switch (action) { case DeviceAction.clearResult: clearResult(); break; default: logWarning("Action $action not supported for input device"); } } void createInputPoints( String deviceAddress, String pointProps, String subAddress, ) {} void generateButtonPoints() { if (!isButtonDevice) return; buttonPoints ..clear() ..addAll( generateStandardButtonPoints( description.isEmpty ? "Device_$deviceId" : description, ), ); } @override Map<String, dynamic> toJson() { final json = super.toJson(); json['buttonPoints'] = buttonPoints.map((point) => point.toJson()).toList(); return json; } } class ButtonPoint { final String name; final String function; final int buttonId; ButtonPoint({ required this.name, required this.function, required this.buttonId, }); Map<String, dynamic> toJson() { return {'name': name, 'function': function, 'buttonId': buttonId}; } factory ButtonPoint.fromJson(Map<String, dynamic> json) { return ButtonPoint( name: json['name'] as String, function: json['function'] as String, buttonId: json['buttonId'] as int, ); } } 

// File: \lib\models\helvar_models\output_device.dart
import 'package:grms_designer/models/helvar_models/output_point.dart'; import 'package:grms_designer/utils/device_utils.dart'; import '../../utils/logger.dart'; import 'device_action.dart'; import 'helvar_device.dart'; class HelvarDriverOutputDevice extends HelvarDevice { String missing; String faulty; int level; int proportion; double powerConsumption; List<OutputPoint> outputPoints; HelvarDriverOutputDevice({ super.deviceId, super.address, super.state, super.description, super.props, super.iconPath, super.hexId, super.addressingScheme, super.emergency, super.blockId, super.sceneId, super.out, super.helvarType = "output", super.deviceTypeCode, super.deviceStateCode, super.isButtonDevice, super.isMultisensor, super.sensorInfo, super.additionalInfo, this.missing = "", this.faulty = "", this.level = 100, this.proportion = 0, this.powerConsumption = 0, List<OutputPoint>? outputPoints, }) : outputPoints = outputPoints ?? []; @override void recallScene(String sceneParams) { out = handleRecallScene(sceneParams, logInfoOutput: true); } void directLevel(String levelParams) { try { List<String> temp = levelParams.split(','); String timestamp = DateTime.now().toString(); String s = "Success ($timestamp) Direct Level Device: ${temp[0]}"; logInfo(s); out = s; } catch (e) { logError(e.toString()); out = e.toString(); } } void directProportion(String proportionParams) { try { List<String> temp = proportionParams.split(','); String timestamp = DateTime.now().toString(); String s = "Success ($timestamp) Direct Proportion Device: ${temp[0]}"; out = s; logInfo(s); } catch (e) { logError(e.toString()); out = e.toString(); } } void modifyProportion(String proportionParams) { try { List<String> temp = proportionParams.split(','); String timestamp = DateTime.now().toString(); String s = "Success ($timestamp) Direct Proportion Device: ${temp[0]}"; logInfo(s); out = s; } catch (e) { logError(e.toString()); out = e.toString(); } } @override void started() { generateOutputPoints(); } String getName() { return description.isNotEmpty ? description : "Device_$deviceId"; } @override void stopped() {} @override void performAction(DeviceAction action, dynamic value) { switch (action) { case DeviceAction.clearResult: clearResult(); break; case DeviceAction.recallScene: if (value is int) { recallScene("1,$value"); } break; case DeviceAction.directLevel: if (value is int) { directLevel("$value"); } break; case DeviceAction.directProportion: if (value is int) { directProportion("$value"); } break; case DeviceAction.modifyProportion: if (value is int) { modifyProportion("$value"); } break; default: logWarning("Action $action not supported for output device"); } } void generateOutputPoints() { if (outputPoints.isNotEmpty) return; final deviceName = description.isEmpty ? "Device_$deviceId" : description; outputPoints.addAll([ OutputPoint( name: '${deviceName}_DeviceState', function: 'DeviceState', pointId: 1, pointType: 'boolean', value: false, ), OutputPoint( name: '${deviceName}_LampFailure', function: 'LampFailure', pointId: 2, pointType: 'boolean', value: false, ), OutputPoint( name: '${deviceName}_Missing', function: 'Missing', pointId: 3, pointType: 'boolean', value: false, ), OutputPoint( name: '${deviceName}_Faulty', function: 'Faulty', pointId: 4, pointType: 'boolean', value: false, ), OutputPoint( name: '${deviceName}_OutputLevel', function: 'OutputLevel', pointId: 5, pointType: 'numeric', value: 0.0, ), OutputPoint( name: '${deviceName}_PowerConsumption', function: 'PowerConsumption', pointId: 6, pointType: 'numeric', value: 0.0, ), ]); } Future<void> updatePointValue(int pointId, dynamic value) async { final point = outputPoints.firstWhere( (p) => p.pointId == pointId, orElse: () => throw ArgumentError('Point with ID $pointId not found'), ); point.value = value; logInfo('Updated point ${point.name} to value: $value'); } OutputPoint? getPointById(int pointId) { try { return outputPoints.firstWhere((p) => p.pointId == pointId); } catch (e) { return null; } } OutputPoint? getPointByName(String name) { try { return outputPoints.firstWhere((p) => p.name == name); } catch (e) { return null; } } @override Map<String, dynamic> toJson() { final json = super.toJson(); json['missing'] = missing; json['faulty'] = faulty; json['level'] = level; json['proportion'] = proportion; json['outputPoints'] = outputPoints.map((point) => point.toJson()).toList(); return json; } } 

// File: \lib\models\helvar_models\output_point.dart
class OutputPoint { final String name; final String function; final int pointId; final String pointType; dynamic value; OutputPoint({ required this.name, required this.function, required this.pointId, required this.pointType, this.value, }); Map<String, dynamic> toJson() { return { 'name': name, 'function': function, 'pointId': pointId, 'pointType': pointType, 'value': value, }; } factory OutputPoint.fromJson(Map<String, dynamic> json) { return OutputPoint( name: json['name'] as String, function: json['function'] as String, pointId: json['pointId'] as int, pointType: json['pointType'] as String, value: json['value'], ); } } 

// File: \lib\models\helvar_models\workgroup.dart
import 'package:flutter_simple_treeview/flutter_simple_treeview.dart'; import 'helvar_router.dart'; import 'helvar_group.dart'; class Workgroup extends TreeNode { final String id; final String description; final String networkInterface; final String gatewayRouterIpAddress; final bool refreshPropsAfterAction; final bool pollEnabled; final DateTime? lastPollTime; List<HelvarRouter> routers; List<HelvarGroup> groups; Workgroup({ required this.id, this.description = '', required this.networkInterface, this.gatewayRouterIpAddress = '', this.refreshPropsAfterAction = false, this.pollEnabled = false, this.lastPollTime, List<HelvarRouter>? routers, List<HelvarGroup>? groups, }) : routers = routers ?? [], groups = groups ?? []; void addRouter(HelvarRouter router) { routers.add(router); } void removeRouter(HelvarRouter router) { routers.remove(router); } void addGroup(HelvarGroup group) { groups.add(group); } void removeGroup(HelvarGroup group) { groups.remove(group); } Workgroup copyWith({ String? id, String? description, String? networkInterface, int? groupPowerPollingMinutes, String? gatewayRouterIpAddress, bool? refreshPropsAfterAction, bool? pollEnabled, DateTime? lastPollTime, List<HelvarRouter>? routers, List<HelvarGroup>? groups, }) { return Workgroup( id: id ?? this.id, description: description ?? this.description, networkInterface: networkInterface ?? this.networkInterface, gatewayRouterIpAddress: gatewayRouterIpAddress ?? this.gatewayRouterIpAddress, refreshPropsAfterAction: refreshPropsAfterAction ?? this.refreshPropsAfterAction, pollEnabled: pollEnabled ?? this.pollEnabled, lastPollTime: lastPollTime ?? this.lastPollTime, routers: routers ?? this.routers, groups: groups ?? this.groups, ); } factory Workgroup.fromJson(Map<String, dynamic> json) { return Workgroup( id: json['id'] as String, description: json['description'] as String? ?? '', networkInterface: json['networkInterface'] as String, gatewayRouterIpAddress: json['gatewayRouterIpAddress'] as String? ?? '', refreshPropsAfterAction: json['refreshPropsAfterAction'] as bool? ?? false, pollEnabled: json['pollEnabled'] as bool? ?? false, lastPollTime: json['lastPollTime'] != null ? DateTime.parse(json['lastPollTime'] as String) : null, routers: (json['routers'] as List?) ?.map((routerJson) => HelvarRouter.fromJson(routerJson)) .toList(), groups: (json['groups'] as List?) ?.map((groupJson) => HelvarGroup.fromJson(groupJson)) .toList() ?? [], ); } Map<String, dynamic> toJson() { return { 'id': id, 'description': description, 'networkInterface': networkInterface, 'gatewayRouterIpAddress': gatewayRouterIpAddress, 'refreshPropsAfterAction': refreshPropsAfterAction, 'pollEnabled': pollEnabled, 'lastPollTime': lastPollTime?.toIso8601String(), 'routers': routers.map((router) => router.toJson()).toList(), 'groups': groups.map((group) => group.toJson()).toList(), }; } } 

// File: \lib\models\project_settings.dart
class ProjectSettings { String projectName; int socketTimeoutMs; bool autoSave; int autoSaveIntervalMinutes; int commandTimeoutMs; int heartbeatIntervalSeconds; int maxCommandRetries; int maxConcurrentCommandsPerRouter; int commandHistorySize; int protocolVersion; ProjectSettings({ this.projectName = 'Default Project', this.socketTimeoutMs = 15000, this.autoSave = true, this.autoSaveIntervalMinutes = 5, this.commandTimeoutMs = 10000,  this.heartbeatIntervalSeconds = 30,  this.maxCommandRetries = 3, this.maxConcurrentCommandsPerRouter = 5, this.commandHistorySize = 100, this.protocolVersion = 2, }); ProjectSettings copyWith({ String? projectName, int? socketTimeoutMs, bool? autoSave, int? autoSaveIntervalMinutes, int? commandTimeoutMs, int? heartbeatIntervalSeconds, int? maxCommandRetries, int? maxConcurrentCommandsPerRouter, int? commandHistorySize, int? protocolVersion, }) { return ProjectSettings( projectName: projectName ?? this.projectName, socketTimeoutMs: socketTimeoutMs ?? this.socketTimeoutMs, autoSave: autoSave ?? this.autoSave, autoSaveIntervalMinutes: autoSaveIntervalMinutes ?? this.autoSaveIntervalMinutes, commandTimeoutMs: commandTimeoutMs ?? this.commandTimeoutMs, heartbeatIntervalSeconds: heartbeatIntervalSeconds ?? this.heartbeatIntervalSeconds, maxCommandRetries: maxCommandRetries ?? this.maxCommandRetries, maxConcurrentCommandsPerRouter: maxConcurrentCommandsPerRouter ?? this.maxConcurrentCommandsPerRouter, commandHistorySize: commandHistorySize ?? this.commandHistorySize, protocolVersion: protocolVersion ?? this.protocolVersion, ); } Map<String, dynamic> toJson() { return { 'projectName': projectName, 'socketTimeoutMs': socketTimeoutMs, 'autoSave': autoSave, 'autoSaveIntervalMinutes': autoSaveIntervalMinutes, 'commandTimeoutMs': commandTimeoutMs, 'heartbeatIntervalSeconds': heartbeatIntervalSeconds, 'maxCommandRetries': maxCommandRetries, 'maxConcurrentCommandsPerRouter': maxConcurrentCommandsPerRouter, 'commandHistorySize': commandHistorySize, 'protocolVersion': protocolVersion, }; } factory ProjectSettings.fromJson(Map<String, dynamic> json) { return ProjectSettings( projectName: json['projectName'] as String? ?? 'Default Project', socketTimeoutMs: json['socketTimeoutMs'] as int? ?? 15000, autoSave: json['autoSave'] as bool? ?? true, autoSaveIntervalMinutes: json['autoSaveIntervalMinutes'] as int? ?? 5, commandTimeoutMs: json['commandTimeoutMs'] as int? ?? 10000, heartbeatIntervalSeconds: json['heartbeatIntervalSeconds'] as int? ?? 30, maxCommandRetries: json['maxCommandRetries'] as int? ?? 3, maxConcurrentCommandsPerRouter: json['maxConcurrentCommandsPerRouter'] as int? ?? 5, commandHistorySize: json['commandHistorySize'] as int? ?? 100, protocolVersion: json['protocolVersion'] as int? ?? 2, ); } } 

// File: \lib\niagara\controllers\canvas_interaction_controller.dart
import 'package:flutter/material.dart'; class CanvasInteractionController { final TransformationController transformationController; Matrix4? _cachedInverseMatrix; Matrix4? _lastMatrix; Size _canvasSize; Offset _canvasOffset; static const double canvasPadding = 100.0; bool isDragging = false; CanvasInteractionController({ Size initialCanvasSize = const Size(2000, 2000), Offset initialCanvasOffset = Offset.zero, }) : transformationController = TransformationController(), _canvasSize = initialCanvasSize, _canvasOffset = initialCanvasOffset { transformationController.value = Matrix4.identity(); } Size get canvasSize => _canvasSize; Offset get canvasOffset => _canvasOffset; void resetView() { transformationController.value = Matrix4.identity(); } Offset? getCanvasPositionOptimized( Offset globalPosition, RenderBox canvasBox, ) { final Offset localPosition = canvasBox.globalToLocal(globalPosition); final matrix = transformationController.value; if (_lastMatrix != matrix) { _cachedInverseMatrix = Matrix4.inverted(matrix); _lastMatrix = matrix.clone(); } final canvasPosition = MatrixUtils.transformPoint( _cachedInverseMatrix!, localPosition, ); return canvasPosition; } Rect getViewportBounds(Size viewportSize) { final matrix = transformationController.value; final inverseMatrix = Matrix4.inverted(matrix); final topLeft = MatrixUtils.transformPoint(inverseMatrix, Offset.zero); final bottomRight = MatrixUtils.transformPoint( inverseMatrix, Offset(viewportSize.width, viewportSize.height), ); return Rect.fromPoints(topLeft, bottomRight); } bool isComponentVisible( Offset componentPos, Size componentSize, Size viewportSize, ) { final viewportBounds = getViewportBounds(viewportSize); final componentRect = Rect.fromLTWH( componentPos.dx, componentPos.dy, componentSize.width, componentSize.height, ); return viewportBounds.overlaps(componentRect); } void clearCache() { _cachedInverseMatrix = null; _lastMatrix = null; } bool updateCanvasSize( Map<String, Offset> componentPositions, Map<String, double> componentWidths, ) { if (componentPositions.isEmpty) return false; double minX = double.infinity; double minY = double.infinity; double maxX = double.negativeInfinity; double maxY = double.negativeInfinity; componentPositions.forEach((id, position) { final width = componentWidths[id] ?? 160.0; const estimatedHeight = 120.0; minX = minX < position.dx ? minX : position.dx; minY = minY < position.dy ? minY : position.dy; maxX = maxX > position.dx + width ? maxX : position.dx + width; maxY = maxY > position.dy + estimatedHeight ? maxY : position.dy + estimatedHeight; }); bool needsUpdate = false; Size newCanvasSize = _canvasSize; Offset newCanvasOffset = _canvasOffset; if (minX < canvasPadding) { double extraWidth = canvasPadding - minX; newCanvasSize = Size( _canvasSize.width + extraWidth, newCanvasSize.height, ); newCanvasOffset = Offset( _canvasOffset.dx - extraWidth, newCanvasOffset.dy, ); needsUpdate = true; } if (minY < canvasPadding) { double extraHeight = canvasPadding - minY; newCanvasSize = Size( newCanvasSize.width, _canvasSize.height + extraHeight, ); newCanvasOffset = Offset( newCanvasOffset.dx, _canvasOffset.dy - extraHeight, ); needsUpdate = true; } if (maxX > _canvasSize.width - canvasPadding) { double extraWidth = maxX - (_canvasSize.width - canvasPadding); newCanvasSize = Size( _canvasSize.width + extraWidth, newCanvasSize.height, ); needsUpdate = true; } if (maxY > _canvasSize.height - canvasPadding) { double extraHeight = maxY - (_canvasSize.height - canvasPadding); newCanvasSize = Size( newCanvasSize.width, _canvasSize.height + extraHeight, ); needsUpdate = true; } if (needsUpdate) { _canvasSize = newCanvasSize; _canvasOffset = newCanvasOffset; clearCache(); return true; } return false; } Offset? getCanvasPosition(Offset globalPosition, RenderBox canvasBox) { final Offset localPosition = canvasBox.globalToLocal(globalPosition); final matrix = transformationController.value; final inverseMatrix = Matrix4.inverted(matrix); final canvasPosition = MatrixUtils.transformPoint( inverseMatrix, localPosition, ); return canvasPosition; } Map<String, Offset> getAdjustedPositions( Map<String, Offset> componentPositions, Offset offsetChange, ) { if (offsetChange == Offset.zero) return componentPositions; final adjustedPositions = <String, Offset>{}; componentPositions.forEach((id, position) { adjustedPositions[id] = position + offsetChange; }); return adjustedPositions; } void setCanvasSize(Size size, Offset offset) { _canvasSize = size; _canvasOffset = offset; } } 

// File: \lib\niagara\controllers\clipboard_manager.dart
import 'package:flutter/material.dart'; import '../models/component.dart'; import '../models/connection.dart'; class ClipboardManager { final List<Component> _clipboardComponents = []; final List<Offset> _clipboardPositions = []; final List<Connection> _clipboardConnections = []; Offset? _clipboardReferencePosition; List<Component> get clipboardComponents => _clipboardComponents; List<Offset> get clipboardPositions => _clipboardPositions; List<Connection> get clipboardConnections => _clipboardConnections; Offset? get clipboardReferencePosition => _clipboardReferencePosition; bool get isEmpty => _clipboardComponents.isEmpty; void copyComponent(Component component, Offset position) { _clipboardComponents.clear(); _clipboardPositions.clear(); _clipboardConnections.clear(); _clipboardComponents.add(component); _clipboardPositions.add(position); _clipboardReferencePosition = position; } void copyMultipleComponents( Set<Component> components, Map<String, Offset> componentPositions, List<Connection> allConnections, ) { if (components.isEmpty) return; _clipboardComponents.clear(); _clipboardPositions.clear(); _clipboardConnections.clear(); Map<String, int> componentIndexMap = {}; int index = 0; for (final component in components) { _clipboardComponents.add(component); final position = componentPositions[component.id] ?? Offset.zero; _clipboardPositions.add(position); componentIndexMap[component.id] = index; index++; } for (final connection in allConnections) { final fromSelected = componentIndexMap.containsKey( connection.fromComponentId, ); final toSelected = componentIndexMap.containsKey( connection.toComponentId, ); if (fromSelected && toSelected) { _clipboardConnections.add(connection); } } if (_clipboardComponents.isNotEmpty) { _clipboardReferencePosition = _clipboardPositions.first; } } void setClipboardReferencePosition(Offset position) { _clipboardReferencePosition = position; } void clear() { _clipboardComponents.clear(); _clipboardPositions.clear(); _clipboardConnections.clear(); _clipboardReferencePosition = null; } List<Offset> getRelativePositions() { if (_clipboardReferencePosition == null || _clipboardPositions.isEmpty) { return List.filled(_clipboardPositions.length, Offset.zero); } return _clipboardPositions .map((pos) => pos - _clipboardReferencePosition!) .toList(); } List<Offset> calculatePastePositions(Offset targetPosition) { final relativePositions = getRelativePositions(); return relativePositions.map((relPos) => targetPosition + relPos).toList(); } } 

// File: \lib\niagara\controllers\drag_operation_manager.dart
import 'package:flutter/material.dart'; import '../home/component_widget.dart'; import '../models/component.dart'; class DragOperationManager { SlotDragInfo? _currentDraggedPort; Offset? _tempLineEndPoint; Offset? _dragStartPosition; SlotDragInfo? get currentDraggedPort => _currentDraggedPort; Offset? get tempLineEndPoint => _tempLineEndPoint; Offset? get dragStartPosition => _dragStartPosition; void startPortDrag(SlotDragInfo slotInfo) { _currentDraggedPort = slotInfo; } void updatePortDragPosition(Offset position) { _tempLineEndPoint = position; } void endPortDrag() { _currentDraggedPort = null; _tempLineEndPoint = null; } void startComponentDrag(Offset position) { _dragStartPosition = position; } void endComponentDrag() { _dragStartPosition = null; } Offset calculateDragOffset(Offset currentPosition) { if (_dragStartPosition == null) return Offset.zero; return currentPosition - _dragStartPosition!; } bool isComponentDragInProgress() { return _dragStartPosition != null; } bool isPortDragInProgress() { return _currentDraggedPort != null; } Map<String, Offset> moveComponentsByOffset( Map<String, Offset> componentPositions, Set<Component> selectedComponents, Offset offset, ) { final Map<String, Offset> updatedPositions = Map.from(componentPositions); for (var component in selectedComponents) { final currentPos = componentPositions[component.id]; if (currentPos != null) { updatedPositions[component.id] = currentPos + offset; } } return updatedPositions; } Map<String, Offset> moveComponentToPosition( Map<String, Offset> componentPositions, String componentId, Offset newPosition, ) { final Map<String, Offset> updatedPositions = Map.from(componentPositions); updatedPositions[componentId] = newPosition; return updatedPositions; } } 

// File: \lib\niagara\controllers\flow_editor_state.dart
import 'package:flutter/material.dart'; import '../models/component.dart'; import '../models/command_history.dart'; import '../home/manager.dart'; class FlowEditorState { final FlowManager flowManager; final CommandHistory commandHistory; final Map<String, Offset> componentPositions = {}; final Map<String, GlobalKey> componentKeys = {}; final Map<String, double> componentWidths = {}; final GlobalKey canvasKey = GlobalKey(); final GlobalKey interactiveViewerChildKey = GlobalKey(); bool isPanelExpanded = false; FlowEditorState({required this.flowManager, required this.commandHistory}); void initializeComponentState( Component component, { Offset position = Offset.zero, double width = 160.0, }) { componentPositions[component.id] = position; componentKeys[component.id] = GlobalKey(); componentWidths[component.id] = width; } Offset getComponentPosition(String componentId) { return componentPositions[componentId] ?? Offset.zero; } void setComponentPosition(String componentId, Offset position) { componentPositions[componentId] = position; } double getComponentWidth(String componentId) { return componentWidths[componentId] ?? 160.0; } void setComponentWidth(String componentId, double width) { componentWidths[componentId] = width; } GlobalKey getComponentKey(String componentId) { if (!componentKeys.containsKey(componentId)) { componentKeys[componentId] = GlobalKey(); } return componentKeys[componentId]!; } bool isPointOverComponent(Offset point) { for (final entry in componentPositions.entries) { final componentPos = entry.value; const double componentWidth = 180.0; const double componentHeight = 150.0; final componentRect = Rect.fromLTWH( componentPos.dx, componentPos.dy, componentWidth, componentHeight, ); if (componentRect.contains(point)) { return true; } } return false; } Component? findComponentAtPoint(Offset point) { for (final component in flowManager.components) { final componentPos = componentPositions[component.id]; if (componentPos != null) { const double componentWidth = 180.0; const double componentHeight = 150.0; final componentRect = Rect.fromLTWH( componentPos.dx, componentPos.dy, componentWidth, componentHeight, ); if (componentRect.contains(point)) { return component; } } } return null; } void clear() { componentPositions.clear(); componentKeys.clear(); componentWidths.clear(); flowManager.components.clear(); flowManager.connections.clear(); commandHistory.clear(); } } 

// File: \lib\niagara\controllers\selection_manager.dart
import 'package:flutter/services.dart'; import '../models/component.dart'; typedef SelectionChangedCallback = void Function(Set<Component> selected); class SelectionManager { final Set<Component> _selectedComponents = {}; SelectionChangedCallback? _onSelectionChanged; Offset? _selectionBoxStart; Offset? _selectionBoxEnd; bool _isDraggingSelectionBox = false; Set<Component> get selectedComponents => _selectedComponents; bool get isDraggingSelectionBox => _isDraggingSelectionBox; Offset? get selectionBoxStart => _selectionBoxStart; Offset? get selectionBoxEnd => _selectionBoxEnd; Rect? getSelectionRect() { if (_selectionBoxStart == null || _selectionBoxEnd == null) return null; return Rect.fromPoints(_selectionBoxStart!, _selectionBoxEnd!); } void clearSelection() { if (_selectedComponents.isNotEmpty) { _selectedComponents.clear(); _notifySelectionChanged(); } } void selectComponent(Component component) { clearSelection(); _selectedComponents.add(component); _notifySelectionChanged(); } void toggleComponentSelection(Component component) { if (_selectedComponents.contains(component)) { _selectedComponents.remove(component); } else { _selectedComponents.add(component); } _notifySelectionChanged(); } bool isComponentSelected(Component component) { return _selectedComponents.contains(component); } void startSelectionBox(Offset position) { _selectionBoxStart = position; _selectionBoxEnd = position; _isDraggingSelectionBox = true; } void updateSelectionBox(Offset position) { if (_isDraggingSelectionBox) { _selectionBoxEnd = position; } } void endSelectionBox( List<Component> allComponents, Map<String, Offset> componentPositions, ) { if (!_isDraggingSelectionBox || _selectionBoxStart == null || _selectionBoxEnd == null) { _isDraggingSelectionBox = false; return; } final selectionRect = getSelectionRect(); if (selectionRect == null) { _isDraggingSelectionBox = false; return; } if (!HardwareKeyboard.instance.isControlPressed) { clearSelection(); } for (final component in allComponents) { final componentPos = componentPositions[component.id]; if (componentPos != null) { const double componentWidth = 180.0; const double componentHeight = 150.0; final componentRect = Rect.fromLTWH( componentPos.dx, componentPos.dy, componentWidth, componentHeight, ); if (selectionRect.overlaps(componentRect)) { _selectedComponents.add(component); } } } _isDraggingSelectionBox = false; _selectionBoxStart = null; _selectionBoxEnd = null; } void cancelSelectionBox() { _isDraggingSelectionBox = false; _selectionBoxStart = null; _selectionBoxEnd = null; } void selectAll(List<Component> allComponents) { _selectedComponents.clear(); _selectedComponents.addAll(allComponents); } void endSelectionBoxWithSizes( List<Component> allComponents, Map<String, Offset> componentPositions, Map<String, double> componentWidths, double defaultHeight, ) { if (!_isDraggingSelectionBox || _selectionBoxStart == null || _selectionBoxEnd == null) { _isDraggingSelectionBox = false; return; } final selectionRect = getSelectionRect(); if (selectionRect == null) { _isDraggingSelectionBox = false; return; } if (!HardwareKeyboard.instance.isControlPressed) { clearSelection(); } for (final component in allComponents) { final componentPos = componentPositions[component.id]; if (componentPos != null) { final componentWidth = componentWidths[component.id] ?? 160.0; final componentHeight = defaultHeight; final componentRect = Rect.fromLTWH( componentPos.dx, componentPos.dy, componentWidth + 20, componentHeight, ); if (selectionRect.overlaps(componentRect)) { _selectedComponents.add(component); } } } _isDraggingSelectionBox = false; _selectionBoxStart = null; _selectionBoxEnd = null; } void setOnSelectionChanged(SelectionChangedCallback callback) { _onSelectionChanged = callback; } void _notifySelectionChanged() { _onSelectionChanged?.call(_selectedComponents); } } 

// File: \lib\niagara\home\command.dart
import 'package:flutter/widgets.dart'; import '../models/command.dart'; import '../models/component.dart'; import '../models/connection.dart'; import 'manager.dart'; class AddComponentCommand extends Command { final FlowManager flowManager; final Component component; final Map<String, dynamic> state; AddComponentCommand(this.flowManager, this.component, this.state); @override void execute() { flowManager.addComponent(component); if (state.containsKey('position')) { (state['positions'] as Map<String, Offset>)[component.id] = state['position']; } if (state.containsKey('key')) { (state['keys'] as Map<String, GlobalKey>)[component.id] = state['key']; } } @override void undo() { flowManager.removeComponent(component.id); if (state.containsKey('positions')) { (state['positions'] as Map<String, Offset>).remove(component.id); } if (state.containsKey('keys')) { (state['keys'] as Map<String, GlobalKey>).remove(component.id); } } @override String get description => 'Add ${component.id}'; } class RemoveComponentCommand extends Command { final FlowManager flowManager; final Component component; final Offset position; final GlobalKey? key; final List<Connection> affectedConnections; RemoveComponentCommand( this.flowManager, this.component, this.position, this.key, this.affectedConnections, ); @override void execute() { flowManager.removeComponent(component.id); } @override void undo() { flowManager.addComponent(component); for (var connection in affectedConnections) { flowManager.createConnection( connection.fromComponentId, connection.fromPortIndex, connection.toComponentId, connection.toPortIndex, ); } } @override String get description => 'Remove ${component.id}'; } class CreateConnectionCommand extends Command { final FlowManager flowManager; final String fromComponentId; final int fromPortIndex; final String toComponentId; final int toPortIndex; CreateConnectionCommand( this.flowManager, this.fromComponentId, this.fromPortIndex, this.toComponentId, this.toPortIndex, ); @override void execute() { flowManager.createConnection( fromComponentId, fromPortIndex, toComponentId, toPortIndex, ); } @override void undo() { flowManager.removeConnection( fromComponentId, fromPortIndex, toComponentId, toPortIndex, ); } @override String get description => 'Connect $fromComponentId→$toComponentId'; } class UpdatePortValueCommand extends Command { final FlowManager flowManager; final String componentId; final int slotIndex; final dynamic newValue; final dynamic oldValue; UpdatePortValueCommand( this.flowManager, this.componentId, this.slotIndex, this.newValue, this.oldValue, ); @override void execute() { flowManager.updatePortValue(componentId, slotIndex, newValue); } @override void undo() { flowManager.updatePortValue(componentId, slotIndex, oldValue); } @override String get description => 'Change $componentId value'; } class MoveComponentCommand extends Command { final String componentId; final Offset newPosition; final Offset oldPosition; final Map<String, Offset> componentPositions; MoveComponentCommand( this.componentId, this.newPosition, this.oldPosition, this.componentPositions, ); @override void execute() { componentPositions[componentId] = newPosition; } @override void undo() { componentPositions[componentId] = oldPosition; } @override String get description => 'Move $componentId'; } 

// File: \lib\niagara\home\component_mixin.dart
import 'package:grms_designer/niagara/models/port.dart'; mixin ComponentMixin { List<Property> get properties; List<ActionSlot> get actions; List<Topic> get topics; Property? getPropertyByIndex(int index) { try { return properties.firstWhere((prop) => prop.index == index); } catch (e) { return null; } } ActionSlot? getActionByIndex(int index) { try { return actions.firstWhere((action) => action.index == index); } catch (e) { return null; } } Topic? getTopicByIndex(int index) { try { return topics.firstWhere((topic) => topic.index == index); } catch (e) { return null; } } Slot? getSlotByIndex(int index) { return getPropertyByIndex(index) ?? getActionByIndex(index) ?? getTopicByIndex(index); } } 

// File: \lib\niagara\home\component_widget.dart
import 'package:flutter/material.dart'; import 'package:grms_designer/utils/device_utils.dart'; import '../../utils/general_ui.dart'; import '../models/component.dart'; import '../models/port.dart'; import '../models/port_type.dart'; class SlotDragInfo { final String componentId; final int slotIndex; SlotDragInfo(this.componentId, this.slotIndex); } class ComponentWidget extends StatefulWidget { final Component component; final GlobalKey widgetKey; final Offset position; final bool isSelected; final double width; final double height; final Function(String, int, dynamic) onValueChanged; final Function(SlotDragInfo) onSlotDragStarted; final Function(SlotDragInfo) onSlotDragAccepted; final Function(String, double) onWidthChanged; const ComponentWidget({ super.key, required this.component, required this.isSelected, required this.widgetKey, required this.position, required this.width, required this.height, required this.onValueChanged, required this.onSlotDragStarted, required this.onSlotDragAccepted, required this.onWidthChanged, }); @override State<ComponentWidget> createState() => _ComponentWidgetState(); } class _ComponentWidgetState extends State<ComponentWidget> { static const double itemExternalPadding = 4.0; static const double itemTitleSectionHeight = 22.0; @override Widget build(BuildContext context) { return Container( key: widget.widgetKey, padding: const EdgeInsets.all(itemExternalPadding), decoration: BoxDecoration( color: getComponentColor(widget.component), borderRadius: BorderRadius.circular(8), boxShadow: [ BoxShadow( color: Colors.black.withValues(alpha: 0.2 * 255), blurRadius: 3, offset: const Offset(1, 2), ), ], border: Border.all( color: widget.isSelected ? Colors.indigo : Colors.transparent, width: widget.isSelected ? 1.5 : 0.3, ), ), child: Column( mainAxisSize: MainAxisSize.min, crossAxisAlignment: CrossAxisAlignment.start, children: [ _buildTitleSection(), const SizedBox(height: 1), Row( crossAxisAlignment: CrossAxisAlignment.start, children: [ Container( width: widget.width, decoration: BoxDecoration( border: Border.all( color: Colors.black.withValues(alpha: .25 * 255), ), color: Colors.white.withValues(alpha: 0.5 * 255), borderRadius: BorderRadius.circular(3), ), child: Column( mainAxisSize: MainAxisSize.min, children: [ if (widget.component.properties.isNotEmpty) ..._buildSectionHeader("Properties"), ...widget.component.properties.map( (property) => _buildPropertyRow(property), ), if (widget.component.actions.isNotEmpty) ..._buildSectionHeader("Actions"), ...widget.component.actions.map( (action) => _buildActionRow(action), ), if (widget.component.topics.isNotEmpty) ..._buildSectionHeader("Topics"), ...widget.component.topics.map( (topic) => _buildTopicRow(topic), ), ], ), ), _buildResizeHandle(), ], ), ], ), ); } Widget _buildTitleSection() { return SizedBox( height: itemTitleSectionHeight, width: widget.width, child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Expanded( child: Text( widget.component.id, style: const TextStyle( fontSize: 11, fontWeight: FontWeight.bold, color: Colors.black87, ), maxLines: 1, overflow: TextOverflow.ellipsis, ), ), Container( padding: const EdgeInsets.symmetric(horizontal: 3, vertical: 1), margin: const EdgeInsets.only(left: 3), decoration: BoxDecoration( color: Colors.white, borderRadius: BorderRadius.circular(3), border: Border.all(color: Colors.black45, width: 0.5), ), child: Text( getComponentSymbol(widget.component), style: TextStyle( fontSize: 9, fontWeight: FontWeight.bold, color: getComponentTextColor(widget.component), ), ), ), ], ), ); } Widget _buildResizeHandle() { return GestureDetector( onHorizontalDragUpdate: (details) { double newWidth = widget.width + details.delta.dx; if (newWidth >= 80.0) { widget.onWidthChanged(widget.component.id, newWidth); } }, child: MouseRegion( cursor: SystemMouseCursors.resizeLeftRight, child: Container( width: 6.0, height: widget.height, color: Colors.transparent, child: Center( child: Container( width: 2.0, height: 16.0, decoration: BoxDecoration( color: Colors.grey.withValues(alpha: 0.7 * 255), borderRadius: BorderRadius.circular(1.0), ), ), ), ), ), ); } List<Widget> _buildSectionHeader(String title) { return [ Container( color: Colors.grey.shade200, padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 1), child: Text( title, style: TextStyle( fontWeight: FontWeight.bold, fontSize: 9, color: Colors.grey.shade800, ), ), ), ]; } Widget _buildPropertyRow(Property property) { final isInput = property.isInput; final label = property.name; return DragTarget<SlotDragInfo>( onAcceptWithDetails: (DragTargetDetails<SlotDragInfo> details) { widget.onSlotDragAccepted( SlotDragInfo(widget.component.id, property.index), ); }, builder: (context, candidateData, rejectedData) { return LongPressDraggable<SlotDragInfo>( data: SlotDragInfo(widget.component.id, property.index), feedback: Material( elevation: 3.0, color: Colors.transparent, child: Container( height: rowHeight, decoration: BoxDecoration( color: Colors.indigo.withValues(alpha: 0.2 * 255), border: Border.all(color: Colors.indigo, width: 1.0), borderRadius: BorderRadius.circular(2.0), ), child: Center( child: Text( label, style: const TextStyle( fontSize: 9, color: Colors.indigo, fontWeight: FontWeight.bold, ), ), ), ), ), onDragStarted: () { widget.onSlotDragStarted( SlotDragInfo(widget.component.id, property.index), ); }, child: Container( height: rowHeight, alignment: Alignment.centerLeft, padding: const EdgeInsets.symmetric(horizontal: 4.0), decoration: BoxDecoration( color: (candidateData.isNotEmpty) ? Colors.lightBlue.withValues(alpha: 0.3 * 255) : null, border: Border( bottom: BorderSide( color: Colors.black.withValues(alpha: .15 * 255), width: 0.5, ), ), ), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Row( mainAxisSize: MainAxisSize.min, children: [ Icon( isInput ? Icons.arrow_back : Icons.arrow_forward, size: 12, color: Colors.indigo.withValues(alpha: 0.6 * 255), ), const SizedBox(width: 3), Text( label, style: TextStyle( fontSize: 9, color: Colors.black.withValues(alpha: 0.8 * 255), ), ), const SizedBox(width: 3), buildTypeIndicator(property.type), ], ), _buildPropertyValueDisplay(property), ], ), ), ); }, ); } Widget _buildActionRow(ActionSlot action) { final label = action.name; return DragTarget<SlotDragInfo>( onAcceptWithDetails: (DragTargetDetails<SlotDragInfo> details) { widget.onSlotDragAccepted( SlotDragInfo(widget.component.id, action.index), ); }, builder: (context, candidateData, rejectedData) { return LongPressDraggable<SlotDragInfo>( data: SlotDragInfo(widget.component.id, action.index), feedback: Material( elevation: 3.0, color: Colors.transparent, child: Container( height: rowHeight, decoration: BoxDecoration( color: Colors.amber.withValues(alpha: 0.2 * 255), border: Border.all(color: Colors.amber.shade800, width: 1.0), borderRadius: BorderRadius.circular(2.0), ), child: Center( child: Text( label, style: TextStyle( fontSize: 9, color: Colors.amber.shade800, fontWeight: FontWeight.bold, ), ), ), ), ), onDragStarted: () { widget.onSlotDragStarted( SlotDragInfo(widget.component.id, action.index), ); }, child: Container( height: rowHeight, alignment: Alignment.centerLeft, padding: const EdgeInsets.symmetric(horizontal: 4.0), decoration: BoxDecoration( color: (candidateData.isNotEmpty) ? Colors.amber.withValues(alpha: 0.2 * 255) : null, border: Border( bottom: BorderSide( color: Colors.black.withValues(alpha: .15 * 255), width: 0.5, ), ), ), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Row( mainAxisSize: MainAxisSize.min, children: [ Icon( Icons.flash_on, size: 12, color: Colors.amber.shade800, ), const SizedBox(width: 3), Text( label, style: TextStyle( fontSize: 9, color: Colors.black.withValues(alpha: 0.8 * 255), ), ), if (action.parameterType != null) ...[ const SizedBox(width: 3), buildTypeIndicator(action.parameterType!), ], ], ), IconButton( icon: Icon( Icons.play_arrow, size: 12, color: Colors.amber.shade800, ), constraints: const BoxConstraints.tightFor( width: 20, height: 20, ), padding: EdgeInsets.zero, onPressed: () { widget.onValueChanged( widget.component.id, action.index, null, ); }, ), ], ), ), ); }, ); } Widget _buildTopicRow(Topic topic) { final label = topic.name; return DragTarget<SlotDragInfo>( onAcceptWithDetails: (DragTargetDetails<SlotDragInfo> details) { widget.onSlotDragAccepted( SlotDragInfo(widget.component.id, topic.index), ); }, builder: (context, candidateData, rejectedData) { return LongPressDraggable<SlotDragInfo>( data: SlotDragInfo(widget.component.id, topic.index), feedback: Material( elevation: 3.0, color: Colors.transparent, child: Container( height: rowHeight, decoration: BoxDecoration( color: Colors.green.withValues(alpha: 0.2 * 255), border: Border.all(color: Colors.green.shade800, width: 1.0), borderRadius: BorderRadius.circular(2.0), ), child: Center( child: Text( label, style: TextStyle( fontSize: 9, color: Colors.green.shade800, fontWeight: FontWeight.bold, ), ), ), ), ), onDragStarted: () { widget.onSlotDragStarted( SlotDragInfo(widget.component.id, topic.index), ); }, child: Container( height: rowHeight, alignment: Alignment.centerLeft, padding: const EdgeInsets.symmetric(horizontal: 4.0), decoration: BoxDecoration( color: (candidateData.isNotEmpty) ? Colors.green.withValues(alpha: 0.2 * 255) : null, border: Border( bottom: BorderSide( color: Colors.black.withValues(alpha: .15 * 255), width: 0.5, ), ), ), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Row( mainAxisSize: MainAxisSize.min, children: [ Icon( Icons.volume_up, size: 12, color: Colors.green.shade800, ), const SizedBox(width: 3), Text( label, style: TextStyle( fontSize: 9, color: Colors.black.withValues(alpha: 0.8 * 255), ), ), const SizedBox(width: 3), buildTypeIndicator(topic.eventType), ], ), if (topic.lastEvent != null) Padding( padding: const EdgeInsets.only(right: 6.0), child: Text( _formatEventValue(topic.lastEvent), style: TextStyle( fontSize: 8, color: Colors.green.shade800, fontWeight: FontWeight.bold, ), ), ), ], ), ), ); }, ); } String _formatEventValue(dynamic value) { if (value == null) return "null"; if (value is bool) return value ? "T" : "F"; if (value is num) return value.toStringAsFixed(1); if (value is String) { return '"${value.length > 4 ? '${value.substring(0, 4)}...' : value}"'; } return value.toString(); } Widget _buildPropertyValueDisplay(Property property) { Component component = widget.component; bool canEdit = !property.isInput && component.inputConnections[property.index] == null; switch (property.type.type) { case PortType.BOOLEAN: return GestureDetector( onTap: canEdit ? () { widget.onValueChanged( widget.component.id, property.index, !(property.value as bool), ); } : null, child: Row( mainAxisSize: MainAxisSize.min, children: [ Container( width: 28, height: 14, decoration: BoxDecoration( borderRadius: BorderRadius.circular(7), color: property.value as bool ? Colors.green : Colors.red[300], border: Border.all(color: Colors.black45, width: 0.5), ), child: AnimatedAlign( duration: const Duration(milliseconds: 150), alignment: property.value as bool ? Alignment.centerRight : Alignment.centerLeft, child: Container( width: 14, height: 14, decoration: BoxDecoration( shape: BoxShape.circle, color: Colors.white, border: Border.all(color: Colors.black45, width: 0.5), ), ), ), ), const SizedBox(width: 3), Text( property.value as bool ? 'T' : 'F', style: TextStyle( fontSize: 8, fontWeight: FontWeight.bold, color: property.value as bool ? Colors.green[800] : Colors.red[800], ), ), ], ), ); case PortType.NUMERIC: return Padding( padding: const EdgeInsets.only(right: 6.0), child: Text( (property.value as num).toStringAsFixed(1), style: TextStyle( fontSize: 9, fontWeight: FontWeight.bold, color: Colors.teal[800], ), ), ); case PortType.STRING: return Container( width: 50, padding: const EdgeInsets.only(right: 6.0), child: Tooltip( message: property.value as String, child: Text( '"${(property.value as String).length > 4 ? '${(property.value as String).substring(0, 4)}...' : property.value as String}"', style: TextStyle( fontSize: 9, fontWeight: FontWeight.bold, color: Colors.orange[800], ), maxLines: 1, overflow: TextOverflow.ellipsis, textAlign: TextAlign.right, ), ), ); case PortType.ANY: if (property.value is bool) { return Text( property.value as bool ? 'true' : 'false', style: TextStyle( fontSize: 8, fontWeight: FontWeight.bold, color: Colors.purple[800], ), ); } else if (property.value is num) { return Text( (property.value as num).toStringAsFixed(1), style: TextStyle( fontSize: 8, fontWeight: FontWeight.bold, color: Colors.purple[800], ), ); } else if (property.value is String) { return Text( '"${(property.value as String).length > 6 ? '${(property.value as String).substring(0, 6)}...' : property.value as String}"', style: TextStyle( fontSize: 8, fontWeight: FontWeight.bold, color: Colors.purple[800], ), ); } else { return Text( "null", style: TextStyle( fontSize: 8, fontWeight: FontWeight.bold, color: Colors.purple[800], ), ); } } return const SizedBox(); } } 

// File: \lib\niagara\home\connection_painter.dart
import 'dart:math'; import 'package:flutter/material.dart'; import '../models/component.dart'; import '../models/connection.dart'; import '../models/port.dart'; import '../models/port_type.dart'; import 'component_widget.dart'; import 'manager.dart'; class ConnectionPainter extends CustomPainter { final FlowManager flowManager; final Map<String, Offset> componentPositions; final Map<String, GlobalKey> componentKeys; final Map<String, double> componentWidths; final SlotDragInfo? tempLineStartInfo; final Offset? tempLineEndPoint; static const double rowVerticalOffset = 28.0; static const double rowHeight = 36.0; static const double itemPadding = 8.0; ConnectionPainter({ required this.flowManager, required this.componentPositions, required this.componentKeys, required this.componentWidths, this.tempLineStartInfo, this.tempLineEndPoint, }); @override void paint(Canvas canvas, Size size) { final Paint propertyPaint = Paint() ..color = Colors.indigo ..strokeWidth = 2.0 ..style = PaintingStyle.stroke ..strokeCap = StrokeCap.round; final Paint actionPaint = Paint() ..color = Colors.amber.shade700 ..strokeWidth = 2.0 ..style = PaintingStyle.stroke ..strokeCap = StrokeCap.round; final Paint topicPaint = Paint() ..color = Colors.green.shade700 ..strokeWidth = 2.0 ..style = PaintingStyle.stroke ..strokeCap = StrokeCap.round; final Paint tempLinePaint = Paint() ..color = Colors.blue.withValues(alpha: 0.7 * 255) ..strokeWidth = 1.5 ..style = PaintingStyle.stroke ..strokeCap = StrokeCap.round; for (final connection in flowManager.connections) { _drawConnection( canvas, connection, propertyPaint, actionPaint, topicPaint, ); } if (tempLineStartInfo != null && tempLineEndPoint != null) { _drawTempLine( canvas, tempLineStartInfo!, tempLineEndPoint!, tempLinePaint, ); } } void _drawConnection( Canvas canvas, Connection connection, Paint propertyPaint, Paint actionPaint, Paint topicPaint, ) { final Component? fromComponent = flowManager.findComponentById( connection.fromComponentId, ); final Component? toComponent = flowManager.findComponentById( connection.toComponentId, ); if (fromComponent == null || toComponent == null) return; final Offset? fromPosition = componentPositions[connection.fromComponentId]; final Offset? toPosition = componentPositions[connection.toComponentId]; if (fromPosition == null || toPosition == null) return; Slot? fromSlot = fromComponent.getSlotByIndex(connection.fromPortIndex); Slot? toSlot = toComponent.getSlotByIndex(connection.toPortIndex); if (fromSlot == null || toSlot == null) return; Paint paint; if (fromSlot is Property && toSlot is Property) { paint = propertyPaint; } else if (fromSlot is Action || toSlot is Action) { paint = actionPaint; } else if (fromSlot is Topic || toSlot is Topic) { paint = topicPaint; } else { paint = propertyPaint; } bool isFromOutput = false; if (fromSlot is Property) { isFromOutput = !fromSlot.isInput; } else if (fromSlot is Action) { isFromOutput = false; } else if (fromSlot is Topic) { isFromOutput = true; } bool isToOutput = false; if (toSlot is Property) { isToOutput = !toSlot.isInput; } else if (toSlot is Action) { isToOutput = false; } else if (toSlot is Topic) { isToOutput = true; } int fromRowIndex = _calculateRowIndex( fromComponent, connection.fromPortIndex, ); int toRowIndex = _calculateRowIndex(toComponent, connection.toPortIndex); final fromSlotPos = _calculateSlotPosition( fromPosition, fromRowIndex, isFromOutput, fromComponent.id, ); final toSlotPos = _calculateSlotPosition( toPosition, toRowIndex, isToOutput, toComponent.id, ); _drawArrowLine(canvas, fromSlotPos, toSlotPos, paint); if (fromSlot is Property) { _drawTransferredValue(canvas, fromSlotPos, toSlotPos, fromSlot); } else if (fromSlot is Topic && fromSlot.lastEvent != null) { _drawTransferredTopicEvent(canvas, fromSlotPos, toSlotPos, fromSlot); } } int _calculateRowIndex(Component component, int slotIndex) { Slot? slot = component.getSlotByIndex(slotIndex); if (slot == null) return 0; int propertiesBeforeIndex = 0; for (var prop in component.properties) { if (prop.index == slotIndex) break; propertiesBeforeIndex++; } int actionsBeforeIndex = 0; for (var action in component.actions) { if (action.index == slotIndex) break; actionsBeforeIndex++; } int topicsBeforeIndex = 0; for (var topic in component.topics) { if (topic.index == slotIndex) break; topicsBeforeIndex++; } int rowIndex = 0; if (component.properties.isNotEmpty && component.properties.contains(slot)) { rowIndex = propertiesBeforeIndex; if (component.actions.isNotEmpty || component.topics.isNotEmpty) { rowIndex += 1; } } else if (component.actions.isNotEmpty && component.actions.contains(slot)) { rowIndex = component.properties.length + actionsBeforeIndex; if (component.properties.isNotEmpty) { rowIndex += 1; } if (component.topics.isNotEmpty) { rowIndex += 1; } } else if (component.topics.isNotEmpty && component.topics.contains(slot)) { rowIndex = component.properties.length + component.actions.length + topicsBeforeIndex; if (component.properties.isNotEmpty) { rowIndex += 1; } if (component.actions.isNotEmpty) { rowIndex += 1; } } return rowIndex; } void _drawTempLine( Canvas canvas, SlotDragInfo startInfo, Offset endPoint, Paint paint, ) { final Component? fromComponent = flowManager.findComponentById( startInfo.componentId, ); if (fromComponent == null) return; final Offset? fromPosition = componentPositions[startInfo.componentId]; if (fromPosition == null) return; Slot? fromSlot = fromComponent.getSlotByIndex(startInfo.slotIndex); if (fromSlot == null) return; bool isOutput = false; if (fromSlot is Property) { isOutput = !fromSlot.isInput; } else if (fromSlot is Topic) { isOutput = true; } int rowIndex = _calculateRowIndex(fromComponent, startInfo.slotIndex); final fromSlotPos = _calculateSlotPosition( fromPosition, rowIndex, isOutput, fromComponent.id, ); _drawDashedLine(canvas, fromSlotPos, endPoint, paint); } Offset _calculateSlotPosition( Offset itemPosition, int rowIndex, bool isRightSide, String componentId, ) { final double itemWidth = componentWidths[componentId] ?? 160.0; final double totalWidth = itemWidth + (itemPadding * 2); final double portX = isRightSide ? itemPosition.dx + totalWidth : itemPosition.dx; final double portY = itemPosition.dy + itemPadding + rowVerticalOffset + (rowIndex * rowHeight) + (rowHeight / 2); return Offset(portX, portY); } void _drawArrowLine(Canvas canvas, Offset start, Offset end, Paint paint) { canvas.drawLine(start, end, paint); const double arrowSize = 8.0; final double angle = atan2(end.dy - start.dy, end.dx - start.dx); final Path arrowPath = Path(); arrowPath.moveTo( end.dx - arrowSize * cos(angle - pi / 7), end.dy - arrowSize * sin(angle - pi / 7), ); arrowPath.lineTo(end.dx, end.dy); arrowPath.lineTo( end.dx - arrowSize * cos(angle + pi / 7), end.dy - arrowSize * sin(angle + pi / 7), ); canvas.drawPath(arrowPath, paint); } void _drawDashedLine(Canvas canvas, Offset start, Offset end, Paint paint) { const double dashWidth = 5; const double dashSpace = 3; final double dx = end.dx - start.dx; final double dy = end.dy - start.dy; final double distance = sqrt(dx * dx + dy * dy); final int dashCount = (distance / (dashWidth + dashSpace)).floor(); if (dashCount <= 0) return; final double stepX = dx / dashCount; final double stepY = dy / dashCount; final Paint backgroundPaint = Paint() ..color = Colors.white.withValues(alpha: 0.5 * 255) ..strokeWidth = paint.strokeWidth + 1.0 ..style = PaintingStyle.stroke ..strokeCap = paint.strokeCap; canvas.drawLine(start, end, backgroundPaint); for (int i = 0; i < dashCount; i++) { final double startX = start.dx + i * (stepX + stepX * dashSpace / dashWidth); final double startY = start.dy + i * (stepY + stepY * dashSpace / dashWidth); final double endX = startX + stepX; final double endY = startY + stepY; canvas.drawLine(Offset(startX, startY), Offset(endX, endY), paint); } } void _drawTransferredValue( Canvas canvas, Offset start, Offset end, Property property, ) { final Offset midpoint = Offset( (start.dx + end.dx) / 2, (start.dy + end.dy) / 2, ); final Paint backgroundPaint = Paint() ..color = Colors.white.withValues(alpha: .85 * 255) ..style = PaintingStyle.fill; Color? borderColor; String? displayValue; switch (property.type.type) { case PortType.BOOLEAN: borderColor = (property.value as bool) ? Colors.green.withValues(alpha: 0.6 * 255) : Colors.red.withValues(alpha: 0.6 * 255); displayValue = (property.value as bool) ? 'T' : 'F'; break; case PortType.NUMERIC: borderColor = Colors.teal.withValues(alpha: 0.6 * 255); num value = property.value as num; displayValue = value.toStringAsFixed(1); break; case PortType.STRING: borderColor = Colors.orange.withValues(alpha: 0.6 * 255); displayValue = '"${(property.value as String).length > 3 ? '${(property.value as String).substring(0, 3)}...' : property.value as String}"'; break; case PortType.ANY: borderColor = Colors.purple.withValues(alpha: 0.6 * 255); if (property.value == null) { displayValue = 'null'; } else if (property.value is bool) { displayValue = (property.value as bool) ? 'T' : 'F'; } else if (property.value is num) { displayValue = (property.value as num).toStringAsFixed(1); } else { displayValue = '${property.value}'; } break; } final Paint borderPaint = Paint() ..color = borderColor! ..style = PaintingStyle.stroke ..strokeWidth = 1.0; const double bubbleRadius = 14.0; canvas.drawCircle(midpoint, bubbleRadius, backgroundPaint); canvas.drawCircle(midpoint, bubbleRadius, borderPaint); final textSpan = TextSpan( text: displayValue, style: TextStyle( color: borderColor, fontSize: 10, fontWeight: FontWeight.bold, ), ); final textPainter = TextPainter( text: textSpan, textDirection: TextDirection.ltr, ); textPainter.layout(); textPainter.paint( canvas, Offset( midpoint.dx - textPainter.width / 2, midpoint.dy - textPainter.height / 2, ), ); } void _drawTransferredTopicEvent( Canvas canvas, Offset start, Offset end, Topic topic, ) { final Offset midpoint = Offset( (start.dx + end.dx) / 2, (start.dy + end.dy) / 2, ); final Paint backgroundPaint = Paint() ..color = Colors.white.withValues(alpha: .85 * 255) ..style = PaintingStyle.fill; Color borderColor = Colors.green.withValues(alpha: 0.6 * 255); String displayValue = _formatEventValue(topic.lastEvent); final Paint borderPaint = Paint() ..color = borderColor ..style = PaintingStyle.stroke ..strokeWidth = 1.0; const double bubbleSize = 20.0; final Rect bubbleRect = Rect.fromCenter( center: midpoint, width: bubbleSize, height: bubbleSize, ); canvas.drawRect(bubbleRect, backgroundPaint); canvas.drawRect(bubbleRect, borderPaint); final textSpan = TextSpan( text: displayValue, style: TextStyle( color: borderColor, fontSize: 10, fontWeight: FontWeight.bold, ), ); final textPainter = TextPainter( text: textSpan, textDirection: TextDirection.ltr, ); textPainter.layout(); textPainter.paint( canvas, Offset( midpoint.dx - textPainter.width / 2, midpoint.dy - textPainter.height / 2, ), ); } String _formatEventValue(dynamic value) { if (value == null) return "null"; if (value is bool) return value ? "T" : "F"; if (value is num) return value.toStringAsFixed(1); if (value is String) { return '"${value.length > 3 ? '${value.substring(0, 3)}...' : value}"'; } return value.toString(); } @override bool shouldRepaint(covariant ConnectionPainter oldDelegate) { return true;  } } 

// File: \lib\niagara\home\grid_painter.dart
import 'package:flutter/material.dart'; class GridPainter extends CustomPainter { @override void paint(Canvas canvas, Size size) { final paint = Paint() ..color = Colors.grey[300]! ..strokeWidth = 0.5; for (double i = 0; i < size.width; i += 20) { canvas.drawLine(Offset(i, 0), Offset(i, size.height), paint); } for (double i = 0; i < size.height; i += 20) { canvas.drawLine(Offset(0, i), Offset(size.width, i), paint); } } @override bool shouldRepaint(covariant CustomPainter oldDelegate) => false; } 

// File: \lib\niagara\home\handlers.dart
import 'package:flutter/material.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; import '../models/command_history.dart'; import '../models/component.dart'; import '../models/connection.dart'; import '../models/port.dart'; import '../models/port_type.dart'; import 'manager.dart'; import 'command.dart'; import 'resize_component_command.dart'; class FlowHandlers { final FlowManager flowManager; final CommandHistory commandHistory; final Map<String, Offset> componentPositions; final Map<String, GlobalKey> componentKeys; final Map<String, double> componentWidths; final Function(void Function()) setState; final Function() updateCanvasSize; final Set<Component> selectedComponents; final List<Component> clipboardComponents; final List<Offset> clipboardPositions; final List<Connection> clipboardConnections; final Function(Offset) setClipboardComponentPosition; FlowHandlers({ required this.flowManager, required this.commandHistory, required this.componentPositions, required this.componentKeys, required this.componentWidths, required this.setState, required this.updateCanvasSize, required this.selectedComponents, required this.clipboardComponents, required this.clipboardPositions, required this.clipboardConnections, required this.setClipboardComponentPosition, }); void handleWidthChanged(String componentId, double newWidth) { setState(() { componentWidths[componentId] = newWidth; }); } void handleComponentResize(String componentId, double newWidth) { final oldWidth = componentWidths[componentId] ?? 160.0; setState(() { final command = ResizeComponentCommand( componentId, newWidth, oldWidth, componentWidths, ); commandHistory.execute(command); }); } void handleValueChanged(String componentId, int slotIndex, dynamic newValue) { Component? component = flowManager.findComponentById(componentId); if (component != null) { Slot? slot = component.getSlotByIndex(slotIndex); if (slot != null) { dynamic oldValue; if (slot is Property) { oldValue = slot.value; } else if (slot is ActionSlot) { oldValue = slot.parameter; } if (oldValue != newValue) { setState(() { final command = UpdatePortValueCommand( flowManager, componentId, slotIndex, newValue, oldValue, ); commandHistory.execute(command); }); } } } } void handleDeleteComponent(Component component) { final affectedConnections = flowManager.connections .where( (connection) => connection.fromComponentId == component.id || connection.toComponentId == component.id, ) .toList(); setState(() { final oldPosition = componentPositions[component.id] ?? Offset.zero; final oldKey = componentKeys[component.id]; final command = RemoveComponentCommand( flowManager, component, oldPosition, oldKey, affectedConnections, ); commandHistory.execute(command); updateCanvasSize(); }); } void handleEditComponent(BuildContext context, Component component) { TextEditingController nameController = TextEditingController( text: component.id, ); Map<int, TextEditingController> propertyControllers = {}; List<Property> editableProperties = component.properties .where( (prop) => !prop.isInput && !component.inputConnections.containsKey(prop.index), ) .toList(); for (var property in editableProperties) { if (property.type.type != PortType.BOOLEAN) { String valueText = property.value?.toString() ?? ''; propertyControllers[property.index] = TextEditingController( text: valueText, ); } } showDialog( context: context, builder: (context) => StatefulBuilder( builder: (context, setDialogState) { return AlertDialog( title: const Text('Edit Component'), content: SingleChildScrollView( child: Column( mainAxisSize: MainAxisSize.min, crossAxisAlignment: CrossAxisAlignment.start, children: [ TextField( controller: nameController, decoration: const InputDecoration( labelText: 'Component Name', ), autofocus: true, ), const SizedBox(height: 16), if (editableProperties.isNotEmpty) ...[ const Text( 'Properties', style: TextStyle(fontWeight: FontWeight.bold), ), const SizedBox(height: 8), ...editableProperties.map((property) { if (property.type.type == PortType.BOOLEAN) { return const SizedBox.shrink(); } return Padding( padding: const EdgeInsets.only(bottom: 8.0), child: TextField( controller: propertyControllers[property.index], decoration: InputDecoration( labelText: '${property.name} Value', helperText: 'Type: ${property.type.type}', ), keyboardType: property.type.type == PortType.NUMERIC ? TextInputType.number : TextInputType.text, ), ); }), ], ], ), ), actions: [ cancelAction(context), TextButton( onPressed: () { String newName = nameController.text.trim(); if (newName.isNotEmpty && newName != component.id) { component.id = newName; } for (var property in editableProperties) { if (property.type.type != PortType.BOOLEAN && propertyControllers.containsKey(property.index)) { String newValueText = propertyControllers[property.index]!.text; dynamic newValue; if (property.type.type == PortType.NUMERIC) { newValue = num.tryParse(newValueText) ?? property.value; } else if (property.type.type == PortType.STRING) { newValue = newValueText; } else if (property.type.type == PortType.ANY) { newValue = num.tryParse(newValueText); newValue ??= newValueText; } if (newValue != property.value) { handleValueChanged( component.id, property.index, newValue, ); } } } Navigator.pop(context); setState(() {}); }, child: const Text('Save'), ), ], ); }, ), ); } void handleCopyMultipleComponents() { if (selectedComponents.isEmpty) return; clipboardComponents.clear(); clipboardPositions.clear(); clipboardConnections.clear(); Map<String, int> componentIndexMap = {}; for (int i = 0; i < selectedComponents.length; i++) { var component = selectedComponents.elementAt(i); clipboardComponents.add(component); clipboardPositions.add(componentPositions[component.id] ?? Offset.zero); componentIndexMap[component.id] = i; } for (var connection in flowManager.connections) { bool fromSelected = componentIndexMap.containsKey( connection.fromComponentId, ); bool toSelected = componentIndexMap.containsKey(connection.toComponentId); if (fromSelected && toSelected) { clipboardConnections.add(connection); } } if (clipboardComponents.isNotEmpty) { setClipboardComponentPosition(clipboardPositions.first); } } void handlePasteComponent(Offset position) { if (clipboardComponents.isEmpty) return; Map<String, String> idMap = {}; for (int i = 0; i < clipboardComponents.length; i++) { var originalComponent = clipboardComponents[i]; var originalPosition = clipboardPositions[i]; Offset relativeToPastePoint = originalPosition - clipboardPositions[0]; Offset newPosition = position + relativeToPastePoint; String newName = '${originalComponent.id} (Copy)'; int counter = 1; while (flowManager.components.any((comp) => comp.id == newName)) { counter++; newName = '${originalComponent.id} (Copy $counter)'; } Component newComponent = flowManager.createComponentByType( newName, originalComponent.type.type, ); for (var sourceProperty in originalComponent.properties) { if (!originalComponent.inputConnections.containsKey( sourceProperty.index, )) { for (var targetProperty in newComponent.properties) { if (targetProperty.index == sourceProperty.index) { targetProperty.value = sourceProperty.value; break; } } } } final newKey = GlobalKey(); Map<String, dynamic> state = { 'position': newPosition, 'key': newKey, 'positions': componentPositions, 'keys': componentKeys, }; idMap[originalComponent.id] = newComponent.id; final command = AddComponentCommand(flowManager, newComponent, state); commandHistory.execute(command); componentPositions[newComponent.id] = newPosition; componentKeys[newComponent.id] = newKey; } for (var connection in clipboardConnections) { String? newFromId = idMap[connection.fromComponentId]; String? newToId = idMap[connection.toComponentId]; if (newFromId != null && newToId != null) { final command = CreateConnectionCommand( flowManager, newFromId, connection.fromPortIndex, newToId, connection.toPortIndex, ); commandHistory.execute(command); } } setState(() { updateCanvasSize(); }); } void handlePasteSpecialComponent( Offset position, int numberOfCopies, bool keepAllLinks, ) { if (clipboardComponents.isEmpty) return; const double offsetX = 50.0; const double offsetY = 50.0; for (int copyIndex = 0; copyIndex < numberOfCopies; copyIndex++) { final double baseOffsetX = copyIndex * offsetX; final double baseOffsetY = copyIndex * offsetY; Map<String, String> idMap = {}; for (int i = 0; i < clipboardComponents.length; i++) { var originalComponent = clipboardComponents[i]; var originalPosition = clipboardPositions[i]; Offset relativeToPastePoint = originalPosition - clipboardPositions[0]; Offset newPosition = Offset( position.dx + baseOffsetX + relativeToPastePoint.dx, position.dy + baseOffsetY + relativeToPastePoint.dy, ); String newName = '${originalComponent.id} (Copy)'; int counter = 1; while (flowManager.components.any((comp) => comp.id == newName)) { counter++; newName = '${originalComponent.id} (Copy $counter)'; } Component newComponent = flowManager.createComponentByType( newName, originalComponent.type.type, ); for (var sourceProperty in originalComponent.properties) { if (!originalComponent.inputConnections.containsKey( sourceProperty.index, ) || !keepAllLinks) { for (var targetProperty in newComponent.properties) { if (targetProperty.index == sourceProperty.index) { targetProperty.value = sourceProperty.value; break; } } } } final newKey = GlobalKey(); Map<String, dynamic> state = { 'position': newPosition, 'key': newKey, 'positions': componentPositions, 'keys': componentKeys, }; idMap[originalComponent.id] = newComponent.id; final command = AddComponentCommand(flowManager, newComponent, state); commandHistory.execute(command); componentPositions[newComponent.id] = newPosition; componentKeys[newComponent.id] = newKey; } if (keepAllLinks) { for (var connection in clipboardConnections) { String? newFromId = idMap[connection.fromComponentId]; String? newToId = idMap[connection.toComponentId]; if (newFromId != null && newToId != null) { final command = CreateConnectionCommand( flowManager, newFromId, connection.fromPortIndex, newToId, connection.toPortIndex, ); commandHistory.execute(command); } } } } setState(() { updateCanvasSize(); }); } void handleMoveComponentDown(Component component) { Offset? canvasPosition = componentPositions[component.id]; if (canvasPosition != null) { canvasPosition = Offset(canvasPosition.dx, canvasPosition.dy + 20); setState(() { final command = MoveComponentCommand( component.id, canvasPosition!, componentPositions[component.id]!, componentPositions, ); commandHistory.execute(command); updateCanvasSize(); }); } } void handleMoveComponentUp(Component component) { Offset? canvasPosition = componentPositions[component.id]; if (canvasPosition != null) { canvasPosition = Offset(canvasPosition.dx, canvasPosition.dy - 20); setState(() { final command = MoveComponentCommand( component.id, canvasPosition!, componentPositions[component.id]!, componentPositions, ); commandHistory.execute(command); updateCanvasSize(); }); } } void handleMoveComponentLeft(Component component) { Offset? canvasPosition = componentPositions[component.id]; if (canvasPosition != null) { canvasPosition = Offset(canvasPosition.dx - 20, canvasPosition.dy); setState(() { final command = MoveComponentCommand( component.id, canvasPosition!, componentPositions[component.id]!, componentPositions, ); commandHistory.execute(command); updateCanvasSize(); }); } } void handleMoveComponentRight(Component component) { Offset? canvasPosition = componentPositions[component.id]; if (canvasPosition != null) { canvasPosition = Offset(canvasPosition.dx + 20, canvasPosition.dy); setState(() { final command = MoveComponentCommand( component.id, canvasPosition!, componentPositions[component.id]!, componentPositions, ); commandHistory.execute(command); updateCanvasSize(); }); } } } 

// File: \lib\niagara\home\intents.dart
import 'package:flutter/material.dart'; import 'package:flutter/services.dart'; class UndoIntent extends Intent { const UndoIntent(); } class RedoIntent extends Intent { const RedoIntent(); } class CopyIntent extends Intent { const CopyIntent(); } class PasteIntent extends Intent { const PasteIntent(); } class DeleteIntent extends Intent { const DeleteIntent(); } class MoveUpIntent extends Intent { const MoveUpIntent(); } class MoveDownIntent extends Intent { const MoveDownIntent(); } class MoveLeftIntent extends Intent { const MoveLeftIntent(); } class MoveRightIntent extends Intent { const MoveRightIntent(); } class SelectAllIntent extends Intent { const SelectAllIntent(); } Map<LogicalKeySet, Intent> getShortcuts() { return <LogicalKeySet, Intent>{ LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyZ): const UndoIntent(), LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyY): const RedoIntent(), LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyC): const CopyIntent(), LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyV): const PasteIntent(), LogicalKeySet(LogicalKeyboardKey.delete): const DeleteIntent(), LogicalKeySet(LogicalKeyboardKey.arrowDown): const MoveDownIntent(), LogicalKeySet(LogicalKeyboardKey.arrowLeft): const MoveLeftIntent(), LogicalKeySet(LogicalKeyboardKey.arrowRight): const MoveRightIntent(), LogicalKeySet(LogicalKeyboardKey.arrowUp): const MoveUpIntent(), LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyA): const SelectAllIntent(), }; } 

// File: \lib\niagara\home\manager.dart
import '../models/component.dart'; import '../models/connection.dart'; import '../models/component_type.dart'; import '../models/helvar_device_component.dart'; import '../models/logic_components.dart'; import '../models/math_components.dart'; import '../models/point_components.dart'; import '../models/port_type.dart'; import '../models/port.dart'; import '../models/rectangle.dart'; class FlowManager { List<Component> components = []; List<Connection> connections = []; void addComponent(Component component) { components.add(component); } void removeComponent(String componentId) { components.removeWhere((component) => component.id == componentId); connections.removeWhere( (connection) => connection.fromComponentId == componentId || connection.toComponentId == componentId, ); recalculateAll(); } Component? findComponentById(String id) { try { return components.firstWhere((component) => component.id == id); } catch (e) { return null; } } bool canCreateConnection( String fromComponentId, int fromPortIndex, String toComponentId, int toPortIndex, ) { Component? fromComponent = findComponentById(fromComponentId); Component? toComponent = findComponentById(toComponentId); if (fromComponent == null || toComponent == null) return false; Slot? fromSlot = fromComponent.getSlotByIndex(fromPortIndex); Slot? toSlot = toComponent.getSlotByIndex(toPortIndex); if (fromSlot == null || toSlot == null) return false; if (fromSlot is Property && toSlot is Property) { if (fromSlot.isInput || !toSlot.isInput) return false; return fromSlot.canConnectTo(toSlot); } else if (fromSlot is Property && toSlot is ActionSlot) { if (fromSlot.isInput) return false; return toSlot.parameterType == null || toSlot.parameterType!.type == PortType.ANY || fromSlot.type.type == toSlot.parameterType!.type; } else if (fromSlot is ActionSlot && toSlot is ActionSlot) { return true; } else if (fromSlot is ActionSlot && toSlot is Topic) { return fromSlot.returnType == null || fromSlot.returnType!.type == PortType.ANY || toSlot.eventType.type == fromSlot.returnType!.type; } else if (fromSlot is Topic && toSlot is ActionSlot) { return toSlot.parameterType == null || toSlot.parameterType!.type == PortType.ANY || fromSlot.eventType.type == toSlot.parameterType!.type; } else if (fromSlot is Topic && toSlot is Topic) { return toSlot.eventType.type == PortType.ANY || fromSlot.eventType.type == PortType.ANY || toSlot.eventType.type == fromSlot.eventType.type; } return false; } void createConnection( String fromComponentId, int fromPortIndex, String toComponentId, int toPortIndex, ) { if (!canCreateConnection( fromComponentId, fromPortIndex, toComponentId, toPortIndex, )) { return; } bool connectionExists = connections.any( (connection) => connection.fromComponentId == fromComponentId && connection.fromPortIndex == fromPortIndex && connection.toComponentId == toComponentId && connection.toPortIndex == toPortIndex, ); if (!connectionExists) { Component? fromComponent = findComponentById(fromComponentId); Component? toComponent = findComponentById(toComponentId); if (fromComponent != null && toComponent != null) { connections.add( Connection( fromComponentId: fromComponentId, fromPortIndex: fromPortIndex, toComponentId: toComponentId, toPortIndex: toPortIndex, ), ); toComponent.addInputConnection( toPortIndex, ConnectionEndpoint( componentId: fromComponentId, portIndex: fromPortIndex, ), ); Slot? fromSlot = fromComponent.getSlotByIndex(fromPortIndex); Slot? toSlot = toComponent.getSlotByIndex(toPortIndex); if (fromSlot is Property && toSlot is Property) { propagatePropertyValue(fromComponent, fromPortIndex); } } } } void removeConnection( String fromComponentId, int fromPortIndex, String toComponentId, int toPortIndex, ) { connections.removeWhere( (connection) => connection.fromComponentId == fromComponentId && connection.fromPortIndex == fromPortIndex && connection.toComponentId == toComponentId && connection.toPortIndex == toPortIndex, ); Component? toComponent = findComponentById(toComponentId); if (toComponent != null) { toComponent.removeInputConnection(toPortIndex); } recalculateAll(); } void updatePortValue(String componentId, int portIndex, dynamic value) { Component? component = findComponentById(componentId); if (component == null) return; Slot? slot = component.getSlotByIndex(portIndex); if (slot == null) return; if (slot is Property) { slot.value = value; if (slot.isInput) { component.calculate(); for (var property in component.properties.where((p) => !p.isInput)) { propagatePropertyValue(component, property.index); } for (var topic in component.topics) { propagateTopicEvent(component, topic.index); } } else { propagatePropertyValue(component, portIndex); } } else if (slot is ActionSlot) { slot.parameter = value; dynamic result = slot.execute(parameter: value); if (slot.returnType != null && result != null) { for (var connection in connections.where( (connection) => connection.isFromComponent(componentId, portIndex), )) { Component? targetComponent = findComponentById( connection.toComponentId, ); if (targetComponent != null) { Slot? targetSlot = targetComponent.getSlotByIndex( connection.toPortIndex, ); if (targetSlot is ActionSlot) { updatePortValue( connection.toComponentId, connection.toPortIndex, result, ); } else if (targetSlot is Topic) { targetSlot.fire(result); propagateTopicEvent(targetComponent, connection.toPortIndex); } } } } } } void propagatePropertyValue( Component sourceComponent, int sourcePropertyIndex, ) { Property? sourceProperty = sourceComponent.getPropertyByIndex( sourcePropertyIndex, ); if (sourceProperty == null || sourceProperty.isInput) return; dynamic valueToPropagate = sourceProperty.value; List<Connection> outgoingConnections = connections .where( (connection) => connection.isFromComponent( sourceComponent.id, sourcePropertyIndex, ), ) .toList(); for (var connection in outgoingConnections) { Component? targetComponent = findComponentById(connection.toComponentId); if (targetComponent == null) continue; Slot? targetSlot = targetComponent.getSlotByIndex(connection.toPortIndex); if (targetSlot == null) continue; if (targetSlot is Property) { targetSlot.value = valueToPropagate; targetComponent.calculate(); for (var property in targetComponent.properties.where( (p) => !p.isInput, )) { propagatePropertyValue(targetComponent, property.index); } for (var topic in targetComponent.topics) { propagateTopicEvent(targetComponent, topic.index); } } else if (targetSlot is ActionSlot) { dynamic result = targetSlot.execute(parameter: valueToPropagate); if (result != null) { for (var actionConnection in connections.where( (conn) => conn.isFromComponent( targetComponent.id, connection.toPortIndex, ), )) { Component? actionTargetComponent = findComponentById( actionConnection.toComponentId, ); if (actionTargetComponent == null) continue; Slot? actionTargetSlot = actionTargetComponent.getSlotByIndex( actionConnection.toPortIndex, ); if (actionTargetSlot is ActionSlot) { actionTargetSlot.execute(parameter: result); } else if (actionTargetSlot is Topic) { actionTargetSlot.fire(result); propagateTopicEvent( actionTargetComponent, actionConnection.toPortIndex, ); } } } } } } void propagateTopicEvent(Component sourceComponent, int sourceTopicIndex) { Topic? sourceTopic = sourceComponent.getTopicByIndex(sourceTopicIndex); if (sourceTopic == null) return; dynamic eventToPropagate = sourceTopic.lastEvent; if (eventToPropagate == null) return; List<Connection> outgoingConnections = connections .where( (connection) => connection.isFromComponent(sourceComponent.id, sourceTopicIndex), ) .toList(); for (var connection in outgoingConnections) { Component? targetComponent = findComponentById(connection.toComponentId); if (targetComponent == null) continue; Slot? targetSlot = targetComponent.getSlotByIndex(connection.toPortIndex); if (targetSlot == null) continue; if (targetSlot is ActionSlot) { dynamic result = targetSlot.execute(parameter: eventToPropagate); if (result != null) { for (var actionConnection in connections.where( (conn) => conn.isFromComponent( targetComponent.id, connection.toPortIndex, ), )) { Component? actionTargetComponent = findComponentById( actionConnection.toComponentId, ); if (actionTargetComponent == null) continue; Slot? actionTargetSlot = actionTargetComponent.getSlotByIndex( actionConnection.toPortIndex, ); if (actionTargetSlot is ActionSlot) { actionTargetSlot.execute(parameter: result); } else if (actionTargetSlot is Topic) { actionTargetSlot.fire(result); propagateTopicEvent( actionTargetComponent, actionConnection.toPortIndex, ); } } } } else if (targetSlot is Topic) { (targetSlot).fire(eventToPropagate); propagateTopicEvent(targetComponent, connection.toPortIndex); } } } void recalculateAll() { for (var component in components) { for (var entry in component.inputConnections.entries) { int slotIndex = entry.key; Slot? slot = component.getSlotByIndex(slotIndex); if (slot is Property && slot.isInput) { if (slot.type.type == PortType.BOOLEAN) { slot.value = false; } else if (slot.type.type == PortType.NUMERIC) { slot.value = 0.0; } else if (slot.type.type == PortType.STRING) { slot.value = ''; } else if (slot.type.type == PortType.ANY) { slot.value = null; } } } } for (var component in components) { if (component.type.isPoint) { component.calculate(); } } for (var component in components) { if (component.type.isPoint) { for (var property in component.properties.where((p) => !p.isInput)) { propagatePropertyValue(component, property.index); } } } for (var component in components) { if (!component.type.isPoint) { component.calculate(); for (var property in component.properties.where((p) => !p.isInput)) { propagatePropertyValue(component, property.index); } for (var topic in component.topics) { propagateTopicEvent(component, topic.index); } } } } Component createComponentByType(String id, String typeStr) { final type = ComponentType(typeStr); if (typeStr == RectangleComponent.RECTANGLE) { return RectangleComponent(id: id); } else if (type.isLogicGate) { return LogicComponent(id: id, type: type); } else if (type.isMathOperation) { return MathComponent(id: id, type: type); } else if (type.isPoint) { return PointComponent(id: id, type: type); } else if (typeStr == ComponentType.HELVAR_DEVICE || typeStr == ComponentType.HELVAR_INPUT || typeStr == ComponentType.HELVAR_OUTPUT || typeStr == ComponentType.HELVAR_EMERGENCY) { String deviceType = "unknown"; if (typeStr == ComponentType.HELVAR_INPUT) { deviceType = "input"; } else if (typeStr == ComponentType.HELVAR_OUTPUT) { deviceType = "output"; } else if (typeStr == ComponentType.HELVAR_EMERGENCY) { deviceType = "emergency"; } return HelvarDeviceComponent( id: id, deviceId: 0,  deviceAddress: "",  deviceType: deviceType, description: id, type: type, ); } return PointComponent( id: id, type: const ComponentType(ComponentType.BOOLEAN_WRITABLE), ); } } 

// File: \lib\niagara\home\paste_special_dialog.dart
import 'package:flutter/material.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; class PasteSpecialDialog extends StatefulWidget { final Function(int, bool, bool) onPasteConfirmed; const PasteSpecialDialog({super.key, required this.onPasteConfirmed}); @override State<PasteSpecialDialog> createState() => _PasteSpecialDialogState(); } class _PasteSpecialDialogState extends State<PasteSpecialDialog> { int numberOfCopies = 1; bool keepAllLinks = true; bool keepAllRelations = false; @override Widget build(BuildContext context) { return AlertDialog( title: const Row( children: [ Icon(Icons.copy, size: 20), SizedBox(width: 8), Text('Paste Special'), ], ), content: Column( mainAxisSize: MainAxisSize.min, crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( children: [ const Text('Number of copies'), const SizedBox(width: 12), SizedBox( width: 50, child: TextField( textAlign: TextAlign.center, keyboardType: TextInputType.number, decoration: const InputDecoration( contentPadding: EdgeInsets.symmetric( horizontal: 6, vertical: 0, ), border: OutlineInputBorder(), ), controller: TextEditingController( text: numberOfCopies.toString(), ), onChanged: (value) { int? parsedValue = int.tryParse(value); if (parsedValue != null && parsedValue > 0) { setState(() { numberOfCopies = parsedValue; }); } }, ), ), ], ), const SizedBox(height: 16), Row( children: [ Checkbox( value: keepAllLinks, onChanged: (value) { setState(() { keepAllLinks = value ?? true; }); }, ), const Text('Keep all links'), ], ), ], ), actions: [ cancelAction(context), TextButton( onPressed: () { widget.onPasteConfirmed( numberOfCopies, keepAllLinks, keepAllRelations, ); Navigator.of(context).pop(); }, child: const Text('OK'), ), ], ); } } 

// File: \lib\niagara\home\resize_component_command.dart
import '../models/command.dart'; class ResizeComponentCommand extends Command { final String componentId; final double newWidth; final double oldWidth; final Map<String, double> componentWidths; ResizeComponentCommand( this.componentId, this.newWidth, this.oldWidth, this.componentWidths, ); @override void execute() { componentWidths[componentId] = newWidth; } @override void undo() { componentWidths[componentId] = oldWidth; } @override String get description => 'Resize $componentId'; } 

// File: \lib\niagara\home\selection_box_painter.dart
import 'package:flutter/material.dart'; class SelectionBoxPainter extends CustomPainter { final Offset? start; final Offset? end; SelectionBoxPainter({this.start, this.end}); @override void paint(Canvas canvas, Size size) { if (start == null || end == null) return; final paint = Paint() ..color = Colors.blue.withValues(alpha: 0.2 * 255) ..style = PaintingStyle.fill; final borderPaint = Paint() ..color = Colors.blue ..style = PaintingStyle.stroke ..strokeWidth = 1.0; final rect = Rect.fromPoints(start!, end!); canvas.drawRect(rect, paint); canvas.drawRect(rect, borderPaint); } @override bool shouldRepaint(SelectionBoxPainter oldDelegate) { return oldDelegate.start != start || oldDelegate.end != end; } } 

// File: \lib\niagara\models\command.dart
abstract class Command { void execute(); void undo(); void redo() { execute(); } String get description; } 

// File: \lib\niagara\models\command_history.dart
import 'command.dart'; class CommandHistory { final List<Command> _undoStack = []; final List<Command> _redoStack = []; final int _maxHistorySize; CommandHistory({int maxHistorySize = 100}) : _maxHistorySize = maxHistorySize; bool get canUndo => _undoStack.isNotEmpty; bool get canRedo => _redoStack.isNotEmpty; void execute(Command command) { command.execute(); _undoStack.add(command); _redoStack.clear(); if (_undoStack.length > _maxHistorySize) { _undoStack.removeAt(0); } } void undo() { if (canUndo) { final command = _undoStack.removeLast(); command.undo(); _redoStack.add(command); } } void redo() { if (canRedo) { final command = _redoStack.removeLast(); command.redo(); _undoStack.add(command); } } void clear() { _undoStack.clear(); _redoStack.clear(); } String? get lastUndoDescription => canUndo ? _undoStack.last.description : null; String? get lastRedoDescription => canRedo ? _redoStack.last.description : null; } 

// File: \lib\niagara\models\component.dart
import 'package:grms_designer/niagara/home/component_mixin.dart'; import 'port.dart'; import 'connection.dart'; import 'component_type.dart'; abstract class Component with ComponentMixin { String id; final ComponentType type; @override final List<Property> properties; @override final List<ActionSlot> actions; @override final List<Topic> topics; Map<int, ConnectionEndpoint> inputConnections = {}; Component({ required this.id, required this.type, List<Property>? properties, List<ActionSlot>? actions, List<Topic>? topics, }) : properties = properties ?? [], actions = actions ?? [], topics = topics ?? []; List<Slot> get allSlots { List<Slot> slots = []; slots.addAll(properties); slots.addAll(actions); slots.addAll(topics); return slots; } void addInputConnection(int slotIndex, ConnectionEndpoint endpoint) { inputConnections[slotIndex] = endpoint; } void removeInputConnection(int slotIndex) { inputConnections.remove(slotIndex); } void calculate(); } 

// File: \lib\niagara\models\component_type.dart
class ComponentType { static const String AND_GATE = "AND_GATE"; static const String OR_GATE = "OR_GATE"; static const String XOR_GATE = "XOR_GATE"; static const String NOT_GATE = "NOT_GATE"; static const String IS_GREATER_THAN = "IS_GREATER_THAN"; static const String IS_LESS_THAN = "IS_LESS_THAN"; static const String IS_EQUAL = "IS_EQUAL"; static const String ADD = "ADD"; static const String SUBTRACT = "SUBTRACT"; static const String MULTIPLY = "MULTIPLY"; static const String DIVIDE = "DIVIDE"; static const String MAX = "MAX"; static const String MIN = "MIN"; static const String POWER = "POWER"; static const String ABS = "ABS"; static const String BOOLEAN_WRITABLE = "BOOLEAN_WRITABLE"; static const String NUMERIC_WRITABLE = "NUMERIC_WRITABLE"; static const String STRING_WRITABLE = "STRING_WRITABLE"; static const String BOOLEAN_POINT = "BOOLEAN_POINT"; static const String NUMERIC_POINT = "NUMERIC_POINT"; static const String STRING_POINT = "STRING_POINT"; static const String HELVAR_DEVICE = "HELVAR_DEVICE"; static const String HELVAR_OUTPUT = "HELVAR_OUTPUT"; static const String HELVAR_INPUT = "HELVAR_INPUT"; static const String HELVAR_EMERGENCY = "HELVAR_EMERGENCY"; final String type; const ComponentType(this.type); @override bool operator ==(Object other) => identical(this, other) || other is ComponentType && other.type == type; @override int get hashCode => type.hashCode; bool get isLogicGate => type == AND_GATE || type == OR_GATE || type == NOT_GATE || type == AND_GATE || type == IS_EQUAL || type == IS_LESS_THAN || type == IS_GREATER_THAN; bool get isMathOperation => type == ADD || type == SUBTRACT || type == MULTIPLY || type == DIVIDE || type == MAX || type == MIN || type == POWER || type == ABS; bool get isWritablePoint => type == BOOLEAN_WRITABLE || type == NUMERIC_WRITABLE || type == STRING_WRITABLE; bool get isReadOnlyPoint => type == BOOLEAN_POINT || type == NUMERIC_POINT || type == STRING_POINT; bool get isPoint => isWritablePoint || isReadOnlyPoint; bool get isBooleanType => type == BOOLEAN_WRITABLE || type == BOOLEAN_POINT || type == AND_GATE || type == OR_GATE || type == XOR_GATE || type == NOT_GATE || type == IS_GREATER_THAN || type == IS_LESS_THAN || type == IS_EQUAL; bool get isNumericType => type == NUMERIC_WRITABLE || type == NUMERIC_POINT || isMathOperation; bool get isStringType => type == STRING_WRITABLE || type == STRING_POINT; static ComponentType fromString(String type) { return ComponentType(type); } } 

// File: \lib\niagara\models\connection.dart
class Connection { String fromComponentId; int fromPortIndex; String toComponentId; int toPortIndex; Connection({ required this.fromComponentId, required this.fromPortIndex, required this.toComponentId, required this.toPortIndex, }); bool isFromComponent(String componentId, int portIndex) { return fromComponentId == componentId && fromPortIndex == portIndex; } bool isToComponent(String componentId, int portIndex) { return toComponentId == componentId && toPortIndex == portIndex; } } class ConnectionEndpoint { String componentId; int portIndex; ConnectionEndpoint({required this.componentId, required this.portIndex}); } 

// File: \lib\niagara\models\helvar_device_component.dart
import '../models/component.dart'; import '../models/component_type.dart'; import '../models/port.dart'; import '../models/port_type.dart'; class HelvarDeviceComponent extends Component { final int deviceId; final String deviceAddress; final String deviceType; final String description; HelvarDeviceComponent({ required super.id, required this.deviceId, required this.deviceAddress, required this.deviceType, required this.description, ComponentType? type, }) : super(type: type ?? const ComponentType(ComponentType.HELVAR_DEVICE)) { _setupPorts(); } void _setupPorts() { properties.add( Property.withDefaultValue( name: "Status", index: 0, isInput: false, type: const PortType(PortType.STRING), ), ); switch (deviceType) { case 'output': _setupOutputDevicePorts(); break; case 'input': _setupInputDevicePorts(); break; case 'emergency': _setupEmergencyDevicePorts(); break; } } void _setupOutputDevicePorts() { actions.add( ActionSlot( name: "Clear Result", index: 1, parameterType: const PortType(PortType.BOOLEAN), ), ); actions.add( ActionSlot( name: "Recall Scene", index: 2, parameterType: const PortType(PortType.NUMERIC), ), ); actions.add( ActionSlot( name: "Direct Level", index: 3, parameterType: const PortType(PortType.NUMERIC), ), ); actions.add( ActionSlot( name: "Direct Proportion", index: 4, parameterType: const PortType(PortType.NUMERIC), ), ); actions.add( ActionSlot( name: "Modify Proportion", index: 5, parameterType: const PortType(PortType.NUMERIC), ), ); } void _setupInputDevicePorts() { actions.add( ActionSlot( name: "Clear Result", index: 1, parameterType: const PortType(PortType.BOOLEAN), ), ); for (int i = 1; i <= 5; i++) { topics.add( Topic( name: "Button $i", index: i + 5, eventType: const PortType(PortType.BOOLEAN), ), ); } topics.add( Topic( name: "Presence", index: 11, eventType: const PortType(PortType.BOOLEAN), ), ); } void _setupEmergencyDevicePorts() { actions.add( ActionSlot( name: "Clear Result", index: 1, parameterType: const PortType(PortType.BOOLEAN), ), ); actions.add( ActionSlot( name: "Emergency Function Test", index: 2, parameterType: const PortType(PortType.BOOLEAN), ), ); actions.add( ActionSlot( name: "Emergency Duration Test", index: 3, parameterType: const PortType(PortType.BOOLEAN), ), ); actions.add( ActionSlot( name: "Stop Emergency Test", index: 4, parameterType: const PortType(PortType.BOOLEAN), ), ); actions.add( ActionSlot( name: "Reset Emergency Battery", index: 5, parameterType: const PortType(PortType.BOOLEAN), ), ); topics.add( Topic( name: "Emergency State", index: 6, eventType: const PortType(PortType.BOOLEAN), ), ); topics.add( Topic( name: "Battery Level", index: 7, eventType: const PortType(PortType.NUMERIC), ), ); } @override void calculate() { } } 

// File: \lib\niagara\models\logic_components.dart
import 'component.dart'; import 'component_type.dart'; import 'port.dart'; import 'port_type.dart'; class LogicComponent extends Component { LogicComponent({required super.id, required super.type}) { _setupPorts(); } void _setupPorts() { switch (type.type) { case ComponentType.AND_GATE: case ComponentType.OR_GATE: case ComponentType.XOR_GATE: properties.add( Property.withDefaultValue( name: "Input A", index: 0, isInput: true, type: const PortType(PortType.BOOLEAN), ), ); properties.add( Property.withDefaultValue( name: "Input B", index: 1, isInput: true, type: const PortType(PortType.BOOLEAN), ), ); properties.add( Property.withDefaultValue( name: "Output", index: 2, isInput: false, type: const PortType(PortType.BOOLEAN), ), ); break; case ComponentType.NOT_GATE: properties.add( Property.withDefaultValue( name: "Input", index: 0, isInput: true, type: const PortType(PortType.BOOLEAN), ), ); properties.add( Property.withDefaultValue( name: "Output", index: 1, isInput: false, type: const PortType(PortType.BOOLEAN), ), ); break; case ComponentType.IS_GREATER_THAN: case ComponentType.IS_LESS_THAN: properties.add( Property.withDefaultValue( name: "Input A", index: 0, isInput: true, type: const PortType(PortType.NUMERIC), ), ); properties.add( Property.withDefaultValue( name: "Input B", index: 1, isInput: true, type: const PortType(PortType.NUMERIC), ), ); properties.add( Property.withDefaultValue( name: "Output", index: 2, isInput: false, type: const PortType(PortType.BOOLEAN), ), ); break; case ComponentType.IS_EQUAL: properties.add( Property.withDefaultValue( name: "Input A", index: 0, isInput: true, type: const PortType(PortType.ANY), ), ); properties.add( Property.withDefaultValue( name: "Input B", index: 1, isInput: true, type: const PortType(PortType.ANY), ), ); properties.add( Property.withDefaultValue( name: "Output", index: 2, isInput: false, type: const PortType(PortType.BOOLEAN), ), ); break; } } @override void calculate() { switch (type.type) { case ComponentType.AND_GATE: final bool inputA = properties[0].value as bool; final bool inputB = properties[1].value as bool; properties[2].value = inputA && inputB; break; case ComponentType.OR_GATE: final bool inputA = properties[0].value as bool; final bool inputB = properties[1].value as bool; properties[2].value = inputA || inputB; break; case ComponentType.XOR_GATE: final bool inputA = properties[0].value as bool; final bool inputB = properties[1].value as bool; properties[2].value = inputA != inputB; break; case ComponentType.NOT_GATE: final bool input = properties[0].value as bool; properties[1].value = !input; break; case ComponentType.IS_GREATER_THAN: final num inputA = properties[0].value as num; final num inputB = properties[1].value as num; properties[2].value = inputA > inputB; break; case ComponentType.IS_LESS_THAN: final num inputA = properties[0].value as num; final num inputB = properties[1].value as num; properties[2].value = inputA < inputB; break; case ComponentType.IS_EQUAL: final dynamic inputA = properties[0].value; final dynamic inputB = properties[1].value; properties[2].value = inputA == inputB; break; } } } 

// File: \lib\niagara\models\math_components.dart
import 'dart:math' show pow; import 'component.dart'; import 'component_type.dart'; import 'port.dart'; import 'port_type.dart'; class MathComponent extends Component { MathComponent({required super.id, required super.type}) { _setupPorts(); } void _setupPorts() { switch (type.type) { case ComponentType.ADD: case ComponentType.SUBTRACT: case ComponentType.MULTIPLY: case ComponentType.DIVIDE: case ComponentType.MAX: case ComponentType.MIN: properties.add( Property.withDefaultValue( name: "Input A", index: 0, isInput: true, type: const PortType(PortType.NUMERIC), ), ); properties.add( Property.withDefaultValue( name: "Input B", index: 1, isInput: true, type: const PortType(PortType.NUMERIC), ), ); properties.add( Property.withDefaultValue( name: "Output", index: 2, isInput: false, type: const PortType(PortType.NUMERIC), ), ); break; case ComponentType.POWER: properties.add( Property.withDefaultValue( name: "Base", index: 0, isInput: true, type: const PortType(PortType.NUMERIC), ), ); properties.add( Property.withDefaultValue( name: "Exponent", index: 1, isInput: true, type: const PortType(PortType.NUMERIC), ), ); properties.add( Property.withDefaultValue( name: "Output", index: 2, isInput: false, type: const PortType(PortType.NUMERIC), ), ); break; case ComponentType.ABS: properties.add( Property.withDefaultValue( name: "Input", index: 0, isInput: true, type: const PortType(PortType.NUMERIC), ), ); properties.add( Property.withDefaultValue( name: "Output", index: 1, isInput: false, type: const PortType(PortType.NUMERIC), ), ); break; } } @override void calculate() { switch (type.type) { case ComponentType.ADD: final num inputA = properties[0].value as num; final num inputB = properties[1].value as num; properties[2].value = inputA + inputB; break; case ComponentType.SUBTRACT: final num inputA = properties[0].value as num; final num inputB = properties[1].value as num; properties[2].value = inputA - inputB; break; case ComponentType.MULTIPLY: final num inputA = properties[0].value as num; final num inputB = properties[1].value as num; properties[2].value = inputA * inputB; break; case ComponentType.DIVIDE: final num inputA = properties[0].value as num; final num inputB = properties[1].value as num; properties[2].value = inputB != 0 ? inputA / inputB : double.infinity; break; case ComponentType.MAX: final num inputA = properties[0].value as num; final num inputB = properties[1].value as num; properties[2].value = inputA > inputB ? inputA : inputB; break; case ComponentType.MIN: final num inputA = properties[0].value as num; final num inputB = properties[1].value as num; properties[2].value = inputA < inputB ? inputA : inputB; break; case ComponentType.POWER: final num base = properties[0].value as num; final num exponent = properties[1].value as num; properties[2].value = pow(base, exponent); break; case ComponentType.ABS: final num input = properties[0].value as num; properties[1].value = input.abs(); break; } } } 

// File: \lib\niagara\models\point_components.dart
import 'component.dart'; import 'component_type.dart'; import 'port.dart'; import 'port_type.dart'; class PointComponent extends Component { PointComponent({required super.id, required super.type}) { _setupPorts(); } void _setupPorts() { switch (type.type) { case ComponentType.BOOLEAN_WRITABLE: properties.add( Property.withDefaultValue( name: "Output", index: 0, isInput: false, type: const PortType(PortType.BOOLEAN), ), ); properties.add( Property.withDefaultValue( name: "In1", index: 1, isInput: true, type: const PortType(PortType.BOOLEAN), ), ); properties.add( Property.withDefaultValue( name: "In2", index: 2, isInput: true, type: const PortType(PortType.BOOLEAN), ), ); properties.add( Property.withDefaultValue( name: "In3", index: 3, isInput: true, type: const PortType(PortType.BOOLEAN), ), ); properties.add( Property.withDefaultValue( name: "In4", index: 4, isInput: true, type: const PortType(PortType.BOOLEAN), ), ); break; case ComponentType.NUMERIC_WRITABLE: properties.add( Property.withDefaultValue( name: "Output", index: 0, isInput: false, type: const PortType(PortType.NUMERIC), ), ); properties.add( Property.withDefaultValue( name: "In1", index: 1, isInput: true, type: const PortType(PortType.NUMERIC), ), ); properties.add( Property.withDefaultValue( name: "In2", index: 2, isInput: true, type: const PortType(PortType.NUMERIC), ), ); properties.add( Property.withDefaultValue( name: "In3", index: 3, isInput: true, type: const PortType(PortType.NUMERIC), ), ); properties.add( Property.withDefaultValue( name: "In4", index: 4, isInput: true, type: const PortType(PortType.NUMERIC), ), ); break; case ComponentType.STRING_WRITABLE: properties.add( Property.withDefaultValue( name: "Output", index: 0, isInput: false, type: const PortType(PortType.STRING), ), ); properties.add( Property.withDefaultValue( name: "In1", index: 1, isInput: true, type: const PortType(PortType.STRING), ), ); properties.add( Property.withDefaultValue( name: "In2", index: 2, isInput: true, type: const PortType(PortType.STRING), ), ); properties.add( Property.withDefaultValue( name: "In3", index: 3, isInput: true, type: const PortType(PortType.STRING), ), ); properties.add( Property.withDefaultValue( name: "In4", index: 4, isInput: true, type: const PortType(PortType.STRING), ), ); break; case ComponentType.BOOLEAN_POINT: properties.add( Property.withDefaultValue( name: "Input", index: 0, isInput: true, type: const PortType(PortType.BOOLEAN), ), ); break; case ComponentType.NUMERIC_POINT: properties.add( Property.withDefaultValue( name: "Input", index: 0, isInput: true, type: const PortType(PortType.NUMERIC), ), ); break; case ComponentType.STRING_POINT: properties.add( Property.withDefaultValue( name: "Input", index: 0, isInput: true, type: const PortType(PortType.STRING), ), ); break; } } @override void calculate() { if (type.type == ComponentType.BOOLEAN_WRITABLE || type.type == ComponentType.NUMERIC_WRITABLE || type.type == ComponentType.STRING_WRITABLE) { Property outputProperty = properties[0]; dynamic currentValue = outputProperty.value; for (int i = 1; i <= 4; i++) { Property inputProperty = properties[i]; if (inputConnections.containsKey(inputProperty.index)) { if (inputProperty.value != null) { currentValue = inputProperty.value; break; } } } outputProperty.value = currentValue; } } } 

// File: \lib\niagara\models\port.dart
import 'port_type.dart'; abstract class Slot { final String name; final int index; Slot({required this.name, required this.index}); } class Property extends Slot { final bool isInput; final PortType type; dynamic value; Property({ required super.name, required super.index, required this.isInput, required this.type, this.value, }); factory Property.withDefaultValue({ required String name, required int index, required bool isInput, required PortType type, }) { dynamic defaultValue; switch (type.type) { case PortType.BOOLEAN: defaultValue = false; break; case PortType.NUMERIC: defaultValue = 0.0; break; case PortType.STRING: defaultValue = ''; break; case PortType.ANY: defaultValue = null; break; } return Property( name: name, index: index, isInput: isInput, type: type, value: defaultValue, ); } bool canConnectTo(Property otherProperty) { if (isInput == otherProperty.isInput) return false; return type.type == PortType.ANY || otherProperty.type.type == PortType.ANY || type == otherProperty.type; } } class ActionSlot extends Slot { final PortType? parameterType; final PortType? returnType; dynamic parameter; dynamic returnValue; ActionSlot({ required super.name, required super.index, this.parameterType, this.returnType, this.parameter, this.returnValue, }); dynamic execute({dynamic parameter}) { this.parameter = parameter; return returnValue; } } class Topic extends Slot { final PortType eventType; dynamic lastEvent; Topic({required super.name, required super.index, required this.eventType}); void fire(dynamic event) { lastEvent = event; } } 

// File: \lib\niagara\models\port_type.dart
class PortType { static const String BOOLEAN = "BOOLEAN"; static const String NUMERIC = "NUMERIC"; static const String STRING = "STRING"; static const String ANY = "ANY"; final String type; const PortType(this.type); @override bool operator ==(Object other) => identical(this, other) || other is PortType && other.type == type; @override int get hashCode => type.hashCode; static PortType fromString(String type) { return PortType(type); } } 

// File: \lib\niagara\models\ramp_component.dart
import 'dart:async'; import 'dart:math'; import 'component.dart'; import 'component_type.dart'; import 'port.dart'; import 'port_type.dart'; class RampComponent extends Component { static const String RAMP = "RAMP"; Timer? _timer; double _stepAmount = 0.0; final double _stepRange = 10.0; final double _min = 0.0; final double _max = 100.0; bool _running = false; RampComponent({required super.id}) : super(type: const ComponentType(RAMP)) { _setupPorts(); _startRamping(); } void _setupPorts() { properties.add( Property( name: "Output", index: 0, isInput: false, type: const PortType(PortType.NUMERIC), value: 0.0, ), ); } @override void calculate() { properties[0].value += properties[0].value + _stepAmount; if (properties[0].value >= _max) { properties[0].value = _min; } } void _startRamping() { if (_running) return; _running = true; _timer = Timer.periodic(const Duration(seconds: 2), (timer) { final random = Random(); _stepAmount = random.nextDouble() * _stepRange; calculate(); }); } void stopRamping() { _running = false; _timer?.cancel(); _timer = null; } void dispose() { stopRamping(); } } 

// File: \lib\niagara\models\rectangle.dart
import 'component.dart'; import 'component_type.dart'; import 'port.dart'; import 'port_type.dart'; class RectangleComponent extends Component { static const String RECTANGLE = "RECTANGLE"; RectangleComponent({required super.id}) : super(type: const ComponentType(RECTANGLE)) { _setupPorts(); } void _setupPorts() { properties.add( Property( name: "Length", index: 0, isInput: true, type: const PortType(PortType.NUMERIC), value: 0.0, ), ); properties.add( Property( name: "Width", index: 1, isInput: true, type: const PortType(PortType.NUMERIC), value: 0.0, ), ); properties.add( Property( name: "Threshold", index: 2, isInput: true, type: const PortType(PortType.NUMERIC), value: 1000.0, ), ); topics.add( Topic( name: "Detected", index: 3, eventType: const PortType(PortType.NUMERIC), ), ); } @override void calculate() { double length = properties[0].value as double; double width = properties[1].value as double; double threshold = properties[2].value as double; double area = length * width; if (area > threshold) { topics[0].fire(area); } } } 

// File: \lib\protocol\device_types.dart
bool isButtonDevice(int typeCode) { return typeCode == 1265666 ||  typeCode == 1271554 ||  typeCode == 1274882 ||  typeCode == 1200386 ||  typeCode == 1206274 ||  typeCode == 1184514 ||  typeCode == 1262338 ||  typeCode == 1442306 ||  (typeCode & 0xFF) == 0x02 && (((typeCode >> 8) & 0xFF) == 0x12 ||  ((typeCode >> 8) & 0xFF) == 0x93 ||  ((typeCode >> 8) & 0xFF) == 0x82  ); } bool isDeviceMultisensor(int typeCode) { return typeCode == 3217410 ||  typeCode == 3220738 ||  typeCode == 3282690 ||  ((typeCode & 0xFF) == 0x02 && ((typeCode >> 8) & 0xFF) == 0x31);  } String getDeviceTypeDescription(int typeCode) { final protocol = typeCode & 0xFF; if (protocol == 0x01) { return DaliDeviceType.types[typeCode] ?? 'DALI Device (0x${typeCode.toRadixString(16)})'; } else if (protocol == 0x02) { return DigidimDeviceType.types[typeCode] ?? 'Digidim Device (0x${typeCode.toRadixString(16)})'; } else if (protocol == 0x04) { return ImagineDeviceType.types[typeCode] ?? 'Imagine Device (0x${typeCode.toRadixString(16)})'; } else if (protocol == 0x08) { return DmxDeviceType.types[typeCode] ?? 'DMX Device (0x${typeCode.toRadixString(16)})'; } else if (typeCode == 4818434) { return '498 – Relay Unit (8 channel relay) DALI'; } else if (typeCode == 3217410 || typeCode == 3220738 || typeCode == 3282690) { return 'Multisensor'; } else if (typeCode == 1537) { return 'LED Unit'; } else if (typeCode == 1265666) { return 'Button 135'; } else if (typeCode == 1) { return 'Fluorescent Lamps'; } else if (typeCode == 1793) { return 'Switching function (Relay)'; } else if (typeCode == 1226903554) { return 'DDP Device'; } return 'Unknown Device (0x${typeCode.toRadixString(16)})'; } class DaliDeviceType { static const Map<int, String> types = { 0x0001: 'Fluorescent Lamps', 0x0101: 'Self-contained emergency lighting', 0x0201: 'Discharge lamps (excluding fluorescent lamps)', 0x0301: 'Low voltage halogen lamps', 0x0401: 'Incandescent lamps', 0x0501: 'Conversion into D.C. voltage (IEC 60929)', 0x0601: 'LED modules', 0x0701: 'Switching function (i.e., Relay)', 0x0801: 'Colour control', 0x0901: 'Sequencer', }; } class DigidimDeviceType { static const Map<int, String> types = { 0x00100802: '100 – Rotary', 0x00110702: '110 – Single Sider', 0x00111402: '111 – Double Sider', 0x00121302: '121 – 2 Button On/Off + IR', 0x00122002: '122 – 2 Button Modifier + IR', 0x00124402: '124 – 5 Button + IR', 0x00125102: '125 – 5 Button + Modifier + IR', 0x00126802: '126 – 8 Button + IR', 0x00170102: '170 – IR Receiver', 0x00312502: '312 – Multisensor', 0x00410802: '410 – Ballast (1-10V Converter)', 0x00416002: '416S – 16A Dimmer', 0x00425202: '425S – 25A Dimmer', 0x00444302: '444 – Mini Input Unit', 0x00450402: '450 – 800W Dimmer', 0x00452802: '452 – 1000W Universal Dimmer', 0x00455902: '455 – 500W Thruster Dimmer', 0x00458002: '458/DIMB – 8-Channel Dimmer', 0x74458102: '459/CTRB – 8-Ch Ballast Controller', 0x04458302: '459/SWB – 8-Ch Relay Module', 0x00460302: '460 – DALI-to-SDIM Converter', 0x00472602: '472 – Din Rail 1-10V/DS/8 Converter', 0x00474002: '474 – 4-Ch Ballast (Output Unit)', 0x00474102: '474 – 4-Ch Ballast (Relay Unit)', 0x00490002: '490 – Blinds Unit', 0x00494802: '494 – Relay Unit', 0x00496602: '498 – Relay Unit', 0x00804502: '804 – Digidim 4', 0x00824002: '924 – LCD TouchPanel', 0x00935602: '935 – Scene Commander (6 Buttons)', 0x00939402: '939 – Scene Commander (10 Buttons)', 0x00942402: '942 – Analogue Input Unit', 0x00458602: '459/CPT4 – 4-Ch Options Module', }; } class ImagineDeviceType { static const Map<int, String> types = { 0x00000004: 'No device present', 0x0000F104: '474 – 4 Channel Ballast Controller - Relay Unit', 0x0000F204: '474 – 4 Channel Ballast Controller - Output Unit', 0x0000F304: '458/SW8 – 8-Channel Relay Module', 0x0000F404: '458/CTR8 – 8-Channel Ballast Controller', 0x0000F504: '458/OPT4 – Options Module', 0x0000F604: '498 – 8-Channel Relay Unit', 0x0000F704: '458/DIM8 – 8-Channel Dimmer', 0x0000F804: 'HES92060 – Sine Wave Dimmer', 0x0000F904: 'Ambience4 Dimmer', 0x0000FA04: 'HES92020 – SCR Dimmer', 0x0000FB04: 'HES98020 – Output Unit', 0x0000FC04: 'HES92220 – Transistor Dimmer', 0x0000FE04: 'HES98180-98291 – Relay Unit', 0x0000FF04: 'Dimmer (old style, type undefined)', }; } class DmxDeviceType { static const Map<int, String> types = { 0x00000008: 'DMX No device present', 0x00000108: 'DMX Channel In', 0x00000208: 'DMX Channel Out', }; } class DigidimKeyType { static const Map<int, String> types = { 0x00000001: 'SinglePress', 0x00000002: 'TimedPress', 0x00000003: 'ToggleSolo', 0x00000004: 'ToggleBlock', 0x00000005: 'TouchDimBlock', 0x00000006: 'TouchDimSolo', 0x00000007: 'Modifier', 0x00000008: 'EdgeMode', 0x00000009: 'Slider', 0x0000000A: 'AnalogueInput', 0x0000000B: 'Rotary', 0x0000000C: 'PIR', 0x0000000D: 'ConstantLight', 0x0000000E: 'SliderInputUnit', }; } 

// File: \lib\protocol\message_parser.dart
import 'protocol_constants.dart'; Map<String, dynamic> parseResponse(String response) { final result = <String, dynamic>{}; if (!response.startsWith(MessageType.reply) && !response.startsWith(MessageType.error)) { throw FormatException('Invalid response format: $response'); } final parts = response.split(MessageType.answer); if (parts.length != 2) { throw FormatException('Invalid response format: $response'); } final commandPart = parts[0].substring(1); final commandParams = commandPart.split(MessageType.delimiter); var dataPart = parts[1]; if (dataPart.endsWith(MessageType.terminator)) { dataPart = dataPart.substring(0, dataPart.length - 1); } else if (dataPart.endsWith(MessageType.partialTerminator)) { dataPart = dataPart.substring(0, dataPart.length - 1); result['partial'] = true; } for (final param in commandParams) { if (param.contains(MessageType.paramDelimiter)) { final keyValue = param.split(MessageType.paramDelimiter); if (keyValue.length == 2) { result[keyValue[0]] = keyValue[1]; } } else if (param.startsWith(ParameterId.address)) { result[ParameterId.address] = param.substring(1); } } if (response.startsWith(MessageType.error)) { final errorCode = int.tryParse(dataPart); result['error'] = errorCode; result['errorMessage'] = ErrorCode.getMessage(errorCode ?? -1); } else { if (dataPart.contains(MessageType.delimiter)) { final values = dataPart.split(MessageType.delimiter); result['data'] = values; } else { result['data'] = dataPart; } } return result; } Map<String, int> parseDeviceAddress(String address) { final parts = address.split(MessageType.addressDelimiter); if (parts.length != 4) { throw FormatException('Invalid device address format: $address'); } return { 'cluster': int.parse(parts[0]), 'router': int.parse(parts[1]), 'subnet': int.parse(parts[2]), 'device': int.parse(parts[3]), }; } Map<String, bool> decodeDeviceState(int stateValue) { return { 'disabled': (stateValue & DeviceStateFlag.disabled) != 0, 'lampFailure': (stateValue & DeviceStateFlag.lampFailure) != 0, 'missing': (stateValue & DeviceStateFlag.missing) != 0, 'faulty': (stateValue & DeviceStateFlag.faulty) != 0, 'refreshing': (stateValue & DeviceStateFlag.refreshing) != 0, 'emergencyResting': (stateValue & DeviceStateFlag.emergencyResting) != 0, 'emergencyMode': (stateValue & DeviceStateFlag.emergencyMode) != 0, 'emergencyProlong': (stateValue & DeviceStateFlag.emergencyProlong) != 0, 'functionalTestInProgress': (stateValue & DeviceStateFlag.functionalTestInProgress) != 0, 'durationTestInProgress': (stateValue & DeviceStateFlag.durationTestInProgress) != 0, 'durationTestPending': (stateValue & DeviceStateFlag.durationTestPending) != 0, 'functionalTestPending': (stateValue & DeviceStateFlag.functionalTestPending) != 0, 'batteryFail': (stateValue & DeviceStateFlag.batteryFail) != 0, 'emergencyInhibit': (stateValue & DeviceStateFlag.emergencyInhibit) != 0, 'functionalTestRequested': (stateValue & DeviceStateFlag.functionalTestRequested) != 0, 'durationTestRequested': (stateValue & DeviceStateFlag.durationTestRequested) != 0, 'unknown': (stateValue & DeviceStateFlag.unknown) != 0, 'overTemperature': (stateValue & DeviceStateFlag.overTemperature) != 0, 'overCurrent': (stateValue & DeviceStateFlag.overCurrent) != 0, 'commsError': (stateValue & DeviceStateFlag.commsError) != 0, 'severeError': (stateValue & DeviceStateFlag.severeError) != 0, 'badReply': (stateValue & DeviceStateFlag.badReply) != 0, 'deviceMismatch': (stateValue & DeviceStateFlag.deviceMismatch) != 0, }; } Map<String, bool> decodeEmergencyTestState(int stateValue) { return { 'pass': (stateValue & EmergencyTestState.pass) == EmergencyTestState.pass, 'lampFailure': (stateValue & EmergencyTestState.lampFailure) != 0, 'batteryFailure': (stateValue & EmergencyTestState.batteryFailure) != 0, 'faulty': (stateValue & EmergencyTestState.faulty) != 0, 'failure': (stateValue & EmergencyTestState.failure) != 0, 'testPending': (stateValue & EmergencyTestState.testPending) != 0, 'unknown': (stateValue & EmergencyTestState.unknown) != 0, }; } 

// File: \lib\protocol\protocol_constants.dart
const int maxMessageLength = 1500; const int defaultTcpPort = 50000; const int defaultUdpPort = 50001; String getStateFlagsDescription(int flags) { final descriptions = <String>[]; if (flags == 0) return 'Normal'; if ((flags & 0x00000001) != 0) descriptions.add('Disabled'); if ((flags & 0x00000002) != 0) descriptions.add('Lamp Failure'); if ((flags & 0x00000004) != 0) descriptions.add('Missing'); if ((flags & 0x00000008) != 0) descriptions.add('Faulty'); if ((flags & 0x00000010) != 0) descriptions.add('Refreshing'); if ((flags & 0x00000100) != 0) descriptions.add('Emergency Resting'); if ((flags & 0x00000400) != 0) descriptions.add('In Emergency'); if ((flags & 0x00000800) != 0) descriptions.add('In Prolong'); if ((flags & 0x00001000) != 0) descriptions.add('Function Test In Progress'); if ((flags & 0x00002000) != 0) descriptions.add('Duration Test In Progress'); if ((flags & 0x00010000) != 0) descriptions.add('Duration Test Pending'); if ((flags & 0x00020000) != 0) descriptions.add('Function Test Pending'); if ((flags & 0x00040000) != 0) descriptions.add('Battery Failure'); if ((flags & 0x00200000) != 0) descriptions.add('Emergency Inhibit'); if ((flags & 0x00400000) != 0) descriptions.add('Function Test Requested'); if ((flags & 0x00800000) != 0) descriptions.add('Duration Test Requested'); if ((flags & 0x01000000) != 0) descriptions.add('Unknown State'); if ((flags & 0x02000000) != 0) descriptions.add('Over Temperature'); if ((flags & 0x04000000) != 0) descriptions.add('Over Current'); if ((flags & 0x08000000) != 0) descriptions.add('Communications Error'); if ((flags & 0x10000000) != 0) descriptions.add('Severe Error'); if ((flags & 0x20000000) != 0) descriptions.add('Bad Reply'); if ((flags & 0x80000000) != 0) descriptions.add('Device Mismatch'); return descriptions.join(', '); } class MessageType { static const String command = '>';  static const String internalCommand = '<';  static const String reply = '?';  static const String error = '!';  static const String terminator = '#';  static const String partialTerminator = '\$';  static const String answer = '=';  static const String delimiter = ',';  static const String paramDelimiter = ':';  static const String addressDelimiter = '.';  } class ParameterId { static const String sequenceNumber = 'Q';  static const String version = 'V';  static const String command = 'C';  static const String acknowledgment = 'A';  static const String address = '@';  static const String group = 'G';  static const String scene = 'S';  static const String block = 'B';  static const String fadeTime = 'F';  static const String level = 'L';  static const String proportion = 'P';  static const String constantLight = 'K';  static const String forceStore = 'O';  } class ProtocolType { static const int dali = 0x01; static const int digidim = 0x02; static const int imagine = 0x04; static const int dmx = 0x08; } class SceneStatus { static const Map<int, String> descriptions = { 128: 'Off',  129: 'Min level',  130: 'Max level',  137: 'Last Scene Percentage (0%)',  138: 'Last Scene Percentage (1%)',  237: 'Last Scene Percentage (100%)'  }; } class ErrorCode { static const int success = 0; static const int invalidGroupIndex = 1; static const int invalidCluster = 2; static const int invalidRouter = 3; static const int invalidSubnet = 4; static const int invalidDevice = 5; static const int invalidSubDevice = 6; static const int invalidBlock = 7; static const int invalidScene = 8; static const int clusterNotExist = 9; static const int routerNotExist = 10; static const int deviceNotExist = 11; static const int propertyNotExist = 12; static const int invalidRawMessageSize = 13; static const int invalidMessageType = 14; static const int invalidMessageCommand = 15; static const int missingAsciiTerminator = 16; static const int missingAsciiParameter = 17; static const int incompatibleVersion = 18; static String getMessage(int code) { switch (code) { case success: return 'Success'; case invalidGroupIndex: return 'Error - Invalid group index parameter'; case invalidCluster: return 'Error - Invalid cluster parameter'; case invalidRouter: return 'Error - Invalid router parameter'; case invalidSubnet: return 'Error - Invalid subnet parameter'; case invalidDevice: return 'Error - Invalid device parameter'; case invalidSubDevice: return 'Error - Invalid sub device parameter'; case invalidBlock: return 'Error - Invalid block parameter'; case invalidScene: return 'Error - Invalid scene parameter'; case clusterNotExist: return 'Error - Cluster does not exist'; case routerNotExist: return 'Error - Router does not exist'; case deviceNotExist: return 'Error - Device does not exist'; case propertyNotExist: return 'Error - Property does not exist'; case invalidRawMessageSize: return 'Error - Invalid RAW message size'; case invalidMessageType: return 'Error - Invalid messages type'; case invalidMessageCommand: return 'Error - Invalid message command'; case missingAsciiTerminator: return 'Error - Missing ASCII terminator'; case missingAsciiParameter: return 'Error - Missing ASCII parameter'; case incompatibleVersion: return 'Error - Incompatible version'; default: return 'Unknown error: $code'; } } } class DeviceStateFlag { static const int disabled = 0x00000001; static const int lampFailure = 0x00000002; static const int missing = 0x00000004; static const int faulty = 0x00000008; static const int refreshing = 0x00000010; static const int emergencyResting = 0x00000100; static const int emergencyMode = 0x00000400; static const int emergencyProlong = 0x00000800; static const int functionalTestInProgress = 0x00001000; static const int durationTestInProgress = 0x00002000; static const int durationTestPending = 0x00010000; static const int functionalTestPending = 0x00020000; static const int batteryFail = 0x00040000; static const int emergencyInhibit = 0x00200000; static const int functionalTestRequested = 0x00400000; static const int durationTestRequested = 0x00800000; static const int unknown = 0x01000000; static const int overTemperature = 0x02000000; static const int overCurrent = 0x04000000; static const int commsError = 0x08000000; static const int severeError = 0x10000000; static const int badReply = 0x20000000; static const int deviceMismatch = 0x80000000; } class EmergencyTestState { static const int pass = 0; static const int lampFailure = 1; static const int batteryFailure = 2; static const int faulty = 4; static const int failure = 8; static const int testPending = 16; static const int unknown = 32; } class CommandNumber { static const int recallSceneGroup = 11; static const int recallSceneDevice = 12; static const int directLevelGroup = 13; static const int directLevelDevice = 14; static const int directProportionGroup = 15; static const int directProportionDevice = 16; static const int modifyProportionGroup = 17; static const int modifyProportionDevice = 18; static const int emergencyFunctionTestGroup = 19; static const int emergencyFunctionTestDevice = 20; static const int emergencyDurationTestGroup = 21; static const int emergencyDurationTestDevice = 22; static const int stopEmergencyTestsGroup = 23; static const int stopEmergencyTestsDevice = 24; static const int storeSceneGroup = 201; static const int storeSceneChannel = 202; static const int storeAsSceneGroup = 203; static const int storeAsSceneChannel = 204; static const int resetEmergencyBatteryGroup = 205; static const int resetEmergencyBatteryDevice = 206; static const int queryClusters = 101; static const int queryRouters = 102; static const int queryLastSceneInBlock = 103; static const int queryDeviceType = 104; static const int queryDescriptionGroup = 105; static const int queryDescriptionDevice = 106; static const int queryDeviceState = 110; static const int queryDeviceDisabled = 111; static const int queryLampFailure = 112; static const int queryDeviceMissing = 113; static const int queryDeviceFaulty = 114; static const int queryMeasurement = 150; static const int queryInputs = 151; static const int queryLoadLevel = 152; static const int queryPowerConsumption = 160; static const int queryGroupPowerConsumption = 161; static const int queryEmergencyFunctionTestTime = 170; static const int queryEmergencyFunctionTestState = 171; static const int queryEmergencyDurationTestTime = 172; static const int queryEmergencyDurationTestState = 173; static const int queryEmergencyBatteryCharge = 174; static const int queryEmergencyBatteryTime = 175; static const int queryEmergencyTotalLampTime = 176; static const int queryTime = 185; static const int queryTimeZone = 188; static const int queryDaylightSavingTime = 189; static const int querySoftwareVersion = 190; static const int queryHelvarNetVersion = 191; static const int queryWorkgroupName = 107; static const int queryWorkgroupMembership = 108; static const int queryGroups = 165; static const int queryGroup = 164; static const int querySceneNames = 166; static const int querySceneInfo = 167; } class DigidimKeyType { static const Map<int, String> types = { 0x01: 'SinglePress', 0x02: 'TimedPress', 0x03: 'ToggleSolo', }; } 

// File: \lib\protocol\protocol_parser.dart
import '../utils/logger.dart'; class ProtocolParser { static String? extractResponseValue(String response) { if ((response.startsWith('?') || response.startsWith('!')) && response.contains('=')) { final parts = response.split('='); if (parts.length > 1) { return parts[1].replaceAll('#', ''); } } return null; } static Map<int, int> parseDeviceAddressesAndTypes(String response) { final deviceMap = <int, int>{}; final pairs = response.split(','); for (final pair in pairs) { if (pair.contains('@')) { final parts = pair.split('@'); if (parts.length == 2) { try { final deviceType = int.parse(parts[0]); final deviceId = int.parse(parts[1]); deviceMap[deviceId] = deviceType; } catch (e) { logError('Error parsing device pair: $pair - $e'); } } } } return deviceMap; } static bool isSuccessResponse(String response) { return response.startsWith('?'); } static bool isErrorResponse(String response) { return response.startsWith('!'); } static int? getCommandCode(String response) { if (!response.startsWith('?') && !response.startsWith('!')) { return null; } final commandMatch = RegExp(r'C:(\d+)').firstMatch(response); if (commandMatch != null) { return int.tryParse(commandMatch.group(1)!); } return null; } static int? getVersion(String response) { if (!response.startsWith('?') && !response.startsWith('!')) { return null; } final versionMatch = RegExp(r'V:(\d+)').firstMatch(response); if (versionMatch != null) { return int.tryParse(versionMatch.group(1)!); } return null; } static String? getDeviceAddress(String response) { if (!response.startsWith('?') && !response.startsWith('!')) { return null; } final addressMatch = RegExp(r'@([\d.]+)').firstMatch(response); if (addressMatch != null) { return addressMatch.group(1); } return null; } static Map<String, dynamic> parseFullResponse(String response) { return { 'isSuccess': isSuccessResponse(response), 'isError': isErrorResponse(response), 'version': getVersion(response), 'commandCode': getCommandCode(response), 'deviceAddress': getDeviceAddress(response), 'value': extractResponseValue(response), 'rawResponse': response, }; } } 

// File: \lib\protocol\protocol_utils.dart
import 'protocol_constants.dart'; class ProtocolUtils { static bool isErrorResponse(String response) { return response.startsWith(MessageType.error); } static int? getErrorCode(String errorResponse) { if (!isErrorResponse(errorResponse)) { return null; } final parts = errorResponse.split(MessageType.answer); if (parts.length != 2) { return null; } var errorCodeStr = parts[1]; if (errorCodeStr.endsWith(MessageType.terminator)) { errorCodeStr = errorCodeStr.substring(0, errorCodeStr.length - 1); } return int.tryParse(errorCodeStr); } static String formatDeviceAddress( int cluster, int router, int subnet, int device) { return '$cluster${MessageType.addressDelimiter}$router${MessageType.addressDelimiter}$subnet${MessageType.addressDelimiter}$device'; } } 

// File: \lib\protocol\query_commands.dart
class HelvarNetCommands { static int version = 2; static String queryDeviceType(String address) { return '>V:$version,C:104,@$address#'; } static String queryDescriptionGroup(int group) { if (group < 1 || group > 16383) { throw ArgumentError('Group must be between 1 and 16383'); } return '>V:$version,C:105,G:$group#'; } static String queryDescriptionDevice(String address) { return '>V:$version,C:106,@$address#'; } static String queryWorkgroupName() { return '>V:$version,C:107#'; } static String queryWorkgroupMembership() { return '>V:$version,C:108#'; } static String queryLastSceneInBlock(int group, int block) { _validateGroup(group); _validateBlock(block); return '>V:$version,C:103,G:$group,B:$block#'; } static String queryLastSceneInGroup(int group) { _validateGroup(group); return '>V:$version,C:109,G:$group#'; } static String queryDeviceState(String address) { return '>V:$version,C:110,@$address#'; } static String queryDeviceIsDisabled(String address) { return '>V:$version,C:111,@$address#'; } static String queryLampFailure(String address) { return '>V:$version,C:112,@$address#'; } static String queryDeviceIsMissing(String address) { return '>V:$version,C:113,@$address#'; } static String queryDeviceIsFaulty(String address) { return '>V:$version,C:114,@$address#'; } static String queryEmergencyBatteryFailure(String address) { return '>V:$version,C:129,@$address#'; } static String queryInputs() { return '>V:$version,C:151#'; } static String queryInputsForDevice(String address) { return '>V:$version,C:151,@$address#'; } static String queryMeasurement(String address) { return '>V:$version,C:150,@$address#'; } static String queryDeviceInfo(String address) { return '>V:$version,C:100,@$address#'; } static String querySceneInfoForDevice(String address) { return '>V:$version,C:167,@$address#'; } static String queryDeviceProperties(String address) { return '>V:$version,C:104,@$address#'; } static String queryLoadLevel(String address) { return '>V:$version,C:152,@$address#'; } static String queryPowerConsumption(String address) { return '>V:$version,C:160,@$address#'; } static String queryGroupPowerConsumption(int group) { _validateGroup(group); return '>V:$version,C:161,G:$group#'; } static String queryEmergencyFunctionTestTime(String address) { return '>V:$version,C:170,@$address#'; } static String queryEmergencyFunctionTestState(String address) { return '>V:$version,C:171,@$address#'; } static String queryEmergencyDurationTestTime(String address) { return '>V:$version,C:172,@$address#'; } static String queryEmergencyDurationTestState(String address) { return '>V:$version,C:173,@$address#'; } static String queryEmergencyBatteryCharge(String address) { return '>V:$version,C:174,@$address#'; } static String queryEmergencyBatteryTime(String address) { return '>V:$version,C:175,@$address#'; } static String queryEmergencyTotalLampTime(String address) { return '>V:$version,C:176,@$address#'; } static String queryTime() { return '>V:$version,C:185#'; } static String queryTimeZone() { return '>V:$version,C:188#'; } static String queryDaylightSavingTime() { return '>V:$version,C:189#'; } static String querySoftwareVersion() { return '>V:$version,C:190#'; } static String queryHelvarNetVersion() { return '>V:$version,C:191#'; } static String queryClusters() { return '>V:$version,C:101#'; } static String queryRouters(int cluster) { if (cluster < 1 || cluster > 253) { throw ArgumentError('Cluster must be between 1 and 253'); } return '>V:$version,C:102,@$cluster#'; } static String queryDeviceTypesAndAddresses(String address) { return '>V:$version,C:100@$address#'; } static String queryGroups() { return '>V:$version,C:165#'; } static String queryGroup(int group) { _validateGroup(group); return '>V:$version,C:164,G:$group#'; } static String querySceneNames() { return '>V:$version,C:166#'; } static String querySceneInfo(String address) { return '>V:$version,C:167@$address#'; } static String recallSceneGroup(int group, int block, int scene, {bool constantLight = false, int fadeTime = 0}) { _validateGroup(group); _validateBlock(block); _validateScene(scene); _validateFadeTime(fadeTime); final constantLightValue = constantLight ? 1 : 0; return '>V:$version,C:11,G:$group,K:$constantLightValue,B:$block,S:$scene,F:$fadeTime#'; } static String recallSceneDevice( int cluster, int router, int subnet, int device, int block, int scene, {int fadeTime = 0}) { _validateBlock(block); _validateScene(scene); _validateFadeTime(fadeTime); String address = '$cluster.$router.$subnet.$device'; return '>V:$version,C:12,B:$block,S:$scene,F:$fadeTime,@$address#'; } static String directLevelGroup(int group, int level, {int fadeTime = 0}) { _validateGroup(group); _validateLevel(level); _validateFadeTime(fadeTime); return '>V:$version,C:13,G:$group,L:$level,F:$fadeTime#'; } static String directLevelDevice(String address, int level, {int fadeTime = 0}) { _validateLevel(level); _validateFadeTime(fadeTime); return '>V:$version,C:14,L:$level,F:$fadeTime,@$address#'; } static String directProportionGroup(int group, int proportion, {int fadeTime = 0}) { _validateGroup(group); _validateProportion(proportion); _validateFadeTime(fadeTime); return '>V:$version,C:15,P:$proportion,G:$group,F:$fadeTime#'; } static String directProportionDevice( int cluster, int router, int subnet, int device, int proportion, {int fadeTime = 0}) { _validateProportion(proportion); _validateFadeTime(fadeTime); String address = '$cluster.$router.$subnet.$device'; return '>V:$version,C:16,P:$proportion,F:$fadeTime,@$address#'; } static String modifyProportionGroup(int group, int proportionChange, {int fadeTime = 0}) { _validateGroup(group); _validateProportionChange(proportionChange); _validateFadeTime(fadeTime); return '>V:$version,C:17,P:$proportionChange,G:$group,F:$fadeTime#'; } static String modifyProportionDevice( int cluster, int router, int subnet, int device, int proportionChange, {int fadeTime = 0}) { _validateProportionChange(proportionChange); _validateFadeTime(fadeTime); String address = '$cluster.$router.$subnet.$device'; return '>V:$version,C:18,P:$proportionChange,F:$fadeTime,@$address#'; } static String emergencyFunctionTestGroup(int group) { _validateGroup(group); return '>V:$version,C:19,G:$group#'; } static String emergencyFunctionTestDevice(String address) { return '>V:$version,C:20,@$address#'; } static String emergencyDurationTestGroup(int group) { _validateGroup(group); return '>V:$version,C:21,G:$group#'; } static String emergencyDurationTestDevice(String address) { return '>V:$version,C:22,@$address#'; } static String stopEmergencyTestsGroup(int group) { _validateGroup(group); return '>V:$version,C:23,G:$group#'; } static String stopEmergencyTestsDevice(String address) { return '>V:$version,C:24,@$address#'; } static String storeSceneGroup(int group, int block, int scene, int level, {bool forceStore = false}) { _validateGroup(group); _validateBlock(block); _validateScene(scene); _validateLevel(level); final forceStoreValue = forceStore ? 1 : 0; return '>V:$version,C:201,G:$group,O:$forceStoreValue,B:$block,S:$scene,L:$level#'; } static String storeSceneDevice(int cluster, int router, int subnet, int device, int block, int scene, int level, {bool forceStore = false}) { _validateBlock(block); _validateScene(scene); _validateLevel(level); String address = '$cluster.$router.$subnet.$device'; final forceStoreValue = forceStore ? 1 : 0; return '>V:$version,C:202,@$address,O:$forceStoreValue,B:$block,S:$scene,L:$level#'; } static String storeAsSceneGroup(int group, int block, int scene, {bool forceStore = false}) { _validateGroup(group); _validateBlock(block); _validateScene(scene); final forceStoreValue = forceStore ? 1 : 0; return '>V:$version,C:203,G:$group,O:$forceStoreValue,B:$block,S:$scene#'; } static String storeAsSceneDevice( int cluster, int router, int subnet, int device, int block, int scene, {bool forceStore = false}) { _validateBlock(block); _validateScene(scene); String address = '$cluster.$router.$subnet.$device'; final forceStoreValue = forceStore ? 1 : 0; return '>V:$version,C:204,@$address,O:$forceStoreValue,B:$block,S:$scene#'; } static String resetEmergencyBatteryAndTotalLampTimeGroup(int group) { _validateGroup(group); return '>V:$version,C:205,G:$group#'; } static String resetEmergencyBatteryAndTotalLampTimeDevice(String address) { return '>V:$version,C:206,@$address#'; } static void _validateGroup(int group) { if (group < 1 || group > 16383) { throw ArgumentError('Group must be between 1 and 16383'); } } static void _validateBlock(int block) { if (block < 1 || block > 8) { throw ArgumentError('Block must be between 1 and 8'); } } static void _validateScene(int scene) { if (scene < 1 || scene > 16) { throw ArgumentError('Scene must be between 1 and 16'); } } static void _validateLevel(int level) { if (level < 0 || level > 100) { throw ArgumentError('Level must be between 0 and 100'); } } static void _validateFadeTime(int fadeTime) { if (fadeTime < 0 || fadeTime > 65535) { throw ArgumentError( 'Fade time must be between 0 and 65535 (0 to 6553.5 seconds)'); } } static void _validateProportion(int proportion) { if (proportion < -100 || proportion > 100) { throw ArgumentError('Proportion must be between -100 and 100'); } } static void _validateProportionChange(int proportionChange) { if (proportionChange < -100 || proportionChange > 100) { throw ArgumentError('Proportion change must be between -100 and 100'); } } } 

// File: \lib\providers\flowsheet_provider.dart
import 'dart:ui'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import '../niagara/models/component.dart'; import '../niagara/models/connection.dart'; import '../models/flowsheet.dart'; import '../services/flowsheet_storage_service.dart'; import '../utils/logger.dart'; class FlowsheetsNotifier extends StateNotifier<List<Flowsheet>> { final FlowsheetStorageService _storageService; String? _activeFlowsheetId; bool _initialized = false; FlowsheetsNotifier({required FlowsheetStorageService storageService}) : _storageService = storageService, super([]) { _initializeData(); } String? get activeFlowsheetId => _activeFlowsheetId; Future<void> _initializeData() async { if (_initialized) return; try { final flowsheets = await _storageService.listFlowsheets(); if (flowsheets.isEmpty) { final defaultFlowsheet = await _storageService.createFlowsheet('Default Flowsheet'); state = [defaultFlowsheet]; _activeFlowsheetId = defaultFlowsheet.id; } else { state = flowsheets; _activeFlowsheetId = flowsheets.first.id; } _initialized = true; } catch (e) { logError('Error initializing flowsheets: $e'); } } Flowsheet? get activeFlowsheet { if (_activeFlowsheetId == null || state.isEmpty) return null; try { return state.firstWhere( (sheet) => sheet.id == _activeFlowsheetId, ); } catch (e) { return state.isNotEmpty ? state.first : null; } } Future<void> updateComponentPosition( String flowsheetId, String componentId, Offset position) async { final index = state.indexWhere((sheet) => sheet.id == flowsheetId); if (index >= 0) { final updatedState = List<Flowsheet>.from(state); updatedState[index].updateComponentPosition(componentId, position); state = updatedState; await _storageService.saveFlowsheet(updatedState[index]); } } Future<void> updateComponentWidth( String flowsheetId, String componentId, double width) async { final index = state.indexWhere((sheet) => sheet.id == flowsheetId); if (index >= 0) { final updatedState = List<Flowsheet>.from(state); updatedState[index].updateComponentWidth(componentId, width); state = updatedState; await _storageService.saveFlowsheet(updatedState[index]); } } Future<void> updatePortValue(String flowsheetId, String componentId, int slotIndex, dynamic value) async { final index = state.indexWhere((sheet) => sheet.id == flowsheetId); if (index >= 0) { final updatedState = List<Flowsheet>.from(state); updatedState[index].updatePortValue(componentId, slotIndex, value); state = updatedState; await _storageService.saveFlowsheet(updatedState[index]); } } void setActiveFlowsheet(String id) { final exists = state.any((sheet) => sheet.id == id); if (exists) { _activeFlowsheetId = id; } else if (state.isNotEmpty) { _activeFlowsheetId = state.first.id; } else { _activeFlowsheetId = null; } } Future<Flowsheet> createFlowsheet(String name) async { final flowsheet = await _storageService.createFlowsheet(name); state = [...state, flowsheet]; _activeFlowsheetId = flowsheet.id; return flowsheet; } Future<bool> deleteFlowsheet(String id) async { final success = await _storageService.deleteFlowsheet(id); if (success) { state = state.where((sheet) => sheet.id != id).toList(); if (_activeFlowsheetId == id) { _activeFlowsheetId = state.isNotEmpty ? state.first.id : null; } } return success; } Future<bool> renameFlowsheet(String id, String newName) async { final updatedFlowsheet = await _storageService.renameFlowsheet(id, newName); if (updatedFlowsheet != null) { state = state .map((sheet) => sheet.id == id ? updatedFlowsheet : sheet) .toList(); return true; } return false; } Future<Flowsheet?> duplicateFlowsheet(String id, String newName) async { final duplicatedFlowsheet = await _storageService.duplicateFlowsheet(id, newName); if (duplicatedFlowsheet != null) { state = [...state, duplicatedFlowsheet]; _activeFlowsheetId = duplicatedFlowsheet.id; return duplicatedFlowsheet; } return null; } Future<void> addFlowsheetComponent( String flowsheetId, Component component) async { final index = state.indexWhere((sheet) => sheet.id == flowsheetId); if (index >= 0) { final updatedState = List<Flowsheet>.from(state); updatedState[index].addComponent(component); state = updatedState; await _storageService.saveFlowsheet(updatedState[index]); } } Future<void> updateFlowsheetComponent(String flowsheetId, String componentId, Component updatedComponent) async { final index = state.indexWhere((sheet) => sheet.id == flowsheetId); if (index >= 0) { final updatedState = List<Flowsheet>.from(state); updatedState[index].updateComponent(componentId, updatedComponent); state = updatedState; await _storageService.saveFlowsheet(updatedState[index]); } } Future<void> removeFlowsheetComponent( String flowsheetId, String componentId) async { final index = state.indexWhere((sheet) => sheet.id == flowsheetId); if (index >= 0) { final updatedState = List<Flowsheet>.from(state); updatedState[index].removeComponent(componentId); state = updatedState; await _storageService.saveFlowsheet(updatedState[index]); } } Future<void> addConnection(String flowsheetId, Connection connection) async { final index = state.indexWhere((sheet) => sheet.id == flowsheetId); if (index >= 0) { final updatedState = List<Flowsheet>.from(state); updatedState[index].addConnection(connection); state = updatedState; await _storageService.saveFlowsheet(updatedState[index]); } } Future<void> removeConnection(String flowsheetId, String fromComponentId, int fromPortIndex, String toComponentId, int toPortIndex) async { final index = state.indexWhere((sheet) => sheet.id == flowsheetId); if (index >= 0) { final updatedState = List<Flowsheet>.from(state); updatedState[index].removeConnection( fromComponentId, fromPortIndex, toComponentId, toPortIndex); state = updatedState; await _storageService.saveFlowsheet(updatedState[index]); } } Future<void> updateCanvasSize(String flowsheetId, Size newSize) async { final index = state.indexWhere((sheet) => sheet.id == flowsheetId); if (index >= 0) { final updatedState = List<Flowsheet>.from(state); updatedState[index].updateCanvasSize(newSize); state = updatedState; await _storageService.saveFlowsheet(updatedState[index]); } } Future<void> updateCanvasOffset(String flowsheetId, Offset newOffset) async { final index = state.indexWhere((sheet) => sheet.id == flowsheetId); if (index >= 0) { final updatedState = List<Flowsheet>.from(state); updatedState[index].updateCanvasOffset(newOffset); state = updatedState; await _storageService.saveFlowsheet(updatedState[index]); } } Future<void> updateFlowsheet( String flowsheetId, Flowsheet updatedFlowsheet) async { final index = state.indexWhere((sheet) => sheet.id == flowsheetId); if (index >= 0) { final updatedState = List<Flowsheet>.from(state); updatedState[index] = updatedFlowsheet; state = updatedState; await _storageService.saveFlowsheet(updatedFlowsheet); } } Future<void> saveFlowsheet(String flowsheetId) async { final index = state.indexWhere((sheet) => sheet.id == flowsheetId); if (index >= 0) { await _storageService.saveFlowsheet(state[index]); } } Future<void> saveActiveFlowsheet() async { if (_activeFlowsheetId != null) { final flowsheet = activeFlowsheet; if (flowsheet != null) { await _storageService.saveFlowsheet(flowsheet); } } } static Future<void> saveFlowsheetFromProvider( WidgetRef ref, String flowsheetId) async { await ref.read(flowsheetsProvider.notifier).saveFlowsheet(flowsheetId); } } final flowsheetStorageServiceProvider = Provider<FlowsheetStorageService>((ref) { return FlowsheetStorageService(); }); final flowsheetsProvider = StateNotifierProvider<FlowsheetsNotifier, List<Flowsheet>>((ref) { return FlowsheetsNotifier( storageService: ref.watch(flowsheetStorageServiceProvider), ); }); final activeFlowsheetProvider = Provider<Flowsheet?>((ref) { final notifier = ref.watch(flowsheetsProvider.notifier); return notifier.activeFlowsheet; }); 

// File: \lib\providers\group_polling_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart'; import '../services/group_polling_service.dart'; import '../models/helvar_models/workgroup.dart'; import '../models/helvar_models/helvar_group.dart'; import 'router_connection_provider.dart'; import 'workgroups_provider.dart'; import '../utils/logger.dart'; final groupPollingServiceProvider = Provider<GroupPollingService>((ref) { final commandService = ref.watch(routerCommandServiceProvider); final pollingService = GroupPollingService(commandService); pollingService.onGroupPowerUpdated = (updatedGroup) { ref.read(workgroupsProvider.notifier).updateGroupFromPolling(updatedGroup); }; ref.onDispose(() { pollingService.dispose(); }); return pollingService; }); final pollingStateProvider = StateNotifierProvider<PollingStateNotifier, Map<String, bool>>((ref) { return PollingStateNotifier(ref); }); class PollingStateNotifier extends StateNotifier<Map<String, bool>> { final Ref _ref; PollingStateNotifier(this._ref) : super({}) { _ref.listen<List<Workgroup>>(workgroupsProvider, (previous, next) { _handleWorkgroupChanges(previous ?? [], next); }); } void _handleWorkgroupChanges( List<Workgroup> previous, List<Workgroup> current, ) { final pollingService = _ref.read(groupPollingServiceProvider); for (final workgroup in current) { final previousWorkgroup = previous.firstWhere( (wg) => wg.id == workgroup.id, orElse: () => workgroup, ); if (previousWorkgroup.pollEnabled != workgroup.pollEnabled) { if (workgroup.pollEnabled) { startPolling(workgroup.id); } else { stopPolling(workgroup.id); } } if (workgroup.pollEnabled && !isPolling(workgroup.id)) { startPolling(workgroup.id); } } final currentIds = current.map((wg) => wg.id).toSet(); final previousIds = previous.map((wg) => wg.id).toSet(); final removedIds = previousIds.difference(currentIds); for (final removedId in removedIds) { stopPolling(removedId); } } void startPolling(String workgroupId) { final workgroups = _ref.read(workgroupsProvider); final workgroup = workgroups.firstWhere( (wg) => wg.id == workgroupId, orElse: () => throw StateError('Workgroup not found: $workgroupId'), ); if (!workgroup.pollEnabled) { logWarning( 'Attempted to start polling for workgroup with polling disabled: ${workgroup.description}', ); return; } final pollingService = _ref.read(groupPollingServiceProvider); pollingService.startWorkgroupPolling(workgroup); state = {...state, workgroupId: true}; logInfo('Started polling for workgroup: ${workgroup.description}'); } void stopPolling(String workgroupId) { final pollingService = _ref.read(groupPollingServiceProvider); pollingService.stopWorkgroupPolling(workgroupId); state = {...state, workgroupId: false}; logInfo('Stopped polling for workgroup: $workgroupId'); } void togglePolling(String workgroupId) { if (isPolling(workgroupId)) { stopPolling(workgroupId); } else { startPolling(workgroupId); } } bool isPolling(String workgroupId) { return state[workgroupId] ?? false; } void updateGroupPolling(String workgroupId, HelvarGroup group) { if (!isPolling(workgroupId)) return; final workgroups = _ref.read(workgroupsProvider); final workgroup = workgroups.firstWhere( (wg) => wg.id == workgroupId, orElse: () => throw StateError('Workgroup not found: $workgroupId'), ); final pollingService = _ref.read(groupPollingServiceProvider); pollingService.updateGroupPolling(workgroup, group); } void initializePolling() { final workgroups = _ref.read(workgroupsProvider); for (final workgroup in workgroups) { if (workgroup.pollEnabled) { startPolling(workgroup.id); } } } } 

// File: \lib\providers\project_settings_provider.dart
import 'dart:convert'; import 'dart:io'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import '../models/project_settings.dart'; import '../services/app_directory_service.dart'; import '../utils/logger.dart'; class ProjectSettingsNotifier extends StateNotifier<ProjectSettings> { final AppDirectoryService _directoryService = AppDirectoryService(); static const String _settingsFileName = 'project_settings.json'; ProjectSettingsNotifier() : super(ProjectSettings()) { _loadSettings(); } Future<void> _loadSettings() async { try { final filePath = await _directoryService.getSettingsFilePath(_settingsFileName); final file = File(filePath); if (await file.exists()) { final jsonString = await file.readAsString(); final json = jsonDecode(jsonString); state = ProjectSettings.fromJson(json); } } catch (e) { logError('Error loading project settings: $e'); } } Future<void> _saveSettings() async { try { final filePath = await _directoryService.getSettingsFilePath(_settingsFileName); final file = File(filePath); final jsonString = jsonEncode(state.toJson()); await file.writeAsString(jsonString); logInfo('Project settings saved to: $filePath'); } catch (e) { logError('Error saving project settings: $e'); } } Future<void> setProjectName(String name) async { state = state.copyWith(projectName: name); await _saveSettings(); } Future<void> setSocketTimeout(int timeoutMs) async { state = state.copyWith(socketTimeoutMs: timeoutMs); await _saveSettings(); } Future<void> setAutoSave(bool enabled) async { state = state.copyWith(autoSave: enabled); await _saveSettings(); } Future<void> setAutoSaveInterval(int minutes) async { state = state.copyWith(autoSaveIntervalMinutes: minutes); await _saveSettings(); } Future<String?> createSettingsBackup() async { try { return _directoryService.createBackup( AppDirectoryService.settingsDir, _settingsFileName); } catch (e) { logError('Error creating project settings backup: $e'); return null; } } Future<bool> restoreSettingsFromBackup(String backupFileName) async { try { final backupFilePath = await _directoryService.getBackupFilePath(backupFileName); final backupFile = File(backupFilePath); if (!await backupFile.exists()) { return false; } final jsonString = await backupFile.readAsString(); final json = jsonDecode(jsonString); state = ProjectSettings.fromJson(json); await _saveSettings(); return true; } catch (e) { logError('Error restoring project settings from backup: $e'); return false; } } Future<void> setCommandTimeout(int timeoutMs) async { state = state.copyWith(commandTimeoutMs: timeoutMs); await _saveSettings(); } Future<void> setHeartbeatInterval(int seconds) async { state = state.copyWith(heartbeatIntervalSeconds: seconds); await _saveSettings(); } Future<void> setMaxCommandRetries(int retries) async { state = state.copyWith(maxCommandRetries: retries); await _saveSettings(); } Future<void> setMaxConcurrentCommands(int maxCommands) async { state = state.copyWith(maxConcurrentCommandsPerRouter: maxCommands); await _saveSettings(); } Future<void> setCommandHistorySize(int size) async { state = state.copyWith(commandHistorySize: size); await _saveSettings(); } Future<void> setProtocolVersion(int version) async { state = state.copyWith(protocolVersion: version); await _saveSettings(); } } final protocolVersionProvider = Provider<int>((ref) { return ref.watch(projectSettingsProvider).protocolVersion; }); final projectSettingsProvider = StateNotifierProvider<ProjectSettingsNotifier, ProjectSettings>((ref) { return ProjectSettingsNotifier(); }); final projectNameProvider = Provider<String>((ref) { return ref.watch(projectSettingsProvider).projectName; }); final socketTimeoutProvider = Provider<int>((ref) { return ref.watch(projectSettingsProvider).socketTimeoutMs; }); final autoSaveEnabledProvider = Provider<bool>((ref) { return ref.watch(projectSettingsProvider).autoSave; }); final autoSaveIntervalProvider = Provider<int>((ref) { return ref.watch(projectSettingsProvider).autoSaveIntervalMinutes; }); final commandTimeoutProvider = Provider<int>((ref) { return ref.watch(projectSettingsProvider).commandTimeoutMs; }); final heartbeatIntervalProvider = Provider<int>((ref) { return ref.watch(projectSettingsProvider).heartbeatIntervalSeconds; }); final maxCommandRetriesProvider = Provider<int>((ref) { return ref.watch(projectSettingsProvider).maxCommandRetries; }); final maxConcurrentCommandsProvider = Provider<int>((ref) { return ref.watch(projectSettingsProvider).maxConcurrentCommandsPerRouter; }); final commandHistorySizeProvider = Provider<int>((ref) { return ref.watch(projectSettingsProvider).commandHistorySize; }); 

// File: \lib\providers\router_connection_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/services/device_query_service.dart'; import 'package:grms_designer/services/scene_query_service.dart'; import '../comm/models/command_models.dart'; import '../comm/models/connection_config.dart'; import '../comm/router_command_service.dart'; import '../comm/router_connection.dart'; import '../comm/router_connection_manager.dart'; import '../comm/models/router_connection_status.dart'; import '../services/connection_service.dart'; import '../services/discovery_service.dart'; import 'project_settings_provider.dart'; final connectionConfigProvider = Provider<ConnectionConfig>((ref) { final settings = ref.watch(projectSettingsProvider); return ConnectionConfig.fromProjectSettings(settings); }); final routerConnectionManagerProvider = Provider<RouterConnectionManager>(( ref, ) { final config = ref.watch(connectionConfigProvider); return RouterConnectionManager(config); }); final routerCommandServiceProvider = Provider<RouterCommandService>((ref) { final connectionManager = ref.watch(routerConnectionManagerProvider); final config = ref.watch(connectionConfigProvider); return RouterCommandService(connectionManager, config); }); final routerConnectionsProvider = Provider<Map<String, RouterConnection>>(( ref, ) { final manager = ref.watch(routerConnectionManagerProvider); return manager.connections; }); final routerConnectionStatusStreamProvider = StreamProvider<RouterConnectionStatus>((ref) { final manager = ref.watch(routerConnectionManagerProvider); return manager.connectionStatusStream; }); final commandHistoryProvider = Provider<List<QueuedCommand>>((ref) { final service = ref.watch(routerCommandServiceProvider); return service.commandHistory; }); final discoveryServiceProvider = Provider<DiscoveryService>((ref) { final commandService = ref.watch(routerCommandServiceProvider); return DiscoveryService(commandService); }); final connectionServiceProvider = Provider<ConnectionService>((ref) { final manager = ref.watch(routerConnectionManagerProvider); return ConnectionService(manager); }); final deviceQueryServiceProvider = Provider<DeviceQueryService>((ref) { final commandService = ref.watch(routerCommandServiceProvider); return DeviceQueryService(commandService); }); final sceneQueryServiceProvider = Provider<SceneQueryService>((ref) { final commandService = ref.watch(routerCommandServiceProvider); return SceneQueryService(commandService); }); 

// File: \lib\providers\settings_provider.dart
import 'dart:convert'; import 'dart:io'; import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import '../services/app_directory_service.dart'; import '../utils/logger.dart'; class AppSettings { final ThemeMode themeMode; final int discoveryTimeoutMs; final bool autoSaveEnabled; final int autoSaveIntervalMinutes; final String defaultExportDirectory; const AppSettings({ this.themeMode = ThemeMode.system, this.discoveryTimeoutMs = 10000, this.autoSaveEnabled = true, this.autoSaveIntervalMinutes = 5, this.defaultExportDirectory = '', }); AppSettings copyWith({ ThemeMode? themeMode, int? discoveryTimeoutMs, bool? autoSaveEnabled, int? autoSaveIntervalMinutes, String? defaultExportDirectory, }) { return AppSettings( themeMode: themeMode ?? this.themeMode, discoveryTimeoutMs: discoveryTimeoutMs ?? this.discoveryTimeoutMs, autoSaveEnabled: autoSaveEnabled ?? this.autoSaveEnabled, autoSaveIntervalMinutes: autoSaveIntervalMinutes ?? this.autoSaveIntervalMinutes, defaultExportDirectory: defaultExportDirectory ?? this.defaultExportDirectory, ); } Map<String, dynamic> toJson() { return { 'themeMode': themeMode.index, 'discoveryTimeoutMs': discoveryTimeoutMs, 'autoSaveEnabled': autoSaveEnabled, 'autoSaveIntervalMinutes': autoSaveIntervalMinutes, 'defaultExportDirectory': defaultExportDirectory, }; } factory AppSettings.fromJson(Map<String, dynamic> json) { return AppSettings( themeMode: ThemeMode.values[json['themeMode'] as int? ?? ThemeMode.system.index], discoveryTimeoutMs: json['discoveryTimeoutMs'] as int? ?? 10000, autoSaveEnabled: json['autoSaveEnabled'] as bool? ?? true, autoSaveIntervalMinutes: json['autoSaveIntervalMinutes'] as int? ?? 5, defaultExportDirectory: json['defaultExportDirectory'] as String? ?? '', ); } } class SettingsNotifier extends StateNotifier<AppSettings> { final AppDirectoryService _directoryService = AppDirectoryService(); static const String _settingsFileName = 'app_settings.json'; SettingsNotifier() : super(const AppSettings()) { _loadSettings(); } Future<void> _loadSettings() async { try { final filePath = await _directoryService.getSettingsFilePath(_settingsFileName); final file = File(filePath); if (await file.exists()) { final jsonString = await file.readAsString(); final json = jsonDecode(jsonString); state = AppSettings.fromJson(json); } } catch (e) { logError('Error loading settings: $e'); } } Future<void> _saveSettings() async { try { final filePath = await _directoryService.getSettingsFilePath(_settingsFileName); final file = File(filePath); final jsonString = jsonEncode(state.toJson()); await file.writeAsString(jsonString); logInfo('Settings saved to: $filePath'); } catch (e) { logError('Error saving settings: $e'); } } Future<void> setThemeMode(ThemeMode mode) async { state = state.copyWith(themeMode: mode); await _saveSettings(); } Future<void> setDiscoveryTimeout(int timeoutMs) async { state = state.copyWith(discoveryTimeoutMs: timeoutMs); await _saveSettings(); } Future<void> setAutoSaveEnabled(bool enabled) async { state = state.copyWith(autoSaveEnabled: enabled); await _saveSettings(); } Future<void> setAutoSaveInterval(int minutes) async { state = state.copyWith(autoSaveIntervalMinutes: minutes); await _saveSettings(); } Future<void> setDefaultExportDirectory(String directory) async { state = state.copyWith(defaultExportDirectory: directory); await _saveSettings(); } Future<String?> createSettingsBackup() async { try { return _directoryService.createBackup( AppDirectoryService.settingsDir, _settingsFileName); } catch (e) { logError('Error creating settings backup: $e'); return null; } } Future<bool> restoreSettingsFromBackup(String backupFileName) async { try { final backupFilePath = await _directoryService.getBackupFilePath(backupFileName); final backupFile = File(backupFilePath); if (!await backupFile.exists()) { return false; } final jsonString = await backupFile.readAsString(); final json = jsonDecode(jsonString); state = AppSettings.fromJson(json); await _saveSettings(); return true; } catch (e) { logError('Error restoring settings from backup: $e'); return false; } } } final settingsProvider = StateNotifierProvider<SettingsNotifier, AppSettings>((ref) { return SettingsNotifier(); }); final themeModeProvider = Provider<ThemeMode>((ref) { return ref.watch(settingsProvider).themeMode; }); final discoveryTimeoutProvider = Provider<int>((ref) { return ref.watch(settingsProvider).discoveryTimeoutMs; }); final autoSaveEnabledProvider = Provider<bool>((ref) { return ref.watch(settingsProvider).autoSaveEnabled; }); final autoSaveIntervalProvider = Provider<int>((ref) { return ref.watch(settingsProvider).autoSaveIntervalMinutes; }); 

// File: \lib\providers\tree_expansion_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart'; class TreeExpansionState { final Set<String> expandedNodes; final Set<String> newlyAddedNodes; TreeExpansionState({ required this.expandedNodes, required this.newlyAddedNodes, }); TreeExpansionState copyWith({ Set<String>? expandedNodes, Set<String>? newlyAddedNodes, }) { return TreeExpansionState( expandedNodes: expandedNodes ?? this.expandedNodes, newlyAddedNodes: newlyAddedNodes ?? this.newlyAddedNodes, ); } } class TreeExpansionNotifier extends StateNotifier<TreeExpansionState> { TreeExpansionNotifier() : super(TreeExpansionState( expandedNodes: <String>{}, newlyAddedNodes: <String>{}, )); bool isNodeExpanded(String nodeId) { return state.expandedNodes.contains(nodeId); } void toggleNodeExpansion(String nodeId) { final newExpandedNodes = Set<String>.from(state.expandedNodes); if (newExpandedNodes.contains(nodeId)) { newExpandedNodes.remove(nodeId); } else { newExpandedNodes.add(nodeId); } state = state.copyWith(expandedNodes: newExpandedNodes); } void setNodeExpansion(String nodeId, bool expanded) { final newExpandedNodes = Set<String>.from(state.expandedNodes); if (expanded) { newExpandedNodes.add(nodeId); } else { newExpandedNodes.remove(nodeId); } state = state.copyWith(expandedNodes: newExpandedNodes); } void markNodesAsNewlyAdded(List<String> nodeIds) { final newNewlyAddedNodes = Set<String>.from(state.newlyAddedNodes); newNewlyAddedNodes.addAll(nodeIds); state = state.copyWith(newlyAddedNodes: newNewlyAddedNodes); } void clearNewlyAddedNodes() { state = state.copyWith(newlyAddedNodes: <String>{}); } void resetExpansionState() { state = TreeExpansionState( expandedNodes: <String>{}, newlyAddedNodes: <String>{}, ); } bool getInitialExpansionState(String nodeId) { if (state.newlyAddedNodes.contains(nodeId)) { return false; } return state.expandedNodes.contains(nodeId); } void updateMultipleNodes(Map<String, bool> nodeStates) { final newExpandedNodes = Set<String>.from(state.expandedNodes); nodeStates.forEach((nodeId, expanded) { if (expanded) { newExpandedNodes.add(nodeId); } else { newExpandedNodes.remove(nodeId); } }); state = state.copyWith(expandedNodes: newExpandedNodes); } } final treeExpansionProvider = StateNotifierProvider<TreeExpansionNotifier, TreeExpansionState>((ref) { return TreeExpansionNotifier(); }); 

// File: \lib\providers\workgroups_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart'; import '../models/helvar_models/helvar_group.dart'; import '../models/helvar_models/workgroup.dart'; import '../models/helvar_models/helvar_device.dart'; import '../services/file_storage_service.dart'; import '../services/router_storage_service.dart'; import '../utils/logger.dart'; import '../comm/models/command_models.dart'; import '../comm/router_command_service.dart'; import '../comm/router_connection.dart'; import '../comm/router_connection_manager.dart'; import 'router_connection_provider.dart'; import 'tree_expansion_provider.dart'; class WorkgroupsNotifier extends StateNotifier<List<Workgroup>> { final FileStorageService _fileStorageService; final RouterStorageService _routerStorageService; final RouterCommandService _commandService; final Ref _ref; bool _initialized = false; bool _disposed = false; WorkgroupsNotifier({ required FileStorageService fileStorageService, required RouterStorageService routerStorageService, required RouterCommandService commandService, required Ref ref, }) : _fileStorageService = fileStorageService, _routerStorageService = routerStorageService, _commandService = commandService, _ref = ref, super([]) { _initializeData(); } @override void dispose() { _disposed = true; super.dispose(); } Future<void> _initializeData() async { if (_initialized || _disposed) return; try { final workgroups = await _fileStorageService.loadWorkgroups(); if (_disposed) return; for (var workgroup in workgroups) { for (var router in workgroup.routers) { try { final devices = await _routerStorageService.loadRouterDevices( workgroup.id, router.address, ); if (_disposed) return; router.devices.clear(); router.devices.addAll(devices); } catch (e) { logError( 'Error loading devices for router ${router.description}: $e', ); } } } if (!_disposed) { state = workgroups; _initialized = true; } } catch (e) { logError('Error initializing workgroups: $e'); } } Future<RouterConnection?> getRouterConnection( String workgroupId, String routerAddress, ) async { try { final workgroup = state.firstWhere((wg) => wg.id == workgroupId); final router = workgroup.routers.firstWhere( (r) => r.address == routerAddress, ); if (router.ipAddress.isEmpty) { return null; } final connectionManager = RouterConnectionManager(); return await connectionManager.getConnection(router.ipAddress); } catch (e) { logError('Error getting router connection: $e'); return null; } } Future<CommandResult> sendRouterCommand( String workgroupId, String routerAddress, String command, { CommandPriority priority = CommandPriority.normal, }) async { try { final workgroup = state.firstWhere((wg) => wg.id == workgroupId); final router = workgroup.routers.firstWhere( (r) => r.address == routerAddress, ); if (router.ipAddress.isEmpty) { return CommandResult.failure('Router has no IP address', 0); } return await _commandService.sendCommand( router.ipAddress, command, priority: priority, ); } catch (e) { logError('Error sending router command: $e'); return CommandResult.failure(e.toString(), 0); } } Future<void> _saveToStorage() async { if (_disposed) return; try { await _fileStorageService.saveWorkgroups(state); if (_disposed) return; for (var workgroup in state) { for (var router in workgroup.routers) { try { await _routerStorageService.saveRouterDevices( workgroup.id, router.address, router.devices, ); if (_disposed) return; } catch (e) { logError( 'Error saving devices for router ${router.description}: $e', ); } } } } catch (e) { logError('Error saving workgroups: $e'); } } Future<void> addDeviceToRouter( String workgroupId, String routerAddress, HelvarDevice device, ) async { final newState = [...state]; final workgroupIndex = newState.indexWhere((wg) => wg.id == workgroupId); if (workgroupIndex >= 0) { final workgroup = newState[workgroupIndex]; final routerIndex = workgroup.routers.indexWhere( (router) => router.address == routerAddress, ); if (routerIndex >= 0) { final router = workgroup.routers[routerIndex]; router.addDevice(device); final deviceNodeId = '${workgroupId}_${routerAddress}_${device.address}'; _ref.read(treeExpansionProvider.notifier).markNodesAsNewlyAdded([ deviceNodeId, ]); state = newState; try { await _routerStorageService.saveRouterDevices( workgroupId, routerAddress, router.devices, ); } catch (e) { logError('Error saving devices for router ${router.description}: $e'); } try { await _fileStorageService.saveWorkgroups(state); } catch (e) { logError('Error saving workgroups: $e'); } } } } Future<void> addMultipleDevicesToRouter( String workgroupId, String routerAddress, List<HelvarDevice> devices, ) async { final newState = [...state]; final workgroupIndex = newState.indexWhere((wg) => wg.id == workgroupId); if (workgroupIndex >= 0) { final workgroup = newState[workgroupIndex]; final routerIndex = workgroup.routers.indexWhere( (router) => router.address == routerAddress, ); if (routerIndex >= 0) { final router = workgroup.routers[routerIndex]; final newDeviceNodeIds = devices .map( (device) => '${workgroupId}_${routerAddress}_${device.address}', ) .toList(); for (final device in devices) { router.addDevice(device); } _ref .read(treeExpansionProvider.notifier) .markNodesAsNewlyAdded(newDeviceNodeIds); state = newState; try { await _routerStorageService.saveRouterDevices( workgroupId, routerAddress, router.devices, ); } catch (e) { logError('Error saving devices for router ${router.description}: $e'); } try { await _fileStorageService.saveWorkgroups(state); } catch (e) { logError('Error saving workgroups: $e'); } } } } void addWorkgroup(Workgroup workgroup) { state = [...state, workgroup]; _saveToStorage(); } void removeWorkgroup(String id) { state = state.where((wg) => wg.id != id).toList(); _saveToStorage(); } void updateWorkgroup(Workgroup updatedWorkgroup) { state = state .map((wg) => wg.id == updatedWorkgroup.id ? updatedWorkgroup : wg) .toList(); _saveToStorage(); } void clearWorkgroups() { state = []; _saveToStorage(); } Future<void> removeDeviceFromRouter( String workgroupId, String routerAddress, HelvarDevice device, ) async { final newState = [...state]; final workgroupIndex = newState.indexWhere((wg) => wg.id == workgroupId); if (workgroupIndex >= 0) { final workgroup = newState[workgroupIndex]; final routerIndex = workgroup.routers.indexWhere( (router) => router.address == routerAddress, ); if (routerIndex >= 0) { final router = workgroup.routers[routerIndex]; router.removeDevice(device); state = newState; try { await _routerStorageService.saveRouterDevices( workgroupId, routerAddress, router.devices, ); } catch (e) { logError('Error saving devices for router ${router.description}: $e'); } try { await _fileStorageService.saveWorkgroups(state); } catch (e) { logError('Error saving workgroups: $e'); } } } } Future<void> updateDeviceInRouter( String workgroupId, String routerAddress, HelvarDevice oldDevice, HelvarDevice updatedDevice, ) async { final newState = [...state]; final workgroupIndex = newState.indexWhere((wg) => wg.id == workgroupId); if (workgroupIndex >= 0) { final workgroup = newState[workgroupIndex]; final routerIndex = workgroup.routers.indexWhere( (router) => router.address == routerAddress, ); if (routerIndex >= 0) { final router = workgroup.routers[routerIndex]; final deviceIndex = router.devices.indexOf(oldDevice); if (deviceIndex >= 0) { router.devices[deviceIndex] = updatedDevice; state = newState; try { await _routerStorageService.saveRouterDevices( workgroupId, routerAddress, router.devices, ); } catch (e) { logError( 'Error saving devices for router ${router.description}: $e', ); } try { await _fileStorageService.saveWorkgroups(state); } catch (e) { logError('Error saving workgroups: $e'); } } } } } Future<void> addGroupToWorkgroup( String workgroupId, HelvarGroup group, ) async { final index = state.indexWhere((wg) => wg.id == workgroupId); if (index >= 0) { final updatedState = List<Workgroup>.from(state); final workgroup = updatedState[index]; workgroup.addGroup(group); state = updatedState; await _saveToStorage(); } } Future<void> removeGroupFromWorkgroup( String workgroupId, HelvarGroup group, ) async { final index = state.indexWhere((wg) => wg.id == workgroupId); if (index >= 0) { final updatedState = List<Workgroup>.from(state); final workgroup = updatedState[index]; workgroup.removeGroup(group); state = updatedState; await _saveToStorage(); } } Future<void> exportWorkgroups(String filePath) async { await _fileStorageService.exportWorkgroups(state, filePath); } Future<void> importWorkgroups(String filePath, {bool merge = false}) async { final importedWorkgroups = await _fileStorageService.importWorkgroups( filePath, ); if (merge) { final List<Workgroup> newState = [...state]; for (final importedWg in importedWorkgroups) { final existingIndex = newState.indexWhere( (wg) => wg.id == importedWg.id, ); if (existingIndex >= 0) { newState[existingIndex] = importedWg; } else { newState.add(importedWg); } } state = newState; } else { state = importedWorkgroups; } for (var workgroup in state) { for (var router in workgroup.routers) { try { await _routerStorageService.saveRouterDevices( workgroup.id, router.address, router.devices, ); } catch (e) { logError('Error saving devices for router ${router.description}: $e'); } } } try { await _fileStorageService.saveWorkgroups(state); } catch (e) { logError('Error saving workgroups: $e'); } } Future<void> updateGroup(String workgroupId, HelvarGroup updatedGroup) async { final index = state.indexWhere((wg) => wg.id == workgroupId); if (index >= 0) { final updatedState = List<Workgroup>.from(state); final workgroup = updatedState[index]; final groupIndex = workgroup.groups.indexWhere( (g) => g.id == updatedGroup.id, ); if (groupIndex >= 0) { workgroup.groups[groupIndex] = updatedGroup; state = updatedState; await _saveToStorage(); } } } Future<void> updateGroupFromPolling(HelvarGroup updatedGroup) async { if (_disposed) return; try { final newState = [...state]; bool groupFound = false; for ( int workgroupIndex = 0; workgroupIndex < newState.length; workgroupIndex++ ) { final workgroup = newState[workgroupIndex]; final groupIndex = workgroup.groups.indexWhere( (g) => g.id == updatedGroup.id, ); if (groupIndex >= 0) { workgroup.groups[groupIndex] = updatedGroup; groupFound = true; break; } } if (groupFound) { state = newState; logDebug( 'Updated group ${updatedGroup.groupId} from polling: ${updatedGroup.powerConsumption}W', ); } else { logWarning( 'Group ${updatedGroup.groupId} not found for polling update', ); } } catch (e) { logError('Error updating group from polling: $e'); } } Future<void> toggleWorkgroupPolling(String workgroupId, bool enabled) async { if (_disposed) return; try { final newState = [...state]; final workgroupIndex = newState.indexWhere((wg) => wg.id == workgroupId); if (workgroupIndex >= 0) { final updatedWorkgroup = newState[workgroupIndex].copyWith( pollEnabled: enabled, lastPollTime: enabled ? DateTime.now() : null, ); newState[workgroupIndex] = updatedWorkgroup; state = newState; await _saveToStorage(); logInfo( '${enabled ? 'Enabled' : 'Disabled'} polling for workgroup: ${updatedWorkgroup.description}', ); } } catch (e) { logError('Error toggling workgroup polling: $e'); } } } final fileStorageServiceProvider = Provider<FileStorageService>((ref) { return FileStorageService(); }); final routerStorageServiceProvider = Provider<RouterStorageService>((ref) { return RouterStorageService(); }); final workgroupsProvider = StateNotifierProvider<WorkgroupsNotifier, List<Workgroup>>((ref) { return WorkgroupsNotifier( fileStorageService: ref.watch(fileStorageServiceProvider), routerStorageService: ref.watch(routerStorageServiceProvider), commandService: ref.watch(routerCommandServiceProvider), ref: ref, ); }); 

// File: \lib\screens\actions.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/extensions/device_address_extensions.dart'; import 'package:grms_designer/extensions/group_extensions.dart'; import 'package:grms_designer/providers/project_settings_provider.dart'; import 'package:grms_designer/utils/general_ui.dart'; import 'package:grms_designer/utils/logger.dart'; import '../comm/models/command_models.dart'; import '../models/helvar_models/helvar_device.dart'; import '../models/helvar_models/helvar_group.dart'; import '../models/helvar_models/helvar_router.dart'; import '../models/helvar_models/workgroup.dart'; import '../protocol/query_commands.dart'; import '../providers/router_connection_provider.dart'; import '../providers/workgroups_provider.dart'; import 'dialogs/action_dialogs.dart'; String getWorkgroupIdForDevice(BuildContext context, HelvarDevice device) { final container = ProviderScope.containerOf(context); final workgroups = container.read(workgroupsProvider); for (final workgroup in workgroups) { for (final router in workgroup.routers) { for (final routerDevice in router.devices) { if (routerDevice.address == device.address) { return workgroup.id; } } } } return workgroups.isNotEmpty ? workgroups.first.id : "1"; } void performRecallScene( BuildContext context, HelvarGroup group, int sceneNumber) { final container = ProviderScope.containerOf(context); final commandService = container.read(routerCommandServiceProvider); final workgroups = container.read(workgroupsProvider); Workgroup? workgroup; for (final wg in workgroups) { if (wg.groups.any((g) => g.id == group.id)) { workgroup = wg; break; } } if (workgroup == null) { logWarning('Workgroup not found for this group'); return; } final groupId = int.tryParse(group.groupId); if (groupId == null) { logWarning('Invalid group ID: ${group.groupId}'); return; } final routerIpAddress = group.resolveRouterIp(workgroup); if (routerIpAddress.isEmpty) { logWarning('No router IP address available for this group'); return; } final command = HelvarNetCommands.recallSceneGroup( groupId, 1, sceneNumber, fadeTime: 700, ); commandService .sendCommand( routerIpAddress, command, priority: CommandPriority.normal, ) .then((result) { if (result.success) { logInfo('Recalled scene $sceneNumber for group ${group.groupId}'); } else { logError('Failed to send command to group: ${result.errorMessage}'); } }).catchError((error) { logError('Connection error: $error'); }); } void performStoreScene( BuildContext context, HelvarGroup group, int sceneNumber) { final container = ProviderScope.containerOf(context); final commandService = container.read(routerCommandServiceProvider); final workgroups = container.read(workgroupsProvider); Workgroup? workgroup; for (final wg in workgroups) { if (wg.groups.any((g) => g.id == group.id)) { workgroup = wg; break; } } if (workgroup == null) { logWarning('Workgroup not found for this group'); return; } final groupId = int.tryParse(group.groupId); if (groupId == null) { logWarning('Invalid group ID: ${group.groupId}'); return; } final routerIpAddress = group.resolveRouterIp(workgroup); if (routerIpAddress.isEmpty) { logWarning('No router IP address available for this group'); return; } final command = HelvarNetCommands.storeAsSceneGroup( groupId, 1,  sceneNumber, forceStore: true,  ); commandService .sendCommand( routerIpAddress, command, priority: CommandPriority.normal, ) .then((result) { if (result.success) { logInfo('Stored scene $sceneNumber for group ${group.groupId}'); } else { logWarning('Failed to send command to group'); } }); } void performDirectLevel(BuildContext context, HelvarGroup group, int level) { final container = ProviderScope.containerOf(context); final commandService = container.read(routerCommandServiceProvider); final workgroups = container.read(workgroupsProvider); Workgroup? workgroup; for (final wg in workgroups) { if (wg.groups.any((g) => g.id == group.id)) { workgroup = wg; break; } } if (workgroup == null) { logWarning('Workgroup not found for this group'); return; } final groupId = int.tryParse(group.groupId); if (groupId == null) { logWarning('Invalid group ID: ${group.groupId}'); return; } final routerIpAddress = group.resolveRouterIp(workgroup); if (routerIpAddress.isEmpty) { logWarning('No router IP address available for this group'); return; } final command = HelvarNetCommands.directLevelGroup( groupId, level, fadeTime: 700,  ); commandService.sendCommand(routerIpAddress, command).then((result) { if (result.success) { showSnackBarMsg( context, 'Set direct level $level for group ${group.groupId}'); } else { showSnackBarMsg( context, 'Command failed: ${result.errorMessage ?? "Unknown"}'); } }).catchError((error) { logError('Connection error: $error'); }); } void performDirectProportion( BuildContext context, HelvarGroup group, int proportion) { final container = ProviderScope.containerOf(context); final commandService = container.read(routerCommandServiceProvider); final workgroups = container.read(workgroupsProvider); Workgroup? workgroup; for (final wg in workgroups) { if (wg.groups.any((g) => g.id == group.id)) { workgroup = wg; break; } } if (workgroup == null) { logWarning('Workgroup not found for this group'); return; } final groupId = int.tryParse(group.groupId); if (groupId == null) { logWarning('Invalid group ID: ${group.groupId}'); return; } final routerIpAddress = group.resolveRouterIp(workgroup); if (routerIpAddress.isEmpty) { logWarning('No router IP address available for this group'); return; } final command = HelvarNetCommands.directProportionGroup( groupId, proportion, fadeTime: 700,  ); commandService.sendCommand(routerIpAddress, command).then((result) { if (result.success) { showSnackBarMsg(context, 'Set direct proportion $proportion for group ${group.groupId}'); } else { logWarning('Failed to send command to group'); } }).catchError((error) { logError('Connection error: $error'); }); } void performModifyProportion( BuildContext context, HelvarGroup group, int proportion) { final container = ProviderScope.containerOf(context); final commandService = container.read(routerCommandServiceProvider); final workgroups = container.read(workgroupsProvider); Workgroup? workgroup; for (final wg in workgroups) { if (wg.groups.any((g) => g.id == group.id)) { workgroup = wg; break; } } if (workgroup == null) { logWarning('Workgroup not found for this group'); return; } final groupId = int.tryParse(group.groupId); if (groupId == null) { logWarning('Invalid group ID: ${group.groupId}'); return; } final routerIpAddress = group.resolveRouterIp(workgroup); if (routerIpAddress.isEmpty) { logWarning('No router IP address available for this group'); return; } final command = HelvarNetCommands.modifyProportionGroup( groupId, proportion, fadeTime: 700,  ); commandService.sendCommand(routerIpAddress, command).then((result) { if (result.success) { showSnackBarMsg(context, 'Modified proportion by $proportion for group ${group.groupId}'); } else { logWarning('Failed to send command to group'); } }).catchError((error) { logError('Connection error: $error'); }); } void performEmergencyFunctionTest( BuildContext context, HelvarGroup group, Workgroup workgroup) { final container = ProviderScope.containerOf(context); final commandService = container.read(routerCommandServiceProvider); final groupId = int.tryParse(group.groupId); if (groupId == null) { logWarning('Invalid group ID: ${group.groupId}'); return; } final routerIpAddress = group.resolveRouterIp(workgroup); if (routerIpAddress.isEmpty) { logWarning('No router IP address available for this group'); return; } final command = HelvarNetCommands.emergencyFunctionTestGroup( groupId, ); commandService.sendCommand(routerIpAddress, command).then((result) { if (result.success) { showSnackBarMsg(context, 'Started emergency function test for group ${group.groupId}'); } else { logWarning('Failed to send command to group'); } }).catchError((error) { logError('Connection error: $error'); }); } void performEmergencyDurationTest( BuildContext context, HelvarGroup group, Workgroup workgroup) { final container = ProviderScope.containerOf(context); final commandService = container.read(routerCommandServiceProvider); final groupId = int.tryParse(group.groupId); if (groupId == null) { logWarning('Invalid group ID: ${group.groupId}'); return; } final routerIpAddress = group.resolveRouterIp(workgroup); if (routerIpAddress.isEmpty) { logWarning('No router IP address available for this group'); return; } final command = HelvarNetCommands.emergencyDurationTestGroup( groupId, ); commandService.sendCommand(routerIpAddress, command).then((result) { if (result.success) { showSnackBarMsg(context, 'Started emergency duration test for group ${group.groupId}'); } else { logWarning('Failed to send command to group'); } }).catchError((error) { logError('Connection error: $error'); }); } void stopEmergencyTest( BuildContext context, HelvarGroup group, Workgroup workgroup) { final container = ProviderScope.containerOf(context); final commandService = container.read(routerCommandServiceProvider); final groupId = int.tryParse(group.groupId); if (groupId == null) { logWarning('Invalid group ID: ${group.groupId}'); return; } final routerIpAddress = group.resolveRouterIp(workgroup); if (routerIpAddress.isEmpty) { logWarning('No router IP address available for this group'); return; } final command = HelvarNetCommands.stopEmergencyTestsGroup( groupId, ); commandService.sendCommand(routerIpAddress, command).then((result) { if (result.success) { showSnackBarMsg( context, 'Stopped emergency tests for group ${group.groupId}'); } else { logWarning('Failed to send command to group'); } }).catchError((error) { logError('Connection error: $error'); }); } void resetEmergencyBatteryTotalLampTime( BuildContext context, HelvarGroup group, Workgroup workgroup) { final container = ProviderScope.containerOf(context); final commandService = container.read(routerCommandServiceProvider); final groupId = int.tryParse(group.groupId); if (groupId == null) { logWarning('Invalid group ID: ${group.groupId}'); return; } final routerIpAddress = group.resolveRouterIp(workgroup); if (routerIpAddress.isEmpty) { logWarning('No router IP address available for this group'); return; } final command = HelvarNetCommands.resetEmergencyBatteryAndTotalLampTimeGroup( groupId, ); commandService.sendCommand(routerIpAddress, command).then((result) { if (result.success) { logInfo( 'Reset emergency battery and total lamp time for group ${group.groupId}'); } else { logWarning('Failed to send command to group'); } }).catchError((error) { logError('Connection error: $error'); }); } void refreshGroupProperties( BuildContext context, HelvarGroup group, Workgroup workgroup) { final container = ProviderScope.containerOf(context); final commandService = container.read(routerCommandServiceProvider); final settingsProvider = container.read(projectSettingsProvider); final groupId = int.tryParse(group.groupId); if (groupId == null) { logWarning('Invalid group ID: ${group.groupId}'); return; } final descriptionCommand = HelvarNetCommands.queryDescriptionGroup( groupId, ); final routerIpAddress = group.resolveRouterIp(workgroup); if (routerIpAddress.isEmpty) { logWarning('No router IP address available for this group'); return; } commandService .sendCommand( routerIpAddress, descriptionCommand, timeout: Duration(milliseconds: settingsProvider.commandTimeoutMs), ) .then((result) { if (result.success && result.response != null) { final response = result.response!; if (response.contains('=')) { final parts = response.split('='); if (parts.length > 1) { final description = parts[1].replaceAll('#', ''); final updatedGroup = group.copyWith( description: description, lastMessage: 'Group properties refreshed', lastMessageTime: DateTime.now(), ); final workgroupsNotifier = container.read(workgroupsProvider.notifier); workgroupsNotifier.updateGroup(workgroup.id, updatedGroup); showSnackBarMsg(context, 'Group properties refreshed'); } } } else { logWarning( 'Failed to refresh group properties: ${result.errorMessage ?? "No response"}'); } }).catchError((error) { logError('Connection error: $error'); }); } void performDeviceDirectLevel( BuildContext context, HelvarDevice device, int level) { final container = ProviderScope.containerOf(context); final commandService = container.read(routerCommandServiceProvider); final routerAddress = device.routerAddress; final workgroups = container.read(workgroupsProvider); Workgroup? workgroup; HelvarRouter? helvarRouter; for (final wg in workgroups) { for (final r in wg.routers) { if (r.address == routerAddress) { workgroup = wg; helvarRouter = r; break; } } if (workgroup != null) break; } if (workgroup == null || helvarRouter == null) { logWarning('Router not found for this device'); return; } final command = HelvarNetCommands.directLevelDevice( device.address, level, fadeTime: 700, ); commandService.sendCommand(helvarRouter.ipAddress, command).then((result) { if (result.success) { logInfo('Set level to $level for device ${device.deviceId}'); } else { logWarning('Failed to send command to router'); } }).catchError((error) { logError('Connection error: $error'); }); } void performDeviceRecallScene( BuildContext context, HelvarDevice device, int sceneNumber) { final container = ProviderScope.containerOf(context); final commandService = container.read(routerCommandServiceProvider); final workgroups = container.read(workgroupsProvider); Workgroup? workgroup; HelvarRouter? helvarRouter; for (final wg in workgroups) { for (final r in wg.routers) { if (r.address == device.routerAddress) { workgroup = wg; helvarRouter = r; break; } } if (workgroup != null) break; } if (workgroup == null || helvarRouter == null) { logWarning('Router not found for this device'); return; } final command = HelvarNetCommands.recallSceneDevice( device.cluster, device.router, device.subnet, device.device, 1,  sceneNumber, fadeTime: 700,  ); commandService.sendCommand(helvarRouter.ipAddress, command).then((result) { if (result.success) { showSnackBarMsg( context, 'Recalled scene $sceneNumber for device ${device.deviceId}'); } else { logWarning('Failed to send command to router'); } }).catchError((error) { logError('Connection error: $error'); }); } void performDeviceDirectProportion( BuildContext context, HelvarDevice device, int proportion) { final container = ProviderScope.containerOf(context); final commandService = container.read(routerCommandServiceProvider); final workgroups = container.read(workgroupsProvider); Workgroup? workgroup; HelvarRouter? helvarRouter; for (final wg in workgroups) { for (final r in wg.routers) { if (r.address == device.routerAddress) { workgroup = wg; helvarRouter = r; break; } } if (workgroup != null) break; } if (workgroup == null || helvarRouter == null) { logWarning('Router not found for this device'); return; } final command = HelvarNetCommands.directProportionDevice( device.cluster, device.router, device.subnet, device.device, proportion, fadeTime: 700, ); commandService.sendCommand(helvarRouter.ipAddress, command).then((result) { if (result.success) { showSnackBarMsg(context, 'Set proportion to $proportion for device ${device.deviceId}'); } else { logError('Failed to send command to router'); } }).catchError((error) { logError('Connection error: $error'); }); } void performDeviceModifyProportion( BuildContext context, HelvarDevice device, int proportion) { final container = ProviderScope.containerOf(context); final commandService = container.read(routerCommandServiceProvider); final workgroups = container.read(workgroupsProvider); Workgroup? workgroup; HelvarRouter? helvarRouter; for (final wg in workgroups) { for (final r in wg.routers) { if (r.address == device.routerAddress) { workgroup = wg; helvarRouter = r; break; } } if (workgroup != null) break; } if (workgroup == null || helvarRouter == null) { logWarning('Router not found for this device'); return; } final command = HelvarNetCommands.modifyProportionDevice( device.cluster, device.router, device.subnet, device.device, proportion, fadeTime: 700, ); commandService.sendCommand(helvarRouter.ipAddress, command).then((result) { if (result.success) { showSnackBarMsg(context, 'Modified proportion by $proportion for device ${device.deviceId}'); } else { logWarning('Failed to send command to device'); } }).catchError((error) { logError('Connection error: $error'); }); } void showGroupContextMenu( BuildContext context, HelvarGroup group, Workgroup workgroup) { final RenderBox button = context.findRenderObject() as RenderBox; final RenderBox overlay = Navigator.of(context).overlay!.context.findRenderObject() as RenderBox; final buttonBottomCenter = button.localToGlobal( Offset(300, button.size.height / 3), ancestor: overlay, ); final RelativeRect position = RelativeRect.fromRect( Rect.fromPoints( buttonBottomCenter, buttonBottomCenter + const Offset(1, 1)), Offset.zero & overlay.size, ); showMenu(context: context, position: position, items: [ PopupMenuItem( child: const Text('Recall Scene'), onTap: () => showRecallSceneDialog(context, group, workgroup), ), PopupMenuItem( child: const Text('Store Scene'), onTap: () => showStoreSceneDialog(context, group, workgroup), ), PopupMenuItem( child: const Text('Direct Level'), onTap: () => showDirectLevelDialog(context, group, workgroup), ), PopupMenuItem( child: const Text('Direct Proportion'), onTap: () => showDirectProportionDialog(context, group, workgroup), ), PopupMenuItem( child: const Text('Modify Proportion'), onTap: () => showModifyProportionDialog(context, group, workgroup), ), PopupMenuItem( child: const Text('Emergency Function Test'), onTap: () => performEmergencyFunctionTest(context, group, workgroup), ), PopupMenuItem( child: const Text('Emergency Duration Test'), onTap: () => performEmergencyDurationTest(context, group, workgroup), ), PopupMenuItem( child: const Text('Stop Emergency Test'), onTap: () => stopEmergencyTest(context, group, workgroup), ), PopupMenuItem( child: const Text('Reset Emergency Battery Total Lamp Time'), onTap: () => resetEmergencyBatteryTotalLampTime(context, group, workgroup), ), PopupMenuItem( child: const Text('Refresh Group Properties'), onTap: () => refreshGroupProperties(context, group, workgroup), ), ]); } 

// File: \lib\screens\details\device_detail_screen.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/utils/date_utils.dart'; import '../../models/helvar_models/helvar_device.dart'; import '../../models/helvar_models/helvar_router.dart'; import '../../models/helvar_models/workgroup.dart'; import '../../models/helvar_models/input_device.dart'; import '../../models/helvar_models/output_device.dart'; import '../../models/helvar_models/output_point.dart'; import '../../utils/device_icons.dart'; import '../../utils/general_ui.dart'; import '../../utils/treeview_utils.dart'; import '../../protocol/query_commands.dart'; import '../../protocol/protocol_parser.dart'; import '../../protocol/protocol_constants.dart'; import '../../providers/router_connection_provider.dart'; import '../../utils/logger.dart'; class DeviceDetailScreen extends ConsumerStatefulWidget { final Workgroup workgroup; final HelvarRouter router; final HelvarDevice device; final Function( String, { Workgroup? workgroup, HelvarRouter? router, HelvarDevice? device, ButtonPoint? point, })? onNavigate; const DeviceDetailScreen({ super.key, required this.workgroup, required this.router, required this.device, this.onNavigate, }); @override DeviceDetailScreenState createState() => DeviceDetailScreenState(); } class DeviceDetailScreenState extends ConsumerState<DeviceDetailScreen> { late TextEditingController _deviceIdController; late TextEditingController _addressController; final Map<int, bool> _expandedPoints = {}; @override void initState() { super.initState(); _deviceIdController = TextEditingController( text: widget.device.deviceId.toString(), ); _addressController = TextEditingController(text: widget.device.address); if (widget.device is HelvarDriverOutputDevice) { final outputDevice = widget.device as HelvarDriverOutputDevice; if (outputDevice.outputPoints.isEmpty) { outputDevice.generateOutputPoints(); } } } @override void dispose() { _deviceIdController.dispose(); _addressController.dispose(); super.dispose(); } @override Widget build(BuildContext context) { final deviceName = widget.device.description.isEmpty ? 'Device ${widget.device.deviceId}' : widget.device.description; return Scaffold( appBar: AppBar( title: Text('${widget.device.address} - $deviceName'), centerTitle: true, ), floatingActionButtonLocation: FloatingActionButtonLocation.endTop, floatingActionButton: ElevatedButton.icon( onPressed: () => _queryRealTimeStatus(), icon: const Icon(Icons.refresh, size: 16), label: const Text('Query Live Status'), ), body: SingleChildScrollView( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ _buildDeviceInfoCard(), const SizedBox(height: 16), _buildStaticStatusCard(), const SizedBox(height: 16), _buildPointsCard(), ], ), ), ); } Widget _buildDeviceInfoCard() { return Card( child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( children: [ CircleAvatar( backgroundImage: AssetImage( getDeviceIconAsset(widget.device), ), backgroundColor: Colors.transparent, radius: 20, ), const SizedBox(width: 16), Expanded( child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Padding( padding: const EdgeInsets.symmetric(vertical: 4.0), child: Row( crossAxisAlignment: CrossAxisAlignment.center, children: [ const SizedBox( width: 120, child: Text( 'Device ID:', style: TextStyle(fontWeight: FontWeight.w500), ), ), Expanded( child: TextFormField( controller: _deviceIdController, keyboardType: TextInputType.number, decoration: const InputDecoration( isDense: true, border: OutlineInputBorder(), contentPadding: EdgeInsets.symmetric( horizontal: 8, vertical: 8, ), ), onFieldSubmitted: (val) => _updateDeviceId(val), onChanged: (val) {}, ), ), ], ), ), Padding( padding: const EdgeInsets.symmetric(vertical: 4.0), child: Row( crossAxisAlignment: CrossAxisAlignment.center, children: [ const SizedBox( width: 120, child: Text( 'Address:', style: TextStyle(fontWeight: FontWeight.w500), ), ), Expanded( child: TextFormField( controller: _addressController, decoration: const InputDecoration( isDense: true, border: OutlineInputBorder(), contentPadding: EdgeInsets.symmetric( horizontal: 8, vertical: 8, ), ), onFieldSubmitted: (val) => _updateDeviceAddress(val), onChanged: (val) {}, ), ), ], ), ), ], ), ), ], ), const Divider(), buildInfoRow('Type', widget.device.helvarType), buildInfoRow('Props', widget.device.props), if (widget.device.deviceTypeCode != null) buildInfoRow( 'Type Code', '0x${widget.device.deviceTypeCode!.toRadixString(16)}', ), buildInfoRow('Emergency', widget.device.emergency ? 'Yes' : 'No'), buildInfoRow('Block ID', widget.device.blockId), if (widget.device.sceneId.isNotEmpty) buildInfoRow('Scene ID', widget.device.sceneId), ], ), ), ); } Widget _buildStaticStatusCard() { return Card( child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Text( 'Device Status', style: Theme.of(context).textTheme.titleMedium, ), ], ), const Divider(), if (widget.device.state.isNotEmpty) buildInfoRow('State', widget.device.state), if (widget.device.deviceStateCode != null) buildInfoRow( 'State Code', '0x${widget.device.deviceStateCode!.toRadixString(16)}', ), buildInfoRow( 'Button Device', widget.device.isButtonDevice ? 'Yes' : 'No', ), buildInfoRow( 'Multisensor', widget.device.isMultisensor ? 'Yes' : 'No', ), if (widget.device is HelvarDriverOutputDevice) ..._buildOutputDeviceStatus(), if (widget.device is HelvarDriverInputDevice) ..._buildInputDeviceStatus(), buildInfoRow('Last Updated', getLastUpdateTime()), ], ), ), ); } Widget _buildPointsCard() { bool hasPoints = false; int pointCount = 0; if (widget.device is HelvarDriverInputDevice) { final inputDevice = widget.device as HelvarDriverInputDevice; hasPoints = inputDevice.buttonPoints.isNotEmpty; pointCount = inputDevice.buttonPoints.length; } else if (widget.device is HelvarDriverOutputDevice) { final outputDevice = widget.device as HelvarDriverOutputDevice; hasPoints = outputDevice.outputPoints.isNotEmpty; pointCount = outputDevice.outputPoints.length; } if (!hasPoints) { return const SizedBox.shrink();  } return Card( child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Text( 'Points ($pointCount)', style: Theme.of(context).textTheme.titleMedium, ), Icon( Icons.radio_button_checked, color: widget.device is HelvarDriverInputDevice ? Colors.green : Colors.orange, ), ], ), const Divider(), if (widget.device is HelvarDriverInputDevice) ..._buildInputPointsList(), if (widget.device is HelvarDriverOutputDevice) ..._buildOutputPointsList(), ], ), ), ); } List<Widget> _buildInputPointsList() { final inputDevice = widget.device as HelvarDriverInputDevice; return inputDevice.buttonPoints .map((point) => _buildInputPointTile(point)) .toList(); } List<Widget> _buildOutputPointsList() { final outputDevice = widget.device as HelvarDriverOutputDevice; return outputDevice.outputPoints .map((point) => _buildOutputPointTile(point)) .toList(); } Widget _buildInputPointTile(ButtonPoint point) { final isExpanded = _expandedPoints[point.buttonId] ?? false; final inputDevice = widget.device as HelvarDriverInputDevice; return Column( children: [ ListTile( contentPadding: EdgeInsets.zero, leading: CircleAvatar( backgroundColor: _getInputPointColor( point, ).withValues(alpha: 0.2 * 255), radius: 16, child: Icon( getButtonPointIcon(point), color: _getInputPointColor(point), size: 16, ), ), title: Text( point.name, style: const TextStyle(fontWeight: FontWeight.w500), ), subtitle: Text('Function: ${point.function} • ID: ${point.buttonId}'), trailing: IconButton( icon: Icon( isExpanded ? Icons.expand_less : Icons.expand_more, size: 20, ), onPressed: () => _togglePointExpansion(point.buttonId), ), ), if (isExpanded) _buildInputPointDetails(point), if (inputDevice.buttonPoints.last != point) const Divider(height: 1), ], ); } Widget _buildOutputPointTile(OutputPoint point) { final isExpanded = _expandedPoints[point.pointId] ?? false; return Column( children: [ ListTile( contentPadding: EdgeInsets.zero, leading: CircleAvatar( backgroundColor: _getOutputPointColor( point, ).withValues(alpha: 0.2 * 255), radius: 16, child: Icon( getOutputPointIcon(point), color: _getOutputPointColor(point), size: 16, ), ), title: Text( point.function, style: const TextStyle(fontWeight: FontWeight.w500), ), subtitle: Row( children: [ Text('Type: ${point.pointType} • ID: ${point.pointId}'), const SizedBox(width: 8), Container( padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2), decoration: BoxDecoration( color: getOutputPointValueColor(point), borderRadius: BorderRadius.circular(10), ), child: Text( formatOutputPointValue(point), style: const TextStyle( fontSize: 10, color: Colors.white, fontWeight: FontWeight.bold, ), ), ), ], ), trailing: IconButton( icon: Icon( isExpanded ? Icons.expand_less : Icons.expand_more, size: 20, ), onPressed: () => _togglePointExpansion(point.pointId), ), ), if (isExpanded) _buildOutputPointDetails(point), if ((widget.device as HelvarDriverOutputDevice).outputPoints.last != point) const Divider(height: 1), ], ); } Widget _buildInputPointDetails(ButtonPoint point) { return Container( padding: const EdgeInsets.only(left: 48, right: 16, bottom: 12), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ buildInfoRow('Point Name', point.name), buildInfoRow('Function Type', point.function), buildInfoRow('Button ID', point.buttonId.toString()), buildInfoRow('Point Type', _getInputPointTypeDescription(point)), ], ), ); } Widget _buildOutputPointDetails(OutputPoint point) { return Container( padding: const EdgeInsets.only(left: 48, right: 16, bottom: 12), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ buildInfoRow('Point Name', point.name), buildInfoRow('Function', point.function), buildInfoRow('Point ID', point.pointId.toString()), buildInfoRow('Point Type', point.pointType), buildInfoRow('Current Value', formatOutputPointValue(point)), ], ), ); } Color _getInputPointColor(ButtonPoint point) { if (point.function.contains('Status') || point.name.contains('Missing')) { return Colors.orange; } else if (point.function.contains('IR')) { return Colors.purple; } else if (point.function.contains('Button')) { return Colors.blue; } else { return Colors.grey; } } Color _getOutputPointColor(OutputPoint point) { switch (point.pointId) { case 1:  return Colors.blue; case 2:  return Colors.red; case 3:  return Colors.orange; case 4:  return Colors.red; case 5:  return Colors.green; case 6:  return Colors.purple; default: return Colors.grey; } } String _getInputPointTypeDescription(ButtonPoint point) { if (point.function.contains('Status') || point.name.contains('Missing')) { return 'Status Point'; } else if (point.function.contains('IR')) { return 'IR Receiver'; } else if (point.function.contains('Button')) { return 'Button Input'; } else { return 'Generic Point'; } } void _togglePointExpansion(int pointId) { setState(() { _expandedPoints[pointId] = !(_expandedPoints[pointId] ?? false); }); } List<Widget> _buildOutputDeviceStatus() { final outputDevice = widget.device as HelvarDriverOutputDevice; return [ const SizedBox(height: 8), Text( 'Output Status', style: Theme.of(context).textTheme.bodyMedium?.copyWith( fontWeight: FontWeight.bold, color: Colors.blue[700], ), ), const SizedBox(height: 4), buildInfoRow('Current Level', '${outputDevice.level}%'), buildInfoRow('Proportion', '${outputDevice.proportion}'), buildInfoRow( 'Missing', outputDevice.missing.isEmpty ? 'No' : outputDevice.missing, ), buildInfoRow( 'Faulty', outputDevice.faulty.isEmpty ? 'No' : outputDevice.faulty, ), buildInfoRow( 'Power Consumption', '${outputDevice.powerConsumption.toStringAsFixed(1)}W', ), ]; } List<Widget> _buildInputDeviceStatus() { final inputDevice = widget.device as HelvarDriverInputDevice; List<Widget> widgets = []; widgets.add(const SizedBox(height: 8)); widgets.add( Text( 'Input Status', style: Theme.of(context).textTheme.bodyMedium?.copyWith( fontWeight: FontWeight.bold, color: Colors.green[700], ), ), ); widgets.add(const SizedBox(height: 4)); if (inputDevice.isButtonDevice) { widgets.add( buildInfoRow('Button Points', '${inputDevice.buttonPoints.length}'), ); } if (inputDevice.isMultisensor) { widgets.add( buildInfoRow('Sensor Capabilities', '${inputDevice.sensorInfo.length}'), ); inputDevice.sensorInfo.forEach((key, value) { widgets.add(buildInfoRow('  $key', value.toString())); }); } return widgets; } void _updateDeviceId(String val) { final id = int.tryParse(val); if (id != null && id > 0) { setState(() { widget.device.deviceId = id; }); logInfo("Device ID updated"); } else { showSnackBarMsg(context, "Invalid Device ID"); } } void _updateDeviceAddress(String val) { setState(() { widget.device.address = val; }); logInfo("Address updated"); } Future<void> _queryRealTimeStatus() async { try { if (widget.device is HelvarDriverOutputDevice) { await _queryOutputDevice(); } else if (widget.device is HelvarDriverInputDevice) { await _queryInputDevice(); } else { await _queryBasicDeviceStatus(); } if (mounted) { setState(() {}); logInfo('Device status updated successfully'); } } catch (e) { logError('Error querying device status: $e'); if (mounted) { showSnackBarMsg(context, 'Error querying device status: $e'); } } } Future<void> _queryOutputDevice() async { final deviceQueryService = ref.read(deviceQueryServiceProvider); final outputDevice = widget.device as HelvarDriverOutputDevice; final success = await deviceQueryService.queryOutputDevicePoints( widget.router.ipAddress, outputDevice, ); if (!success) { throw Exception('Failed to query output device points'); } logInfo('Successfully queried output device: ${widget.device.address}'); } Future<void> _queryInputDevice() async { await _queryBasicDeviceStatus(); final inputDevice = widget.device as HelvarDriverInputDevice; logInfo('Successfully queried input device: ${inputDevice.address}'); if (inputDevice.isButtonDevice) { logInfo('Button device detected - button points available'); } if (inputDevice.isMultisensor) { logInfo('Multisensor detected - sensor data available'); } } Future<void> _queryBasicDeviceStatus() async { final commandService = ref.read(routerCommandServiceProvider); final stateCommand = HelvarNetCommands.queryDeviceState( widget.device.address, ); final stateResult = await commandService.sendCommand( widget.router.ipAddress, stateCommand, ); if (stateResult.success && stateResult.response != null) { final stateValue = ProtocolParser.extractResponseValue( stateResult.response!, ); if (stateValue != null) { final stateCode = int.tryParse(stateValue) ?? 0; widget.device.deviceStateCode = stateCode; widget.device.state = getStateFlagsDescription(stateCode); logInfo('Device ${widget.device.address} state updated: $stateCode'); } } if (widget.device.deviceTypeCode == null) { final typeCommand = HelvarNetCommands.queryDeviceType( widget.device.address, ); final typeResult = await commandService.sendCommand( widget.router.ipAddress, typeCommand, ); if (typeResult.success && typeResult.response != null) { final typeValue = ProtocolParser.extractResponseValue( typeResult.response!, ); if (typeValue != null) { final typeCode = int.tryParse(typeValue) ?? 0; widget.device.deviceTypeCode = typeCode; logInfo('Device ${widget.device.address} type updated: $typeCode'); } } } } } 

// File: \lib\screens\details\group_detail_screen.dart
import 'package:flutter/material.dart'; import 'package:flutter/services.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/protocol/protocol_parser.dart'; import 'package:grms_designer/providers/workgroups_provider.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; import 'package:grms_designer/utils/scene_utils.dart'; import 'package:intl/intl.dart'; import '../../models/helvar_models/helvar_group.dart'; import '../../models/helvar_models/workgroup.dart'; import '../../providers/router_connection_provider.dart'; import '../../providers/group_polling_provider.dart'; import '../../protocol/query_commands.dart'; import '../../utils/general_ui.dart'; import '../../utils/logger.dart'; class GroupDetailScreen extends ConsumerStatefulWidget { final HelvarGroup group; final Workgroup workgroup; const GroupDetailScreen({ super.key, required this.group, required this.workgroup, }); @override GroupDetailScreenState createState() => GroupDetailScreenState(); } class GroupDetailScreenState extends ConsumerState<GroupDetailScreen> { late TextEditingController _sceneTableController; late TextEditingController _pollingMinutesController; bool _isLoading = false; bool _isEditingPollingInterval = false; HelvarGroup get currentGroup { final workgroups = ref.watch(workgroupsProvider); final currentWorkgroup = workgroups.firstWhere( (wg) => wg.id == widget.workgroup.id, ); final group = currentWorkgroup.groups.firstWhere( (g) => g.id == widget.group.id, ); return group; } @override void initState() { super.initState(); _sceneTableController = TextEditingController( text: widget.group.sceneTable.join(', '), ); _pollingMinutesController = TextEditingController( text: widget.group.powerPollingMinutes.toString(), ); } @override void dispose() { _sceneTableController.dispose(); _pollingMinutesController.dispose(); super.dispose(); } String _formatLastUpdateTime(DateTime? lastUpdate) { if (lastUpdate == null) return 'Never'; final now = DateTime.now(); final difference = now.difference(lastUpdate); if (difference.inMinutes < 1) { return 'Just now'; } else if (difference.inMinutes < 60) { return '${difference.inMinutes} minute${difference.inMinutes == 1 ? '' : 's'} ago'; } else if (difference.inHours < 24) { return '${difference.inHours} hour${difference.inHours == 1 ? '' : 's'} ago'; } else { return DateFormat('MMM d, h:mm a').format(lastUpdate); } } @override Widget build(BuildContext context) { final group = currentGroup; WidgetsBinding.instance.addPostFrameCallback((_) { final currentSceneTable = group.sceneTable.join(', '); if (_sceneTableController.text != currentSceneTable) { _sceneTableController.text = currentSceneTable; } if (_pollingMinutesController.text != group.powerPollingMinutes.toString()) { _pollingMinutesController.text = group.powerPollingMinutes.toString(); } }); return Scaffold( appBar: AppBar( title: Text( group.description.isEmpty ? 'Group ${group.groupId}' : group.description, ), centerTitle: true, actions: [ IconButton( icon: const Icon(Icons.refresh), tooltip: 'Update Data', onPressed: _isLoading ? null : _getLatestData, ), ], ), body: _isLoading ? const Center(child: CircularProgressIndicator()) : SingleChildScrollView( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ _buildInfoCard(context), const SizedBox(height: 24), _buildPowerConsumptionCard(context), const SizedBox(height: 24), _buildSceneTableCard(context), ], ), ), ); } Widget _buildPowerConsumptionCard(BuildContext context) { final group = currentGroup; final isPollingEnabled = widget.workgroup.pollEnabled; return Card( elevation: 2, child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( children: [ const Icon(Icons.power, color: Colors.orange), const SizedBox(width: 8), Text( 'Power Consumption', style: Theme.of(context).textTheme.titleLarge, ), ], ), const Divider(), buildInfoRow( 'Current Power', '${group.powerConsumption.toStringAsFixed(2)} W', width: 280, ), Row( children: [ const SizedBox( width: 140, child: Text( 'Polling Interval:', style: TextStyle(fontWeight: FontWeight.bold), ), ), Expanded( child: _isEditingPollingInterval ? Row( children: [ SizedBox( width: 80, child: TextFormField( controller: _pollingMinutesController, keyboardType: TextInputType.number, inputFormatters: [ FilteringTextInputFormatter.digitsOnly, ], decoration: const InputDecoration( isDense: true, border: OutlineInputBorder(), contentPadding: EdgeInsets.symmetric( horizontal: 8, vertical: 8, ), ), onFieldSubmitted: _savePollingInterval, ), ), const SizedBox(width: 8), const Text('minutes'), const SizedBox(width: 8), IconButton( icon: const Icon( Icons.check, color: Colors.green, ), onPressed: () => _savePollingInterval( _pollingMinutesController.text, ), padding: EdgeInsets.zero, constraints: const BoxConstraints.tightFor( width: 32, height: 32, ), ), IconButton( icon: const Icon(Icons.close, color: Colors.red), onPressed: _cancelPollingEdit, padding: EdgeInsets.zero, constraints: const BoxConstraints.tightFor( width: 32, height: 32, ), ), ], ) : Row( children: [ Text('${group.powerPollingMinutes} minutes'), const SizedBox(width: 8), IconButton( icon: const Icon(Icons.edit, size: 16), onPressed: _startPollingEdit, padding: EdgeInsets.zero, constraints: const BoxConstraints.tightFor( width: 32, height: 32, ), tooltip: 'Edit polling interval', ), ], ), ), ], ), const SizedBox(height: 8), Row( children: [ const SizedBox( width: 140, child: Text( 'Last Updated:', style: TextStyle(fontWeight: FontWeight.bold), ), ), Expanded( child: Row( children: [ Icon( Icons.access_time, size: 16, color: group.lastPowerUpdateTime != null ? Colors.green : Colors.grey, ), const SizedBox(width: 4), Text( _formatLastUpdateTime(group.lastPowerUpdateTime), style: TextStyle( color: group.lastPowerUpdateTime != null ? Colors.black87 : Colors.grey, ), ), ], ), ), ], ), if (isPollingEnabled) ...[ const SizedBox(height: 8), Container( padding: const EdgeInsets.symmetric( horizontal: 12, vertical: 6, ), decoration: BoxDecoration( color: Colors.green.withValues(alpha: 0.1 * 255), borderRadius: BorderRadius.circular(16), border: Border.all( color: Colors.green.withValues(alpha: 0.3 * 255), ), ), child: Row( mainAxisSize: MainAxisSize.min, children: [ Icon(Icons.autorenew, size: 16, color: Colors.green[700]), const SizedBox(width: 4), Text( 'Auto-polling active', style: TextStyle( color: Colors.green[700], fontSize: 12, fontWeight: FontWeight.w500, ), ), ], ), ), ] else ...[ const SizedBox(height: 8), Container( padding: const EdgeInsets.symmetric( horizontal: 12, vertical: 6, ), decoration: BoxDecoration( color: Colors.orange.withValues(alpha: 0.1 * 255), borderRadius: BorderRadius.circular(16), border: Border.all( color: Colors.orange.withValues(alpha: 0.3 * 255), ), ), child: Row( mainAxisSize: MainAxisSize.min, children: [ Icon( Icons.pause_circle_outline, size: 16, color: Colors.orange[700], ), const SizedBox(width: 4), Text( 'Auto-polling disabled', style: TextStyle( color: Colors.orange[700], fontSize: 12, fontWeight: FontWeight.w500, ), ), ], ), ), ], ], ), ), ); } void _startPollingEdit() { setState(() { _isEditingPollingInterval = true; }); } void _cancelPollingEdit() { setState(() { _isEditingPollingInterval = false; _pollingMinutesController.text = currentGroup.powerPollingMinutes .toString(); }); } void _savePollingInterval(String value) { final minutes = int.tryParse(value); if (minutes == null || minutes < 1 || minutes > 1440) { showSnackBarMsg( context, 'Please enter a valid interval (1-1440 minutes)', ); return; } final updatedGroup = currentGroup.copyWith(powerPollingMinutes: minutes); ref .read(workgroupsProvider.notifier) .updateGroup(widget.workgroup.id, updatedGroup); ref .read(pollingStateProvider.notifier) .updateGroupPolling(widget.workgroup.id, updatedGroup); setState(() { _isEditingPollingInterval = false; }); showSnackBarMsg(context, 'Polling interval updated to $minutes minutes'); logInfo( 'Updated polling interval for group ${currentGroup.groupId} to $minutes minutes', ); } Future<void> _getLatestData() async { if (widget.workgroup.routers.isEmpty) { showSnackBarMsg(context, 'No routers available'); return; } setState(() { _isLoading = true; }); try { final group = currentGroup; logInfo('Getting latest data for group ${group.groupId}'); await Future.wait([_querySceneData(), _queryPowerConsumption()]); if (mounted) { showSnackBarMsg(context, 'Group data updated successfully'); } logInfo('Successfully updated all data for group ${group.groupId}'); } catch (e) { logError('Error getting latest group data: $e'); if (mounted) { showSnackBarMsg(context, 'Error updating group data: $e'); } } finally { if (mounted) { setState(() { _isLoading = false; }); } } } Future<void> _queryPowerConsumption() async { try { final router = widget.workgroup.routers.first; final commandService = ref.read(routerCommandServiceProvider); final groupIdInt = int.tryParse(currentGroup.groupId); if (groupIdInt == null) { throw Exception('Invalid group ID: ${currentGroup.groupId}'); } logInfo('Querying power consumption for group ${currentGroup.groupId}'); final powerCommand = HelvarNetCommands.queryGroupPowerConsumption( groupIdInt, ); final powerResult = await commandService.sendCommand( router.ipAddress, powerCommand, ); if (powerResult.success && powerResult.response != null) { final powerValue = ProtocolParser.extractResponseValue( powerResult.response!, ); if (powerValue != null) { final powerConsumption = double.tryParse(powerValue) ?? 0.0; final now = DateTime.now(); final updatedGroup = currentGroup.copyWith( powerConsumption: powerConsumption, lastPowerUpdateTime: now, ); await ref .read(workgroupsProvider.notifier) .updateGroup(widget.workgroup.id, updatedGroup); logInfo( 'Updated power consumption for group ${currentGroup.groupId}: ${powerConsumption}W', ); } else { logWarning('Empty power consumption value received'); } } else { logWarning( 'Failed to query power consumption: ${powerResult.response}', ); } } catch (e) { logError('Error querying power consumption: $e'); } } Widget _buildInfoCard(BuildContext context) { final group = currentGroup; return Card( elevation: 2, child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( children: [ const Icon(Icons.layers, color: Colors.green), const SizedBox(width: 8), Text( 'Group Details', style: Theme.of(context).textTheme.titleLarge, ), ], ), const Divider(), buildInfoRow('ID', group.groupId), buildInfoRow('Description', group.description), buildInfoRow('Type', group.type), if (group.lsig != null) buildInfoRow('LSIG', group.lsig.toString()), if (group.lsib1 != null) buildInfoRow('LSIB1', group.lsib1.toString()), if (group.lsib2 != null) buildInfoRow('LSIB2', group.lsib2.toString()), for (int i = 0; i < group.blockValues.length; i++) buildInfoRow('Block${i + 1}', group.blockValues[i].toString()), buildInfoRow('Gateway Router', group.gatewayRouterIpAddress), buildInfoRow( 'Refresh Props After Action', group.refreshPropsAfterAction.toString(), ), if (group.actionResult.isNotEmpty) buildInfoRow('Action Result', group.actionResult), if (group.lastMessage.isNotEmpty) buildInfoRow('Last Message', group.lastMessage), if (group.lastMessageTime != null) buildInfoRow( 'Message Time', DateFormat( 'MMM d, yyyy h:mm:ss a', ).format(group.lastMessageTime!), ), buildInfoRow('Workgroup', widget.workgroup.description), ], ), ), ); } Widget _buildSceneTableCard(BuildContext context) { final group = currentGroup; return Card( elevation: 2, child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( children: [ const Icon(Icons.table_chart, color: Colors.blue), const SizedBox(width: 8), Text( 'Scene Table', style: Theme.of(context).textTheme.titleLarge, ), const Spacer(), PopupMenuButton<String>( onSelected: _handleSceneAction, itemBuilder: (context) => [ const PopupMenuItem( value: 'query', child: Text('Query Scenes'), ), const PopupMenuItem( value: 'query_names', child: Text('Query Scene Names'), ), const PopupMenuItem( value: 'recall', child: Text('Recall Scene'), ), const PopupMenuItem( value: 'store', child: Text('Store Scene'), ), ], ), ], ), const Divider(), const SizedBox(height: 8), Text( 'Scene Numbers (comma-separated):', style: Theme.of( context, ).textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.w500), ), const SizedBox(height: 8), TextField( controller: _sceneTableController, decoration: InputDecoration( hintText: 'Enter scene numbers separated by commas (e.g., 1, 2, 5, 8)', border: const OutlineInputBorder(), suffixIcon: Row( mainAxisSize: MainAxisSize.min, children: [ IconButton( icon: const Icon(Icons.save), tooltip: 'Save Scene Table', onPressed: _saveSceneTable, ), IconButton( icon: const Icon(Icons.clear), tooltip: 'Clear Scene Table', onPressed: _clearSceneTable, ), ], ), ), maxLines: 3, minLines: 1, ), const SizedBox(height: 8), if (group.sceneTable.isNotEmpty) ...[ Text( 'Current Scenes: ${group.sceneTable.length} scenes', style: Theme.of(context).textTheme.bodySmall, ), const SizedBox(height: 8), Wrap( spacing: 8.0, runSpacing: 4.0, children: group.sceneTable.map((scene) { return Chip( label: Text(getSceneDisplayName(scene)), backgroundColor: getSceneChipColor(scene), onDeleted: () => _removeSceneFromTable(scene), deleteIcon: const Icon(Icons.close, size: 16), ); }).toList(), ), ] else ...[ Container( padding: const EdgeInsets.all(16.0), decoration: BoxDecoration( color: Colors.grey[100], borderRadius: BorderRadius.circular(8.0), ), child: const Row( children: [ Icon(Icons.info_outline, color: Colors.grey), SizedBox(width: 8), Text( 'No scenes in table. Query scenes to populate automatically.', style: TextStyle(color: Colors.grey), ), ], ), ), ], ], ), ), ); } void _handleSceneAction(String action) { switch (action) { case 'query': _querySceneData(); break; case 'query_names': _querySceneNames(); break; case 'recall': _showRecallSceneDialog(); break; case 'store': _showStoreSceneDialog(); break; } } Future<void> _querySceneData() async { try { final router = widget.workgroup.routers.first; final sceneQueryService = ref.read(sceneQueryServiceProvider); final groupIdInt = int.tryParse(widget.group.groupId); if (groupIdInt == null) { throw Exception('Invalid group ID: ${currentGroup.groupId}'); } logInfo('Querying scene data for group ${currentGroup.groupId}'); final sceneData = await sceneQueryService.exploreGroupScenes( router.ipAddress, groupIdInt, ); final allScenes = sceneQueryService.buildSceneTable(sceneData); final meaningfulScenes = allScenes.where((scene) { return scene != 129; }).toList(); final scenesToShow = meaningfulScenes.isNotEmpty ? meaningfulScenes : allScenes; _sceneTableController.text = scenesToShow.join(', '); final currentGroupData = currentGroup; final updatedGroup = currentGroupData.copyWith(sceneTable: scenesToShow); await ref .read(workgroupsProvider.notifier) .updateGroup(widget.workgroup.id, updatedGroup); logInfo( 'Updated scene table for group ${currentGroupData.groupId}: $scenesToShow', ); } catch (e) { logError('Error querying scene data: $e'); rethrow; } } Future<void> _querySceneNames() async { if (widget.workgroup.routers.isEmpty) { showSnackBarMsg(context, 'No routers available'); return; } setState(() { _isLoading = true; }); try { final router = widget.workgroup.routers.first; final sceneQueryService = ref.read(sceneQueryServiceProvider); logInfo('Querying scene names for router ${router.ipAddress}'); final sceneNames = await sceneQueryService.querySceneNames( router.ipAddress, ); if (mounted) { if (sceneNames.isNotEmpty) { _showSceneNamesDialog(sceneNames); } else { showSnackBarMsg(context, 'No scene names found'); } } } catch (e) { logError('Error querying scene names: $e'); if (mounted) { showSnackBarMsg(context, 'Error querying scene names: $e'); } } finally { if (mounted) { setState(() { _isLoading = false; }); } } } void _showSceneNamesDialog(List<String> sceneNames) { showDialog( context: context, builder: (context) => AlertDialog( title: const Text('Scene Names'), content: SizedBox( width: double.maxFinite, child: Column( mainAxisSize: MainAxisSize.min, children: [ Text('Found ${sceneNames.length} scene names:'), const SizedBox(height: 16), Flexible( child: ListView.builder( shrinkWrap: true, itemCount: sceneNames.length, itemBuilder: (context, index) { final sceneName = sceneNames[index]; return Card( margin: const EdgeInsets.symmetric(vertical: 2), child: ListTile( dense: true, leading: const Icon(Icons.movie, size: 20), title: Text( sceneName, style: const TextStyle(fontSize: 14), ), subtitle: _parseSceneNameInfo(sceneName), ), ); }, ), ), ], ), ), actions: [closeAction(context)], ), ); } Widget? _parseSceneNameInfo(String sceneName) { if (sceneName.startsWith('[@') && sceneName.contains(':')) { try { final parts = sceneName.substring(2, sceneName.length - 1).split(':'); if (parts.length == 2) { final address = parts[0]; final description = parts[1]; return Text( 'Address: $address • $description', style: const TextStyle(fontSize: 12, color: Colors.grey), ); } } catch (e) { } } return null; } void _saveSceneTable() { try { final text = _sceneTableController.text.trim(); List<int> sceneNumbers = []; if (text.isNotEmpty) { final parts = text.split(','); for (final part in parts) { final trimmed = part.trim(); if (trimmed.isNotEmpty) { final sceneNum = int.tryParse(trimmed); if (sceneNum != null && sceneNum > 0 && sceneNum <= 255) { sceneNumbers.add(sceneNum); } else { throw Exception('Invalid scene number: $trimmed (must be 1-255)'); } } } } final uniqueScenes = sceneNumbers.toSet().toList()..sort(); final updatedGroup = currentGroup.copyWith(sceneTable: uniqueScenes); ref .read(workgroupsProvider.notifier) .updateGroup(widget.workgroup.id, updatedGroup); _sceneTableController.text = uniqueScenes.join(', '); final message = uniqueScenes.isEmpty ? 'Scene table cleared' : 'Scene table saved with ${uniqueScenes.length} distinct scenes'; showSnackBarMsg(context, message); logInfo('Scene table updated: $uniqueScenes'); } catch (e) { showSnackBarMsg(context, 'Error saving scene table: $e'); } } void _clearSceneTable() { _sceneTableController.clear(); final updatedGroup = currentGroup.copyWith(sceneTable: []); ref .read(workgroupsProvider.notifier) .updateGroup(widget.workgroup.id, updatedGroup); logInfo('Scene table cleared for group ${currentGroup.groupId}'); } void _removeSceneFromTable(int sceneNumber) { final currentScenes = currentGroup.sceneTable.toList(); currentScenes.remove(sceneNumber); final updatedGroup = currentGroup.copyWith(sceneTable: currentScenes); ref .read(workgroupsProvider.notifier) .updateGroup(widget.workgroup.id, updatedGroup); _sceneTableController.text = currentScenes.join(', '); showSnackBarMsg(context, 'Removed scene $sceneNumber'); logInfo('Removed scene $sceneNumber from group ${currentGroup.groupId}'); } void _showRecallSceneDialog() { if (currentGroup.sceneTable.isEmpty) { showSnackBarMsg(context, 'No scenes available to recall'); return; } showDialog( context: context, builder: (context) => AlertDialog( title: const Text('Recall Scene'), content: Column( mainAxisSize: MainAxisSize.min, children: [ const Text('Select a scene to recall:'), const SizedBox(height: 16), Wrap( spacing: 8.0, runSpacing: 8.0, children: currentGroup.sceneTable.map((scene) { return ElevatedButton( onPressed: () { Navigator.of(context).pop(); _recallScene(scene); }, child: Text('Scene $scene'), ); }).toList(), ), ], ), actions: [cancelAction(context)], ), ); } void _showStoreSceneDialog() { final sceneController = TextEditingController(); final blockController = TextEditingController(text: '1'); showDialog( context: context, builder: (context) => AlertDialog( title: const Text('Store Scene'), content: Column( mainAxisSize: MainAxisSize.min, children: [ TextField( controller: sceneController, decoration: const InputDecoration( labelText: 'Scene Number (1-16)', border: OutlineInputBorder(), ), keyboardType: TextInputType.number, ), const SizedBox(height: 16), TextField( controller: blockController, decoration: const InputDecoration( labelText: 'Block Number (1-8)', border: OutlineInputBorder(), ), keyboardType: TextInputType.number, ), ], ), actions: [ cancelAction(context), ElevatedButton( onPressed: () { final scene = int.tryParse(sceneController.text); final block = int.tryParse(blockController.text); if (scene != null && block != null) { Navigator.of(context).pop(); _storeScene(scene, block); } else { showSnackBarMsg(context, 'Please enter valid numbers'); } }, child: const Text('Store'), ), ], ), ); } Future<void> _recallScene(int sceneNumber) async { if (widget.workgroup.routers.isEmpty) { showSnackBarMsg(context, 'No routers available'); return; } try { final router = widget.workgroup.routers.first; final commandService = ref.read(routerCommandServiceProvider); final groupIdInt = int.tryParse(currentGroup.groupId); if (groupIdInt == null) { throw Exception('Invalid group ID'); } final command = HelvarNetCommands.recallSceneGroup( groupIdInt, 1,  sceneNumber, ); final result = await commandService.sendCommand( router.ipAddress, command, ); if (result.success) { logInfo( 'Recalled scene $sceneNumber for group ${currentGroup.groupId}', ); } else { throw Exception('Command failed: ${result.response}'); } } catch (e) { logError('Error recalling scene: $e'); showSnackBarMsg(context, 'Error recalling scene: $e'); } } Future<void> _storeScene(int sceneNumber, int blockNumber) async { if (widget.workgroup.routers.isEmpty) { showSnackBarMsg(context, 'No routers available'); return; } try { final router = widget.workgroup.routers.first; final commandService = ref.read(routerCommandServiceProvider); final groupIdInt = int.tryParse(currentGroup.groupId); if (groupIdInt == null) { throw Exception('Invalid group ID'); } final command = HelvarNetCommands.storeAsSceneGroup( groupIdInt, blockNumber, sceneNumber, ); final result = await commandService.sendCommand( router.ipAddress, command, ); if (result.success) { logInfo( 'Stored scene $sceneNumber in block $blockNumber for group ${currentGroup.groupId}', ); await Future.delayed(const Duration(milliseconds: 500)); _querySceneData(); } else { throw Exception('Command failed: ${result.response}'); } } catch (e) { logError('Error storing scene: $e'); showSnackBarMsg(context, 'Error storing scene: $e'); } } } 

// File: \lib\screens\details\input_point_detail_screen.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/utils/general_ui.dart'; import '../../models/helvar_models/helvar_device.dart'; import '../../models/helvar_models/helvar_router.dart'; import '../../models/helvar_models/workgroup.dart'; import '../../models/helvar_models/input_device.dart'; class InputPointDetailScreen extends ConsumerStatefulWidget { final Workgroup workgroup; final HelvarRouter router; final HelvarDevice device; final ButtonPoint point; const InputPointDetailScreen({ super.key, required this.workgroup, required this.router, required this.device, required this.point, }); @override InputPointDetailScreenState createState() => InputPointDetailScreenState(); } class InputPointDetailScreenState extends ConsumerState<InputPointDetailScreen> { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('${widget.router.description} - ${widget.point.name}'), centerTitle: true, ), body: SingleChildScrollView( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [_buildPointInfoCard()], ), ), ); } Widget _buildPointInfoCard() { return Card( child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( children: [ Icon(_getPointIcon(), size: 32, color: _getPointColor()), const SizedBox(width: 16), Expanded( child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text( widget.point.name, style: Theme.of(context).textTheme.titleLarge, ), Text( widget.point.function, style: Theme.of(context).textTheme.bodyMedium, ), ], ), ), ], ), const Divider(), buildInfoRow('Point Name', widget.point.name), buildInfoRow('Function', widget.point.function), buildInfoRow('Button ID', widget.point.buttonId.toString()), buildInfoRow( 'Parent Device', widget.device.description.isEmpty ? 'Device ${widget.device.deviceId}' : widget.device.description, ), buildInfoRow('Device Address', widget.device.address), buildInfoRow('Point Type', _getPointTypeDescription()), ], ), ), ); } IconData _getPointIcon() { if (widget.point.function.contains('Status') || widget.point.name.contains('Missing')) { return Icons.info_outline; } else if (widget.point.function.contains('IR')) { return Icons.settings_remote; } else if (widget.point.function.contains('Button')) { return Icons.touch_app; } else { return Icons.radio_button_unchecked; } } Color _getPointColor() { if (widget.point.function.contains('Status') || widget.point.name.contains('Missing')) { return Colors.orange; } else if (widget.point.function.contains('IR')) { return Colors.purple; } else if (widget.point.function.contains('Button')) { return Colors.blue; } else { return Colors.grey; } } String _getPointTypeDescription() { if (widget.point.function.contains('Status') || widget.point.name.contains('Missing')) { return 'Status Point'; } else if (widget.point.function.contains('IR')) { return 'IR Receiver Point'; } else if (widget.point.function.contains('Button')) { return 'Button Input Point'; } else { return 'Generic Point'; } } } 

// File: \lib\screens\details\output_points_detail_screen.dart
import 'dart:async'; import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/models/helvar_models/output_point.dart'; import '../../models/helvar_models/helvar_device.dart'; import '../../models/helvar_models/helvar_router.dart'; import '../../models/helvar_models/workgroup.dart'; import '../../models/helvar_models/output_device.dart'; import '../../services/device_query_service.dart'; import '../../utils/general_ui.dart'; class OutputPointsDetailScreen extends ConsumerStatefulWidget { final Workgroup workgroup; final HelvarRouter router; final HelvarDevice device; final Function( String, { Workgroup? workgroup, HelvarRouter? router, HelvarDevice? device, OutputPoint? outputPoint, })? onNavigate; const OutputPointsDetailScreen({ super.key, required this.workgroup, required this.router, required this.device, this.onNavigate, }); @override OutputPointsDetailScreenState createState() => OutputPointsDetailScreenState(); } class OutputPointsDetailScreenState extends ConsumerState<OutputPointsDetailScreen> { final Map<int, bool> _expandedPoints = {}; bool _autoRefresh = false; Timer? _refreshTimer; @override void initState() { super.initState(); if (widget.device is HelvarDriverOutputDevice) { final outputDevice = widget.device as HelvarDriverOutputDevice; if (outputDevice.outputPoints.isEmpty) { outputDevice.generateOutputPoints(); } } } @override void dispose() { _refreshTimer?.cancel(); super.dispose(); } @override Widget build(BuildContext context) { final outputDevice = widget.device as HelvarDriverOutputDevice; final deviceName = widget.device.description.isEmpty ? 'Device ${widget.device.deviceId}' : widget.device.description; return Scaffold( appBar: AppBar( title: Text('Output Points - $deviceName'), centerTitle: true, actions: [ IconButton( icon: Icon(_autoRefresh ? Icons.pause : Icons.refresh), tooltip: _autoRefresh ? 'Stop Auto Refresh' : 'Start Auto Refresh', onPressed: _toggleAutoRefresh, ), PopupMenuButton<String>( onSelected: _handleMenuAction, itemBuilder: (context) => [ const PopupMenuItem( value: 'query_all', child: Text('Query All Points'), ), const PopupMenuItem( value: 'export_config', child: Text('Export Point Configuration'), ), const PopupMenuItem( value: 'reset_values', child: Text('Reset All Values'), ), ], ), ], ), body: outputDevice.outputPoints.isEmpty ? const Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Icon( Icons.radio_button_unchecked, size: 64, color: Colors.grey, ), SizedBox(height: 16), Text( 'No output points available for this device', style: TextStyle(fontSize: 18), ), ], ), ) : _buildPointsList(outputDevice), ); } Widget _buildPointsList(HelvarDriverOutputDevice outputDevice) { return ListView.builder( padding: const EdgeInsets.all(16.0), itemCount: outputDevice.outputPoints.length, itemBuilder: (context, index) { final point = outputDevice.outputPoints[index]; return _buildPointCard(point, index); }, ); } Widget _buildPointCard(OutputPoint point, int index) { final isExpanded = _expandedPoints[point.pointId] ?? false; return Card( margin: const EdgeInsets.symmetric(vertical: 8), child: Column( children: [ ListTile( leading: CircleAvatar( backgroundColor: _getPointColor( point, ).withValues(alpha: 0.2 * 255), child: Icon( _getPointIcon(point), color: _getPointColor(point), size: 20, ), ), title: Text( point.function, style: const TextStyle(fontWeight: FontWeight.bold), ), subtitle: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text('Type: ${point.pointType}'), Text('ID: ${point.pointId}'), Row( children: [ const Text('Value: '), Container( padding: const EdgeInsets.symmetric( horizontal: 8, vertical: 2, ), decoration: BoxDecoration( color: _getValueColor( point, ).withValues(alpha: 0.2 * 255), borderRadius: BorderRadius.circular(12), ), child: Text( _formatValue(point), style: TextStyle( color: _getValueColor(point), fontSize: 12, fontWeight: FontWeight.bold, ), ), ), ], ), ], ), trailing: Row( mainAxisSize: MainAxisSize.min, children: [ IconButton( icon: Icon( isExpanded ? Icons.expand_less : Icons.expand_more, ), onPressed: () => _togglePointExpansion(point.pointId), ), ], ), isThreeLine: true, ), if (isExpanded) _buildExpandedPointContent(point), ], ), ); } Widget _buildExpandedPointContent(OutputPoint point) { return Container( padding: const EdgeInsets.all(16.0), decoration: BoxDecoration( color: Colors.grey[50], border: Border(top: BorderSide(color: Colors.grey[300]!)), ), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( children: [ Expanded( child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ buildInfoRow('Point Name', point.name), buildInfoRow('Function', point.function), buildInfoRow('Point ID', point.pointId.toString()), buildInfoRow('Point Type', point.pointType), buildInfoRow( 'Description', DeviceQueryService.getPointDescription(point.pointId), ), buildInfoRow('Current Value', _formatValue(point)), ], ), ), ], ), ], ), ); } IconData _getPointIcon(OutputPoint point) { switch (point.pointId) { case 1:  return Icons.device_hub; case 2:  return Icons.lightbulb_outline; case 3:  return Icons.help_outline; case 4:  return Icons.warning; case 5:  return Icons.tune; case 6:  return Icons.power; default: return Icons.circle; } } Color _getPointColor(OutputPoint point) { switch (point.pointId) { case 1:  return Colors.blue; case 2:  return Colors.red; case 3:  return Colors.orange; case 4:  return Colors.red; case 5:  return Colors.green; case 6:  return Colors.purple; default: return Colors.grey; } } Color _getValueColor(OutputPoint point) { if (point.pointType == 'boolean') { final value = point.value as bool? ?? false; if ([1, 2, 3, 4].contains(point.pointId)) { return value ? Colors.red : Colors.green; } return value ? Colors.green : Colors.grey; } else { final value = (point.value as num?)?.toDouble() ?? 0.0; if (value == 0) return Colors.grey; if (value < 50) return Colors.blue; return Colors.green; } } String _formatValue(OutputPoint point) { if (point.pointType == 'boolean') { final value = point.value as bool? ?? false; return value ? 'TRUE' : 'FALSE'; } else { final value = (point.value as num?)?.toDouble() ?? 0.0; if (point.pointId == 5) { return '${value.toStringAsFixed(0)}%'; } else if (point.pointId == 6) { return '${value.toStringAsFixed(1)}W'; } return value.toStringAsFixed(1); } } void _togglePointExpansion(int pointId) { setState(() { _expandedPoints[pointId] = !(_expandedPoints[pointId] ?? false); }); } void _toggleAutoRefresh() { setState(() { _autoRefresh = !_autoRefresh; }); if (_autoRefresh) { _startAutoRefresh(); showSnackBarMsg(context, 'Auto refresh started (30s interval)'); } else { _stopAutoRefresh(); showSnackBarMsg(context, 'Auto refresh stopped'); } } void _startAutoRefresh() {} void _stopAutoRefresh() {} void _handleMenuAction(String action) { switch (action) { case 'query_all': break; case 'export_config': break; case 'reset_values': break; } } } 

// File: \lib\screens\details\output_point_detail_screen.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/utils/general_ui.dart'; import '../../models/helvar_models/helvar_device.dart'; import '../../models/helvar_models/helvar_router.dart'; import '../../models/helvar_models/workgroup.dart'; import '../../models/helvar_models/output_point.dart'; import '../../services/device_query_service.dart'; class OutputPointDetailScreen extends ConsumerStatefulWidget { final Workgroup workgroup; final HelvarRouter router; final HelvarDevice device; final OutputPoint point; const OutputPointDetailScreen({ super.key, required this.workgroup, required this.router, required this.device, required this.point, }); @override OutputPointDetailScreenState createState() => OutputPointDetailScreenState(); } class OutputPointDetailScreenState extends ConsumerState<OutputPointDetailScreen> { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('${widget.router.description} - ${widget.point.function}'), centerTitle: true, ), body: Padding( padding: const EdgeInsets.all(16.0), child: _buildPointInfoCard(), ), ); } Widget _buildPointInfoCard() { return Card( child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( children: [ Icon(_getPointIcon(), size: 32, color: _getPointColor()), const SizedBox(width: 16), Expanded( child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text( widget.point.function, style: Theme.of(context).textTheme.titleLarge, ), Text( widget.point.name, style: Theme.of(context).textTheme.bodyMedium, ), ], ), ), ], ), const Divider(), buildInfoRow('Point Name', widget.point.name), buildInfoRow('Function', widget.point.function), buildInfoRow('Point ID', widget.point.pointId.toString()), buildInfoRow('Point Type', widget.point.pointType), buildInfoRow( 'Parent Device', widget.device.description.isEmpty ? 'Device ${widget.device.deviceId}' : widget.device.description, ), buildInfoRow('Device Address', widget.device.address), buildInfoRow( 'Description', DeviceQueryService.getPointDescription(widget.point.pointId), ), ], ), ), ); } IconData _getPointIcon() { switch (widget.point.pointId) { case 1: return Icons.device_hub; case 2: return Icons.lightbulb_outline; case 3: return Icons.help_outline; case 4: return Icons.warning; case 5: return Icons.tune; case 6: return Icons.power; default: return Icons.circle; } } Color _getPointColor() { switch (widget.point.pointId) { case 1: return Colors.blue; case 2: return Colors.red; case 3: return Colors.orange; case 4: return Colors.red; case 5: return Colors.green; case 6: return Colors.purple; default: return Colors.grey; } } } 

// File: \lib\screens\details\points_detail_screen.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/utils/general_ui.dart'; import '../../models/helvar_models/helvar_device.dart'; import '../../models/helvar_models/helvar_router.dart'; import '../../models/helvar_models/workgroup.dart'; import '../../models/helvar_models/input_device.dart'; class PointsDetailScreen extends ConsumerStatefulWidget { final Workgroup workgroup; final HelvarRouter router; final HelvarDevice device; final Function( String, { Workgroup? workgroup, HelvarRouter? router, HelvarDevice? device, ButtonPoint? point, })? onNavigate; const PointsDetailScreen({ super.key, required this.workgroup, required this.router, required this.device, this.onNavigate, }); @override PointsDetailScreenState createState() => PointsDetailScreenState(); } class PointsDetailScreenState extends ConsumerState<PointsDetailScreen> { final Map<int, bool> _expandedPoints = {}; final Map<int, String> _pointStates = {}; @override void initState() { super.initState(); _initializePointStates(); } void _initializePointStates() { final inputDevice = widget.device as HelvarDriverInputDevice; for (final point in inputDevice.buttonPoints) { _pointStates[point.buttonId] = 'Unknown'; } } @override Widget build(BuildContext context) { final inputDevice = widget.device as HelvarDriverInputDevice; final deviceName = widget.device.description.isEmpty ? 'Device ${widget.device.deviceId}' : widget.device.description; return Scaffold( appBar: AppBar( title: Text('Points - $deviceName'), centerTitle: true, actions: [ PopupMenuButton<String>( onSelected: _handleMenuAction, itemBuilder: (context) => [ const PopupMenuItem( value: 'refresh_all', child: Text('Refresh All States'), ), const PopupMenuItem( value: 'export_config', child: Text('Export Point Configuration'), ), const PopupMenuItem( value: 'clear_all_history', child: Text('Clear All Event History'), ), ], ), ], ), body: inputDevice.buttonPoints.isEmpty ? const Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Icon( Icons.radio_button_unchecked, size: 64, color: Colors.grey, ), SizedBox(height: 16), Text( 'No points available for this device', style: TextStyle(fontSize: 18), ), ], ), ) : _buildPointsList(inputDevice), ); } Widget _buildPointsList(HelvarDriverInputDevice inputDevice) { return ListView.builder( padding: const EdgeInsets.all(16.0), itemCount: inputDevice.buttonPoints.length, itemBuilder: (context, index) { final point = inputDevice.buttonPoints[index]; return _buildPointCard(point, index); }, ); } Widget _buildPointCard(ButtonPoint point, int index) { final isExpanded = _expandedPoints[point.buttonId] ?? false; final currentState = _pointStates[point.buttonId] ?? 'Unknown'; return Card( margin: const EdgeInsets.symmetric(vertical: 8), child: Column( children: [ ListTile( leading: CircleAvatar( backgroundColor: _getPointColor( point, ).withValues(alpha: 0.2 * 255), child: Icon( _getPointIcon(point), color: _getPointColor(point), size: 20, ), ), title: Text( point.name, style: const TextStyle(fontWeight: FontWeight.bold), ), subtitle: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text('Function: ${point.function}'), Text('ID: ${point.buttonId}'), Row( children: [ const Text('State: '), Container( padding: const EdgeInsets.symmetric( horizontal: 8, vertical: 2, ), decoration: BoxDecoration( color: _getStateColor( currentState, ).withValues(alpha: 0.2 * 255), borderRadius: BorderRadius.circular(12), ), child: Text( currentState, style: TextStyle( color: _getStateColor(currentState), fontSize: 12, fontWeight: FontWeight.bold, ), ), ), ], ), ], ), trailing: Row( mainAxisSize: MainAxisSize.min, children: [ IconButton( icon: Icon( isExpanded ? Icons.expand_less : Icons.expand_more, ), onPressed: () => _togglePointExpansion(point.buttonId), ), ], ), isThreeLine: true, ), if (isExpanded) _buildExpandedPointContent(point), ], ), ); } Widget _buildExpandedPointContent(ButtonPoint point) { return Container( padding: const EdgeInsets.all(16.0), decoration: BoxDecoration( color: Colors.grey[50], border: Border(top: BorderSide(color: Colors.grey[300]!)), ), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( children: [ Expanded( child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ buildInfoRow('Point Name', point.name), buildInfoRow('Function Type', point.function), buildInfoRow('Button ID', point.buttonId.toString()), buildInfoRow('Point Type', _getPointTypeDescription(point)), ], ), ), ], ), ], ), ); } IconData _getPointIcon(ButtonPoint point) { if (point.function.contains('Status') || point.name.contains('Missing')) { return Icons.info_outline; } else if (point.function.contains('IR')) { return Icons.settings_remote; } else if (point.function.contains('Button')) { return Icons.touch_app; } else { return Icons.radio_button_unchecked; } } Color _getPointColor(ButtonPoint point) { if (point.function.contains('Status') || point.name.contains('Missing')) { return Colors.orange; } else if (point.function.contains('IR')) { return Colors.purple; } else if (point.function.contains('Button')) { return Colors.blue; } else { return Colors.grey; } } Color _getStateColor(String state) { switch (state.toLowerCase()) { case 'active': case 'on': case 'pressed': return Colors.green; case 'inactive': case 'off': case 'released': return Colors.grey; case 'fault': case 'error': return Colors.red; case 'unknown': default: return Colors.orange; } } String _getPointTypeDescription(ButtonPoint point) { if (point.function.contains('Status') || point.name.contains('Missing')) { return 'Status Point'; } else if (point.function.contains('IR')) { return 'IR Receiver'; } else if (point.function.contains('Button')) { return 'Button Input'; } else { return 'Generic Point'; } } void _togglePointExpansion(int buttonId) { setState(() { _expandedPoints[buttonId] = !(_expandedPoints[buttonId] ?? false); }); } void _handleMenuAction(String action) { switch (action) { case 'refresh_all': break; case 'export_config': break; case 'clear_all_history': break; } } } 

// File: \lib\screens\details\router_detail_screen.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; import '../../models/helvar_models/helvar_router.dart'; import '../../models/helvar_models/helvar_device.dart'; import '../../models/helvar_models/input_device.dart'; import '../../models/helvar_models/output_device.dart'; import '../../models/helvar_models/workgroup.dart'; import '../../providers/router_connection_provider.dart'; import '../../providers/workgroups_provider.dart'; import '../../utils/device_icons.dart'; import '../../utils/file_dialog_helper.dart'; import '../../utils/general_ui.dart'; import '../../utils/logger.dart'; import '../dialogs/add_device_dialog.dart'; class RouterDetailScreen extends ConsumerStatefulWidget { final Workgroup workgroup; final HelvarRouter router; const RouterDetailScreen({ super.key, required this.workgroup, required this.router, }); @override RouterDetailScreenState createState() => RouterDetailScreenState(); } class RouterDetailScreenState extends ConsumerState<RouterDetailScreen> { late List<HelvarDevice> _devices; bool _isLoading = false; final Map<String, List<HelvarDevice>> _devicesBySubnet = {}; @override void initState() { super.initState(); _devices = widget.router.devices; _organizeDevicesBySubnet(); } void _organizeDevicesBySubnet() { _devicesBySubnet.clear(); for (final device in _devices) { final addressParts = device.address.split('.'); if (addressParts.length >= 3) { final subnetId = addressParts.sublist(0, 3).join('.'); if (!_devicesBySubnet.containsKey(subnetId)) { _devicesBySubnet[subnetId] = []; } _devicesBySubnet[subnetId]!.add(device); } } } void _addOutputDevice() { _showAddDeviceDialog(DeviceType.output); } void _addInputDevice() { _showAddDeviceDialog(DeviceType.input); } void _addEmergencyDevice() { _showAddDeviceDialog(DeviceType.emergency); } Future<void> _showAddDeviceDialog(DeviceType initialType) async { final existingSubnets = _devicesBySubnet.keys.toList(); final device = await showDialog<HelvarDevice>( context: context, builder: (context) => AddDeviceDialog( nextDeviceId: _devices.length + 1, existingSubnets: existingSubnets, ), ); if (device != null) { await ref .read(workgroupsProvider.notifier) .addDeviceToRouter( widget.workgroup.id, widget.router.address, device, ); setState(() { _devices = widget.router.devices; _organizeDevicesBySubnet(); }); if (mounted) { showSnackBarMsg(context, 'Device added successfully'); } } } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Router: ${widget.router.description}'), actions: [ IconButton( icon: const Icon(Icons.wifi), tooltip: 'Connect', onPressed: () { ref .read(workgroupsProvider.notifier) .getRouterConnection( widget.workgroup.id, widget.router.address, ); }, ), PopupMenuButton<String>( onSelected: _handleMenuAction, itemBuilder: (context) => [ const PopupMenuItem( value: 'discover', child: Text('Discover Devices'), ), const PopupMenuItem( value: 'import', child: Text('Import Devices from File'), ), const PopupMenuItem( value: 'export', child: Text('Export Devices to File'), ), const PopupMenuItem( value: 'add_output', child: Text('Add Output Device'), ), const PopupMenuItem( value: 'add_input', child: Text('Add Input Device'), ), const PopupMenuItem( value: 'add_emergency', child: Text('Add Emergency Device'), ), const PopupMenuItem( value: 'delete_all', child: Text('Delete All Devices'), ), ], ), ], ), body: _isLoading ? const Center(child: CircularProgressIndicator()) : _buildDevicesList(), ); } Widget _buildDevicesList() { return widget.router.devices.isEmpty ? Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ const Icon(Icons.device_unknown, size: 64, color: Colors.grey), const SizedBox(height: 16), const Text( 'No devices found for this router', style: TextStyle(fontSize: 18), ), const SizedBox(height: 24), Row( mainAxisAlignment: MainAxisAlignment.center, children: [ ElevatedButton.icon( icon: const Icon(Icons.search), label: const Text('Discover Devices'), onPressed: _discoverDevices, ), const SizedBox(width: 16), ElevatedButton.icon( icon: const Icon(Icons.add), label: const Text('Add Manually'), onPressed: () => _handleMenuAction('add_output'), ), ], ), ], ), ) : ListView.builder( itemCount: widget.router.devicesBySubnet.length, itemBuilder: (context, index) { final subnet = widget.router.devicesBySubnet.keys.elementAt( index, ); final subnetDevices = widget.router.devicesBySubnet[subnet] ?? []; return ExpansionTile( title: Text('Subnet $subnet (${subnetDevices.length} devices)'), initiallyExpanded: index == 0, children: subnetDevices .map((device) => _buildDeviceExpansionTile(device)) .toList(), ); }, ); } Widget _buildDeviceExpansionTile(HelvarDevice device) { final deviceName = device.description.isEmpty ? 'Device ${device.deviceId}' : device.description; final List<Widget> subItems = []; subItems.add( ListTile( leading: const Icon(Icons.warning_amber, size: 20), title: const Text('Alarm Source Info'), contentPadding: const EdgeInsets.only(left: 56), dense: true, onTap: () => _showDeviceAlarmInfo(device), ), ); if (device is HelvarDriverInputDevice && device.isButtonDevice && device.buttonPoints.isNotEmpty) { subItems.add( ExpansionTile( title: const Text('Points'), leading: const Icon(Icons.add_circle_outline), childrenPadding: const EdgeInsets.only(left: 20), tilePadding: const EdgeInsets.only(left: 40), children: device.buttonPoints .map( (point) => ListTile( leading: Icon( point.function.contains('Status') || point.name.contains('Missing') ? Icons.info_outline : point.function.contains('IR') ? Icons.settings_remote : Icons.touch_app, size: 20, color: Colors.green, ), title: Text(point.name), subtitle: Text(point.function), contentPadding: const EdgeInsets.only(left: 16), dense: true, ), ) .toList(), ), ); } if (device.isMultisensor) { subItems.add( ExpansionTile( title: const Text('Sensor Data'), leading: const Icon(Icons.sensors), childrenPadding: const EdgeInsets.only(left: 20), tilePadding: const EdgeInsets.only(left: 40), children: device.sensorInfo.entries .map( (entry) => ListTile( title: Text('${entry.key}: ${entry.value}'), dense: true, ), ) .toList(), ), ); } return Card( margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4), child: ExpansionTile( leading: CircleAvatar( backgroundImage: AssetImage(getDeviceIconAsset(device)), backgroundColor: Colors.transparent, ), title: Text( deviceName, style: const TextStyle(fontWeight: FontWeight.bold), ), subtitle: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text('Address: ${device.address}'), Text('Type: ${device.props}'), ], ), trailing: Row( mainAxisSize: MainAxisSize.min, children: [ IconButton( icon: const Icon(Icons.edit), onPressed: () => _editDevice(device), tooltip: 'Edit device', ), IconButton( icon: const Icon(Icons.delete), onPressed: () => _confirmDeleteDevice(device), tooltip: 'Remove device', ), ], ), onExpansionChanged: (expanded) { if (expanded) { _showDeviceDetails(device); } }, children: subItems, ), ); } void _showDeviceAlarmInfo(HelvarDevice device) { showDialog( context: context, builder: (context) => AlertDialog( title: Text('Alarm Info: ${device.description}'), content: Column( mainAxisSize: MainAxisSize.min, crossAxisAlignment: CrossAxisAlignment.start, children: [ Text('State: ${device.state}'), if (device.deviceStateCode != null) Text( 'State Code: 0x${device.deviceStateCode!.toRadixString(16)}', ), const SizedBox(height: 8), const Text('No active alarms'), ], ), actions: [closeAction(context)], ), ); } void _handleMenuAction(String action) async { switch (action) { case 'discover': await _discoverDevices(); break; case 'import': await _importDevices(); break; case 'export': await _exportDevices(); break; case 'add_output': _addOutputDevice(); break; case 'add_input': _addInputDevice(); break; case 'add_emergency': _addEmergencyDevice(); break; case 'delete_all': _deleteAllDevices(); break; } } Future<void> _importDevices() async { try { final filePath = await FileDialogHelper.pickJsonFileToOpen(); if (filePath == null) return; setState(() { _isLoading = true; }); final routerStorageService = ref.read(routerStorageServiceProvider); final devices = await routerStorageService.importRouterDevices(filePath); if (!mounted) return; final merge = await showDialog<bool>( context: context, builder: (context) => AlertDialog( title: const Text('Import Devices'), content: Text( 'Found ${devices.length} devices. Do you want to merge with existing devices or replace them?', ), actions: [ TextButton( onPressed: () => Navigator.of(context).pop(false), child: const Text('Replace'), ), TextButton( onPressed: () => Navigator.of(context).pop(true), child: const Text('Merge'), ), ], ), ); if (merge == null) { setState(() { _isLoading = false; }); return; } if (merge) { final existingAddresses = widget.router.devices .map((d) => d.address) .toSet(); final newDevices = devices .where((d) => !existingAddresses.contains(d.address)) .toList(); for (final device in newDevices) { await ref .read(workgroupsProvider.notifier) .addDeviceToRouter( widget.workgroup.id, widget.router.address, device, ); } showSnackBarMsg(context, 'Added ${newDevices.length} new devices'); } else { widget.router.devices.clear(); for (final device in devices) { await ref .read(workgroupsProvider.notifier) .addDeviceToRouter( widget.workgroup.id, widget.router.address, device, ); } showSnackBarMsg( context, 'Replaced with ${devices.length} imported devices', ); } setState(() { _devices = widget.router.devices; _organizeDevicesBySubnet(); _isLoading = false; }); } catch (e) { showSnackBarMsg(context, 'Error importing devices: $e'); setState(() { _isLoading = false; }); } } Future<void> _exportDevices() async { try { if (_devices.isEmpty) { showSnackBarMsg(context, 'No devices to export'); return; } final filePath = await FileDialogHelper.pickJsonFileToSave( "helvarnet_devices.json", ); if (filePath == null) return; setState(() { _isLoading = true; }); final routerStorageService = ref.read(routerStorageServiceProvider); await routerStorageService.exportRouterDevices(_devices, filePath); if (!mounted) return; showSnackBarMsg( context, 'Exported ${_devices.length} devices to $filePath', ); setState(() { _isLoading = false; }); } catch (e) { if (!mounted) return; showSnackBarMsg(context, 'Error exporting devices: $e'); setState(() { _isLoading = false; }); } } void _editDevice(HelvarDevice device) { showSnackBarMsg(context, 'Edit Device feature coming soon'); } Future<void> _confirmDeleteDevice(HelvarDevice device) async { final result = await showDialog<bool>( context: context, builder: (context) => AlertDialog( title: const Text('Delete Device'), content: Text( 'Are you sure you want to delete the device "${device.description.isEmpty ? 'Device ${device.deviceId}' : device.description}"?', ), actions: [ cancelAction(context), TextButton( onPressed: () => Navigator.of(context).pop(true), child: const Text('Delete', style: TextStyle(color: Colors.red)), ), ], ), ); if (result == true) { await ref .read(workgroupsProvider.notifier) .removeDeviceFromRouter( widget.workgroup.id, widget.router.address, device, ); if (!mounted) return; showSnackBarMsg(context, 'Device deleted'); setState(() { _devices = widget.router.devices; _organizeDevicesBySubnet(); }); } } void _showDeviceDetails(HelvarDevice device) { showDialog( context: context, builder: (context) => AlertDialog( title: Text( device.description.isEmpty ? 'Device ${device.deviceId}' : device.description, ), content: SingleChildScrollView( child: Column( crossAxisAlignment: CrossAxisAlignment.start, mainAxisSize: MainAxisSize.min, children: [ _buildDetailRow('Address', device.address), _buildDetailRow('Type', device.props), _buildDetailRow('ID', device.deviceId.toString()), if (device.deviceTypeCode != null) _buildDetailRow( 'Type Code', '0x${device.deviceTypeCode!.toRadixString(16)}', ), _buildDetailRow('Device Type', device.helvarType), _buildDetailRow('Emergency', device.emergency.toString()), _buildDetailRow('Block ID', device.blockId), _buildDetailRow('Scene ID', device.sceneId), if (device.state.isNotEmpty) _buildDetailRow('State', device.state), if (device.hexId.isNotEmpty) _buildDetailRow('Hex ID', device.hexId), if (device.helvarType == 'output' && device is HelvarDriverOutputDevice) _buildDetailRow('Level', '${device.level}%'), if (device is HelvarDriverInputDevice && device.isButtonDevice && device.buttonPoints.isNotEmpty) ...[ const Divider(), const Text( 'Button Points:', style: TextStyle(fontWeight: FontWeight.bold), ), const SizedBox(height: 8), ...device.buttonPoints.map( (point) => Padding( padding: const EdgeInsets.only(left: 16.0, bottom: 4.0), child: Text('${point.name} (${point.function})'), ), ), ], if (device.isMultisensor) ...[ const Divider(), const Text( 'Sensor Capabilities:', style: TextStyle(fontWeight: FontWeight.bold), ), const SizedBox(height: 8), ...device.sensorInfo.entries.map( (entry) => Padding( padding: const EdgeInsets.only(left: 16.0, bottom: 4.0), child: Text('${entry.key}: ${entry.value}'), ), ), ], ], ), ), actions: [ closeAction(context), if (device.helvarType == 'output') ElevatedButton( onPressed: () => _controlOutputDevice(device), child: const Text('Control'), ) else if (device.helvarType == 'emergency') ElevatedButton( onPressed: () => _testEmergencyDevice(device), child: const Text('Test'), ), ], ), ); } void _controlOutputDevice(HelvarDevice device) { showSnackBarMsg(context, 'Device control feature coming soon'); } void _testEmergencyDevice(HelvarDevice device) { showSnackBarMsg(context, 'Emergency device test feature coming soon'); } Widget _buildDetailRow(String label, String value) { return Padding( padding: const EdgeInsets.symmetric(vertical: 4.0), child: Row( crossAxisAlignment: CrossAxisAlignment.start, children: [ SizedBox( width: 100, child: Text( '$label:', style: const TextStyle(fontWeight: FontWeight.bold), ), ), Expanded(child: Text(value)), ], ), ); } Future<void> _discoverDevices() async { if (widget.router.ipAddress.isEmpty) { showSnackBarMsg(context, 'Router IP address is not set'); return; } setState(() { _isLoading = true; }); try { logInfo( 'Starting device discovery for router: ${widget.router.ipAddress}', ); final discoveryService = ref.watch(discoveryServiceProvider); await Future.delayed(const Duration(milliseconds: 100)); logInfo('Discovery service obtained, attempting connection...'); final discoveredRouter = await discoveryService .discoverRouterWithPersistentConnection(widget.router.ipAddress); logInfo('Discovery completed. Router found: ${discoveredRouter != null}'); if (discoveredRouter == null || discoveredRouter.devices.isEmpty) { if (!mounted) return; final message = discoveredRouter == null ? 'Failed to connect to router' : 'No devices discovered'; showSnackBarMsg(context, message); setState(() { _isLoading = false; }); return; } final discoveredDevices = discoveredRouter.devices; logInfo('Found ${discoveredDevices.length} devices'); if (!mounted) return; final shouldAdd = await showDialog<bool>( context: context, builder: (context) => AlertDialog( title: const Text('Devices Discovered'), content: Text( 'Found ${discoveredDevices.length} devices. Do you want to add them?', ), actions: [ cancelAction(context), TextButton( onPressed: () => Navigator.of(context).pop(true), child: const Text('Add Devices'), ), ], ), ) ?? false; if (!shouldAdd || !mounted) { setState(() { _isLoading = false; }); return; } final existingAddresses = _devices.map((d) => d.address).toSet(); final newDevices = discoveredDevices .where((d) => !existingAddresses.contains(d.address)) .toList(); logInfo('Adding ${newDevices.length} new devices'); if (newDevices.isNotEmpty) { await ref .read(workgroupsProvider.notifier) .addMultipleDevicesToRouter( widget.workgroup.id, widget.router.address, newDevices, ); } if (!mounted) return; showSnackBarMsg(context, 'Added ${newDevices.length} devices'); setState(() { _devices = widget.router.devices; _organizeDevicesBySubnet(); _isLoading = false; }); } catch (e, stackTrace) { logError('Error discovering devices: $e', stackTrace: stackTrace); if (!mounted) return; showSnackBarMsg(context, 'Error discovering devices: $e'); setState(() { _isLoading = false; }); } } void _deleteAllDevices() { showDialog( context: context, builder: (context) => AlertDialog( title: const Text('Delete All Devices'), content: Column( mainAxisSize: MainAxisSize.min, crossAxisAlignment: CrossAxisAlignment.start, children: [ const Text('Are you sure you want to delete all devices?'), const SizedBox(height: 8), Text( 'This will permanently remove all ${_devices.length} devices from this router.', style: const TextStyle(fontWeight: FontWeight.bold), ), const SizedBox(height: 8), const Text( 'This action cannot be undone.', style: TextStyle(color: Colors.red), ), ], ), actions: [ cancelAction(context), TextButton( onPressed: () => Navigator.of(context).pop(true), style: TextButton.styleFrom(foregroundColor: Colors.red), child: const Text('Delete All'), ), ], ), ).then((confirmed) async { if (confirmed == true) { await _performDeleteAllDevices(); } }); } Future<void> _performDeleteAllDevices() async { if (_devices.isEmpty) { showSnackBarMsg(context, 'No devices to delete'); return; } setState(() { _isLoading = true; }); try { final devicesToDelete = List<HelvarDevice>.from(_devices); for (final device in devicesToDelete) { await ref .read(workgroupsProvider.notifier) .removeDeviceFromRouter( widget.workgroup.id, widget.router.address, device, ); } if (!mounted) return; setState(() { _devices.clear(); _devicesBySubnet.clear(); _isLoading = false; }); showSnackBarMsg( context, 'Successfully deleted ${devicesToDelete.length} devices', ); logInfo( 'Deleted all ${devicesToDelete.length} devices from router ${widget.router.address}', ); } catch (e) { logError('Error deleting all devices: $e'); if (!mounted) return; showSnackBarMsg(context, 'Error deleting devices: $e'); setState(() { _isLoading = false; _devices = widget.router.devices; _organizeDevicesBySubnet(); }); } } } 

// File: \lib\screens\details\subnet_detail_screen.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import '../../models/helvar_models/helvar_device.dart'; import '../../models/helvar_models/helvar_router.dart'; import '../../models/helvar_models/workgroup.dart'; import '../../utils/device_icons.dart'; import '../../utils/general_ui.dart'; class SubnetDetailScreen extends ConsumerStatefulWidget { final Workgroup workgroup; final HelvarRouter router; final int subnetNumber; final List<HelvarDevice> devices; final Function(String, {Workgroup? workgroup, HelvarRouter? router, HelvarDevice? device})? onNavigate; const SubnetDetailScreen({ super.key, required this.workgroup, required this.router, required this.subnetNumber, required this.devices, this.onNavigate, }); @override SubnetDetailScreenState createState() => SubnetDetailScreenState(); } class SubnetDetailScreenState extends ConsumerState<SubnetDetailScreen> { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( leading: Text('${widget.router.description} Subnet ${widget.subnetNumber}'), centerTitle: true, actions: [ IconButton( icon: const Icon(Icons.refresh), tooltip: 'Refresh Devices', onPressed: _refreshDevices, ), ], ), body: widget.devices.isEmpty ? const Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Icon( Icons.device_unknown, size: 64, color: Colors.grey, ), SizedBox(height: 16), Text( 'No devices found in this subnet', style: TextStyle(fontSize: 18), ), ], ), ) : _buildDevicesList(), ); } Widget _buildDevicesList() { return ListView.builder( padding: const EdgeInsets.all(16.0), itemCount: widget.devices.length, itemBuilder: (context, index) { final device = widget.devices[index]; return _buildDeviceCard(device); }, ); } Widget _buildDeviceCard(HelvarDevice device) { final deviceName = device.description.isEmpty ? 'Device ${device.deviceId}' : device.description; return Card( margin: const EdgeInsets.symmetric(vertical: 8), child: Column( children: [ ListTile( leading: CircleAvatar( backgroundImage: AssetImage(getDeviceIconAsset(device)), backgroundColor: Colors.transparent, ), title: Text( deviceName, style: const TextStyle(fontWeight: FontWeight.bold), ), subtitle: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text('Address: ${device.address}'), Text('Type: ${device.helvarType}'), if (device.state.isNotEmpty) Text('State: ${device.state}'), ], ), isThreeLine: true, trailing: Row( mainAxisSize: MainAxisSize.min, children: [ if (device.emergency) const Icon(Icons.warning, color: Colors.red, size: 20), if (device.isButtonDevice) const Icon(Icons.touch_app, color: Colors.blue, size: 20), if (device.isMultisensor) const Icon(Icons.sensors, color: Colors.green, size: 20), const Icon(Icons.arrow_forward_ios, size: 16), ], ), onTap: () => _navigateToDeviceDetail(device), ), if (device.helvarType == 'output') Padding( padding: const EdgeInsets.only(right: 8.0, bottom: 8.0), child: Row( mainAxisAlignment: MainAxisAlignment.end, children: [ TextButton.icon( icon: const Icon(Icons.power_settings_new, size: 16), label: const Text('Control'), onPressed: () => _showDeviceControls(device), ), ], ), ), ], ), ); } void _navigateToDeviceDetail(HelvarDevice device) { if (widget.onNavigate != null) { widget.onNavigate!( 'deviceDetail', workgroup: widget.workgroup, router: widget.router, device: device, ); } else { showSnackBarMsg(context, 'Device Detail navigation not available'); } } void _showDeviceControls(HelvarDevice device) { showSnackBarMsg(context, 'Device controls coming soon'); } void _refreshDevices() { showSnackBarMsg(context, 'Refresh functionality coming soon'); } } 

// File: \lib\screens\details\workgroup_detail_screen.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import '../../models/helvar_models/workgroup.dart'; import '../../models/helvar_models/helvar_router.dart'; import '../../providers/workgroups_provider.dart'; import '../../providers/group_polling_provider.dart'; import '../lists/groups_list_screen.dart'; import 'router_detail_screen.dart'; class WorkgroupDetailScreen extends ConsumerStatefulWidget { final Workgroup workgroup; const WorkgroupDetailScreen({super.key, required this.workgroup}); @override WorkgroupDetailScreenState createState() => WorkgroupDetailScreenState(); } class WorkgroupDetailScreenState extends ConsumerState<WorkgroupDetailScreen> { bool _isLoading = false; Workgroup get currentWorkgroup { final workgroups = ref.watch(workgroupsProvider); return workgroups.firstWhere( (wg) => wg.id == widget.workgroup.id, orElse: () => widget.workgroup, ); } @override void initState() { super.initState(); _isLoading = false; } @override Widget build(BuildContext context) { final workgroup = currentWorkgroup; final pollingState = ref.watch(pollingStateProvider); final isPollingActive = pollingState[workgroup.id] ?? false; return Scaffold( appBar: AppBar( title: Text(workgroup.description), centerTitle: true, actions: const [], ), body: _isLoading ? const Center(child: CircularProgressIndicator()) : SingleChildScrollView( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ _buildInfoCard(context), const SizedBox(height: 24), _buildPollingCard(context), const SizedBox(height: 24), Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ const Text( 'Groups', style: TextStyle( fontSize: 20, fontWeight: FontWeight.bold, ), ), TextButton.icon( icon: const Icon(Icons.navigate_next), label: const Text('View All Groups'), onPressed: () { Navigator.push( context, MaterialPageRoute( builder: (context) => GroupsListScreen(workgroup: workgroup), ), ); }, ), ], ), const SizedBox(height: 24), const Text( 'Routers', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold), ), const SizedBox(height: 8), _buildRoutersList(context), ], ), ), ); } Widget _buildInfoCard(BuildContext context) { final workgroup = currentWorkgroup; return Card( elevation: 2, child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( children: [ const Icon(Icons.group_work, color: Colors.blue), const SizedBox(width: 8), Text( 'Workgroup Details', style: Theme.of(context).textTheme.titleLarge, ), ], ), const Divider(), _buildDetailRow('ID', workgroup.id), _buildDetailRow('Description', workgroup.description), _buildDetailRow('Network Interface', workgroup.networkInterface), _buildDetailRow( 'Number of Routers', workgroup.routers.length.toString(), ), _buildDetailRow( 'Number of Groups', workgroup.groups.length.toString(), ), _buildDetailRow( 'Gateway Router IP', workgroup.gatewayRouterIpAddress.isEmpty ? 'Not set' : workgroup.gatewayRouterIpAddress, ), _buildDetailRow( 'Refresh Props After Action', workgroup.refreshPropsAfterAction.toString(), ), ], ), ), ); } Widget _buildPollingCard(BuildContext context) { final workgroup = currentWorkgroup; final pollingState = ref.watch(pollingStateProvider); final isPollingActive = pollingState[workgroup.id] ?? false; return Card( elevation: 2, child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( children: [ Icon( workgroup.pollEnabled ? Icons.autorenew : Icons.pause_circle_outline, color: workgroup.pollEnabled ? Colors.green : Colors.orange, ), const SizedBox(width: 8), Text( 'Power Consumption Polling', style: Theme.of(context).textTheme.titleLarge, ), ], ), const Divider(), Row( children: [ const SizedBox( width: 140, child: Text( 'Polling Enabled:', style: TextStyle(fontWeight: FontWeight.bold), ), ), Expanded( child: DropdownButton<bool>( value: workgroup.pollEnabled, isExpanded: true, onChanged: (bool? newValue) { if (newValue != null) { _togglePolling(newValue); } }, items: const [ DropdownMenuItem<bool>( value: false, child: Row( children: [ Icon( Icons.pause_circle_outline, size: 16, color: Colors.orange, ), SizedBox(width: 8), Text('Disabled'), ], ), ), DropdownMenuItem<bool>( value: true, child: Row( children: [ Icon( Icons.autorenew, size: 16, color: Colors.green, ), SizedBox(width: 8), Text('Enabled'), ], ), ), ], ), ), ], ), const SizedBox(height: 12), if (workgroup.pollEnabled) ...[ Container( padding: const EdgeInsets.all(12), decoration: BoxDecoration( color: Colors.green.withValues(alpha: 0.1 * 255), borderRadius: BorderRadius.circular(8), border: Border.all( color: Colors.green.withValues(alpha: 0.3 * 255), ), ), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( children: [ Icon( isPollingActive ? Icons.check_circle : Icons.pending, size: 16, color: isPollingActive ? Colors.green : Colors.orange, ), const SizedBox(width: 8), Text( isPollingActive ? 'Polling Active' : 'Starting Polling...', style: TextStyle( fontWeight: FontWeight.w500, color: isPollingActive ? Colors.green[700] : Colors.orange[700], ), ), ], ), const SizedBox(height: 8), Text( 'Groups will be polled automatically based on their individual polling intervals.', style: TextStyle(fontSize: 12, color: Colors.green[600]), ), if (workgroup.groups.isNotEmpty) ...[ const SizedBox(height: 8), Text( 'Active Groups: ${workgroup.groups.length}', style: TextStyle( fontSize: 12, fontWeight: FontWeight.w500, color: Colors.green[700], ), ), const SizedBox(height: 4), Wrap( spacing: 4, runSpacing: 4, children: workgroup.groups.map((group) { return Container( padding: const EdgeInsets.symmetric( horizontal: 6, vertical: 2, ), decoration: BoxDecoration( color: Colors.green.withValues(alpha: 0.2 * 255), borderRadius: BorderRadius.circular(12), ), child: Text( 'Group ${group.groupId} (${group.powerPollingMinutes}min)', style: const TextStyle(fontSize: 10), ), ); }).toList(), ), ], ], ), ), ] else ...[ Container( padding: const EdgeInsets.all(12), decoration: BoxDecoration( color: Colors.grey.withValues(alpha: 0.1 * 255), borderRadius: BorderRadius.circular(8), border: Border.all( color: Colors.grey.withValues(alpha: 0.3 * 255), ), ), child: Row( children: [ Icon(Icons.info_outline, size: 16, color: Colors.grey[600]), const SizedBox(width: 8), Expanded( child: Text( 'Automatic power consumption polling is disabled. Enable to start monitoring group power consumption.', style: TextStyle(fontSize: 12, color: Colors.grey[600]), ), ), ], ), ), ], if (workgroup.lastPollTime != null) ...[ const SizedBox(height: 8), _buildDetailRow( 'Last Poll Started', _formatDateTime(workgroup.lastPollTime!), ), ], ], ), ), ); } String _formatDateTime(DateTime dateTime) { final now = DateTime.now(); final difference = now.difference(dateTime); if (difference.inMinutes < 1) { return 'Just now'; } else if (difference.inMinutes < 60) { return '${difference.inMinutes} minute${difference.inMinutes == 1 ? '' : 's'} ago'; } else if (difference.inHours < 24) { return '${difference.inHours} hour${difference.inHours == 1 ? '' : 's'} ago'; } else { return '${dateTime.day}/${dateTime.month}/${dateTime.year} ${dateTime.hour}:${dateTime.minute.toString().padLeft(2, '0')}'; } } void _togglePolling(bool enabled) async { setState(() { _isLoading = true; }); try { await ref .read(workgroupsProvider.notifier) .toggleWorkgroupPolling(widget.workgroup.id, enabled); if (enabled) { ref .read(pollingStateProvider.notifier) .startPolling(widget.workgroup.id); } else { ref .read(pollingStateProvider.notifier) .stopPolling(widget.workgroup.id); } final message = enabled ? 'Automatic polling enabled for all groups in this workgroup' : 'Automatic polling disabled'; if (mounted) { ScaffoldMessenger.of(context).showSnackBar( SnackBar( content: Text(message), backgroundColor: enabled ? Colors.green : Colors.orange, ), ); } } catch (e) { if (mounted) { ScaffoldMessenger.of(context).showSnackBar( SnackBar( content: Text('Error toggling polling: $e'), backgroundColor: Colors.red, ), ); } } finally { if (mounted) { setState(() { _isLoading = false; }); } } } Widget _buildDetailRow(String label, String value) { return Padding( padding: const EdgeInsets.symmetric(vertical: 4.0), child: Row( crossAxisAlignment: CrossAxisAlignment.start, children: [ SizedBox( width: 140, child: Text( '$label:', style: const TextStyle(fontWeight: FontWeight.bold), ), ), Expanded(child: Text(value)), ], ), ); } Widget _buildRoutersList(BuildContext context) { final workgroup = currentWorkgroup; return ListView.builder( shrinkWrap: true, physics: const NeverScrollableScrollPhysics(), itemCount: workgroup.routers.length, itemBuilder: (context, index) { final router = workgroup.routers[index]; return _buildRouterCard(context, router); }, ); } Widget _buildRouterCard(BuildContext context, HelvarRouter router) { return Card( margin: const EdgeInsets.symmetric(vertical: 8), child: Column( children: [ ListTile( title: Text( router.description, style: const TextStyle(fontWeight: FontWeight.bold), ), subtitle: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text('IP Address: ${router.ipAddress}'), Text('Address: ${router.address}'), Text('Description: ${router.description}'), Text('Devices: ${router.devices.length}'), ], ), isThreeLine: true, leading: const CircleAvatar(child: Icon(Icons.router)), onTap: () { Navigator.push( context, MaterialPageRoute( builder: (context) => RouterDetailScreen( workgroup: currentWorkgroup, router: router, ), ), ); }, ), Padding( padding: const EdgeInsets.only(right: 8.0, bottom: 8.0), child: Row( mainAxisAlignment: MainAxisAlignment.end, children: [ TextButton.icon( icon: const Icon(Icons.devices), label: const Text('Manage Devices'), onPressed: () { Navigator.push( context, MaterialPageRoute( builder: (context) => RouterDetailScreen( workgroup: currentWorkgroup, router: router, ), ), ); }, ), ], ), ), ], ), ); } } 

// File: \lib\screens\dialogs\action_dialogs.dart
import 'package:flutter/material.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; import '../../models/helvar_models/helvar_device.dart'; import '../../models/helvar_models/helvar_group.dart'; import '../../models/helvar_models/workgroup.dart'; import '../../utils/general_ui.dart'; import '../actions.dart'; Future<void> showDeviceDirectProportionDialog( BuildContext context, HelvarDevice device, ) async { final TextEditingController controller = TextEditingController(); await Future.delayed(Duration.zero); if (!context.mounted) return; final result = await showDialog<String>( context: context, builder: (context) => AlertDialog( title: const Row( children: [ Icon(Icons.lightbulb), SizedBox(width: 8), Text('Direct Proportion'), ], ), content: TextField( controller: controller, autofocus: true, keyboardType: TextInputType.number, decoration: const InputDecoration( border: OutlineInputBorder(), labelText: 'Proportion (-100 to 100)', ), ), actions: [ cancelAction(context), confirmActionWithText(context, controller.text), ], ), ); if (result != null && result.isNotEmpty) { try { final proportion = int.parse(result); if (proportion >= -100 && proportion <= 100) { performDeviceDirectProportion(context, device, proportion); } else { showSnackBarMsg(context, 'Proportion must be between -100 and 100'); } } catch (e) { showSnackBarMsg(context, 'Invalid proportion value'); } } } Future<void> showDeviceRecallSceneDialog( BuildContext context, HelvarDevice device, ) async { final TextEditingController controller = TextEditingController(); await Future.delayed(Duration.zero); if (!context.mounted) return; final result = await showDialog<String>( context: context, builder: (context) => AlertDialog( title: const Row( children: [ Icon(Icons.lightbulb), SizedBox(width: 8), Text('Recall Scene'), ], ), content: TextField( controller: controller, autofocus: true, keyboardType: TextInputType.number, decoration: const InputDecoration( border: OutlineInputBorder(), labelText: 'Scene Number', ), ), actions: [ cancelAction(context), confirmActionWithText(context, controller.text), ], ), ); if (result != null && result.isNotEmpty) { performDeviceRecallScene(context, device, int.parse(result)); } } Future<void> showRecallSceneDialog( BuildContext context, HelvarGroup group, Workgroup workgroup, ) async { final TextEditingController controller = TextEditingController(); await Future.delayed(Duration.zero);  if (!context.mounted) return; final result = await showDialog<String>( context: context, builder: (context) => AlertDialog( title: Row( children: [ Image.asset( 'assets/icons/helvar_icon.png', width: 24, height: 24, errorBuilder: (context, error, stackTrace) => const Icon(Icons.lightbulb), ), const SizedBox(width: 8), const Text('Recall Scene'), ], ), content: TextField( controller: controller, autofocus: true, keyboardType: TextInputType.number, decoration: const InputDecoration(border: OutlineInputBorder()), ), actions: [ cancelAction(context), confirmActionWithText(context, controller.text), ], ), ); if (result != null && result.isNotEmpty) { performRecallScene(context, group, int.parse(result)); } } Future<void> showStoreSceneDialog( BuildContext context, HelvarGroup group, Workgroup workgroup, ) async { final TextEditingController controller = TextEditingController(); await Future.delayed(Duration.zero); if (!context.mounted) return; final result = await showDialog<String>( context: context, builder: (context) => AlertDialog( title: Row( children: [ Image.asset( 'assets/icons/helvar_icon.png', width: 24, height: 24, errorBuilder: (context, error, stackTrace) => const Icon(Icons.lightbulb), ), const SizedBox(width: 8), const Text('Store Scene'), ], ), content: TextField( controller: controller, autofocus: true, keyboardType: TextInputType.number, decoration: const InputDecoration(border: OutlineInputBorder()), ), actions: [ cancelAction(context), confirmActionWithText(context, controller.text), ], ), ); if (result != null && result.isNotEmpty) { performStoreScene(context, group, int.parse(result)); } } Future<void> showDirectProportionDialog( BuildContext context, HelvarGroup group, Workgroup workgroup, ) async { final TextEditingController controller = TextEditingController(); await Future.delayed(Duration.zero); if (!context.mounted) return; final result = await showDialog<String>( context: context, builder: (context) => AlertDialog( title: Row( children: [ Image.asset( 'assets/icons/helvar_icon.png', width: 24, height: 24, errorBuilder: (context, error, stackTrace) => const Icon(Icons.lightbulb), ), const SizedBox(width: 8), const Text('Direct Proportion'), ], ), content: TextField( controller: controller, autofocus: true, keyboardType: TextInputType.number, decoration: const InputDecoration(border: OutlineInputBorder()), ), actions: [ cancelAction(context), confirmActionWithText(context, controller.text), ], ), ); if (result != null && result.isNotEmpty) { performDirectProportion(context, group, int.parse(result)); } } Future<void> showModifyProportionDialog( BuildContext context, HelvarGroup group, Workgroup workgroup, ) async { final TextEditingController controller = TextEditingController(); await Future.delayed(Duration.zero); if (!context.mounted) return; final result = await showDialog<String>( context: context, builder: (context) => AlertDialog( title: Row( children: [ Image.asset( 'assets/icons/helvar_icon.png', width: 24, height: 24, errorBuilder: (context, error, stackTrace) => const Icon(Icons.lightbulb), ), const SizedBox(width: 8), const Text('Modify Proportion'), ], ), content: TextField( controller: controller, autofocus: true, keyboardType: TextInputType.number, decoration: const InputDecoration(border: OutlineInputBorder()), ), actions: [ cancelAction(context), confirmActionWithText(context, controller.text), ], ), ); if (result != null && result.isNotEmpty) { performModifyProportion(context, group, int.parse(result)); } } Future<void> showDirectLevelDialog( BuildContext context, HelvarGroup group, Workgroup workgroup, ) async { final TextEditingController controller = TextEditingController(); await Future.delayed(Duration.zero); if (!context.mounted) return; final result = await showDialog<String>( context: context, builder: (context) => AlertDialog( title: Row( children: [ Image.asset( 'assets/icons/helvar_icon.png', width: 24, height: 24, errorBuilder: (context, error, stackTrace) => const Icon(Icons.lightbulb), ), const SizedBox(width: 8), const Text('Direct Level'), ], ), content: TextField( controller: controller, autofocus: true, keyboardType: TextInputType.number, decoration: const InputDecoration(border: OutlineInputBorder()), ), actions: [ cancelAction(context), confirmActionWithText(context, controller.text), ], ), ); if (result != null && result.isNotEmpty) { performDirectLevel(context, group, int.parse(result)); } } Future<void> showDeviceDirectLevelDialog( BuildContext context, HelvarDevice device, ) async { final TextEditingController controller = TextEditingController(); await Future.delayed(Duration.zero); if (!context.mounted) return; final result = await showDialog<String>( context: context, builder: (context) => AlertDialog( title: const Row( children: [ Icon(Icons.lightbulb), SizedBox(width: 8), Text('Direct Level'), ], ), content: TextField( controller: controller, autofocus: true, keyboardType: TextInputType.number, decoration: const InputDecoration( border: OutlineInputBorder(), labelText: 'Level (0-100)', ), ), actions: [ cancelAction(context), confirmActionWithText(context, controller.text), ], ), ); if (result != null && result.isNotEmpty) { try { final level = int.parse(result); if (level >= 0 && level <= 100) { performDeviceDirectLevel(context, device, level); } else { showSnackBarMsg(context, 'Level must be between 0 and 100'); } } catch (e) { showSnackBarMsg(context, 'Invalid level value'); } } } Future<void> showDeviceModifyProportionDialog( BuildContext context, HelvarDevice device, ) async { final TextEditingController controller = TextEditingController(); await Future.delayed(Duration.zero); if (!context.mounted) return; final result = await showDialog<String>( context: context, builder: (context) => AlertDialog( title: const Row( children: [ Icon(Icons.lightbulb), SizedBox(width: 8), Text('Modify Proportion'), ], ), content: TextField( controller: controller, autofocus: true, keyboardType: TextInputType.number, decoration: const InputDecoration( border: OutlineInputBorder(), labelText: 'Change amount (-100 to 100)', ), ), actions: [ cancelAction(context), confirmActionWithText(context, controller.text), ], ), ); if (result != null && result.isNotEmpty) { try { final change = int.parse(result); if (change >= -100 && change <= 100) { performDeviceModifyProportion(context, device, change); } else { showSnackBarMsg(context, 'Change amount must be between -100 and 100'); } } catch (e) { showSnackBarMsg(context, 'Invalid change amount'); } } } 

// File: \lib\screens\dialogs\add_component_dialog.dart


// File: \lib\screens\dialogs\add_device_dialog.dart
import 'package:flutter/material.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; import '../../models/helvar_models/emergency_device.dart'; import '../../models/helvar_models/helvar_device.dart'; import '../../models/helvar_models/input_device.dart'; import '../../models/helvar_models/output_device.dart'; enum DeviceType { output, input, emergency } class AddDeviceDialog extends StatefulWidget { final int nextDeviceId; final List<String> existingSubnets; const AddDeviceDialog({ super.key, required this.nextDeviceId, required this.existingSubnets, }); @override AddDeviceDialogState createState() => AddDeviceDialogState(); } class AddDeviceDialogState extends State<AddDeviceDialog> { final _formKey = GlobalKey<FormState>(); DeviceType _deviceType = DeviceType.output; final _addressController = TextEditingController(); final _descriptionController = TextEditingController(); String? _selectedSubnet; final _deviceIndexController = TextEditingController(); @override void initState() { super.initState(); if (widget.existingSubnets.isNotEmpty) { _selectedSubnet = widget.existingSubnets.first; } } @override Widget build(BuildContext context) { return AlertDialog( title: const Text('Add Device'), content: Form( key: _formKey, child: SingleChildScrollView( child: Column( mainAxisSize: MainAxisSize.min, children: [ DropdownButtonFormField<DeviceType>( decoration: const InputDecoration( labelText: 'Device Type', border: OutlineInputBorder(), ), value: _deviceType, onChanged: (value) { if (value != null) { setState(() { _deviceType = value; }); } }, items: DeviceType.values.map((type) { return DropdownMenuItem<DeviceType>( value: type, child: Text(type.toString().split('.').last), ); }).toList(), ), const SizedBox(height: 16), if (widget.existingSubnets.isNotEmpty) ...[ DropdownButtonFormField<String>( decoration: const InputDecoration( labelText: 'Subnet', border: OutlineInputBorder(), ), value: _selectedSubnet, onChanged: (value) { if (value != null) { setState(() { _selectedSubnet = value; }); } }, items: [ ...widget.existingSubnets.map((subnet) { return DropdownMenuItem<String>( value: subnet, child: Text('Subnet $subnet'), ); }), const DropdownMenuItem<String>( value: 'custom', child: Text('Custom Subnet...'), ), ], ), const SizedBox(height: 16), ], if (_selectedSubnet == 'custom' || widget.existingSubnets.isEmpty) TextFormField( controller: _addressController, decoration: const InputDecoration( labelText: 'Full Device Address (e.g., 1.1.1.1)', border: OutlineInputBorder(), ), validator: (value) { if (value == null || value.isEmpty) { return 'Please enter a device address'; } if (!RegExp(r'^\d+\.\d+\.\d+\.\d+$').hasMatch(value)) { return 'Please enter a valid address (e.g., 1.1.1.1)'; } return null; }, ) else ...[ TextFormField( controller: _deviceIndexController, decoration: const InputDecoration( labelText: 'Device Index', border: OutlineInputBorder(), ), keyboardType: TextInputType.number, validator: (value) { if (value == null || value.isEmpty) { return 'Please enter a device index'; } if (int.tryParse(value) == null || int.parse(value) < 1 || int.parse(value) > 255) { return 'Please enter a valid device index (1-255)'; } return null; }, ), ], const SizedBox(height: 16), TextFormField( controller: _descriptionController, decoration: const InputDecoration( labelText: 'Description', border: OutlineInputBorder(), ), ), ], ), ), ), actions: [ cancelAction(context), ElevatedButton( onPressed: () { if (_formKey.currentState!.validate()) { final String deviceAddress; if (_selectedSubnet != 'custom' && _selectedSubnet != null && widget.existingSubnets.isNotEmpty) { deviceAddress = '$_selectedSubnet.${_deviceIndexController.text}'; } else { deviceAddress = _addressController.text; } final HelvarDevice device; switch (_deviceType) { case DeviceType.input: device = HelvarDriverInputDevice( deviceId: widget.nextDeviceId, address: deviceAddress, description: _descriptionController.text.isEmpty ? 'Input Device ${widget.nextDeviceId}' : _descriptionController.text, props: '', ); break; case DeviceType.emergency: device = HelvarDriverEmergencyDevice( deviceId: widget.nextDeviceId, address: deviceAddress, description: _descriptionController.text.isEmpty ? 'Emergency Device ${widget.nextDeviceId}' : _descriptionController.text, emergency: true, ); break; case DeviceType.output: device = HelvarDriverOutputDevice( deviceId: widget.nextDeviceId, address: deviceAddress, description: _descriptionController.text.isEmpty ? 'Output Device ${widget.nextDeviceId}' : _descriptionController.text, ); break; } Navigator.of(context).pop(device); } }, child: const Text('Add'), ), ], ); } @override void dispose() { _addressController.dispose(); _descriptionController.dispose(); _deviceIndexController.dispose(); super.dispose(); } } 

// File: \lib\screens\dialogs\device_context_menu.dart
import 'package:flutter/material.dart'; import '../../models/helvar_models/device_action.dart'; import '../../models/helvar_models/helvar_device.dart'; import '../../utils/general_ui.dart'; import 'action_dialogs.dart'; void showDeviceContextMenu(BuildContext context, HelvarDevice device) { final RenderBox button = context.findRenderObject() as RenderBox; final RenderBox overlay = Navigator.of(context).overlay!.context.findRenderObject() as RenderBox; final buttonBottomCenter = button.localToGlobal( Offset(300, button.size.height / 3), ancestor: overlay, ); final RelativeRect position = RelativeRect.fromRect( Rect.fromPoints( buttonBottomCenter, buttonBottomCenter + const Offset(1, 1)), Offset.zero & overlay.size, ); final List<PopupMenuEntry<DeviceAction>> menuItems = []; menuItems.add( PopupMenuItem( value: DeviceAction.clearResult, child: Text(DeviceAction.clearResult.displayName), ), ); if (device.helvarType == 'output') { menuItems.addAll([ PopupMenuItem( value: DeviceAction.recallScene, child: Text(DeviceAction.recallScene.displayName), ), PopupMenuItem( value: DeviceAction.directLevel, child: Text(DeviceAction.directLevel.displayName), ), PopupMenuItem( value: DeviceAction.directProportion, child: Text(DeviceAction.directProportion.displayName), ), PopupMenuItem( value: DeviceAction.modifyProportion, child: Text(DeviceAction.modifyProportion.displayName), ), ]); } else if (device.helvarType == 'emergency') { menuItems.addAll([ PopupMenuItem( value: DeviceAction.emergencyFunctionTest, child: Text(DeviceAction.emergencyFunctionTest.displayName), ), PopupMenuItem( value: DeviceAction.emergencyDurationTest, child: Text(DeviceAction.emergencyDurationTest.displayName), ), PopupMenuItem( value: DeviceAction.stopEmergencyTest, child: Text(DeviceAction.stopEmergencyTest.displayName), ), PopupMenuItem( value: DeviceAction.resetEmergencyBattery, child: Text(DeviceAction.resetEmergencyBattery.displayName), ), ]); } showMenu<DeviceAction>(context: context, position: position, items: menuItems) .then((DeviceAction? value) { if (value == null) return; switch (value) { case DeviceAction.clearResult: _clearDeviceResult(context, device); break; case DeviceAction.recallScene: showDeviceRecallSceneDialog(context, device); break; case DeviceAction.directLevel: showDeviceDirectLevelDialog(context, device); break; case DeviceAction.directProportion: showDeviceDirectProportionDialog(context, device); break; case DeviceAction.modifyProportion: showDeviceModifyProportionDialog(context, device); break; case DeviceAction.emergencyFunctionTest: break; case DeviceAction.emergencyDurationTest: break; case DeviceAction.stopEmergencyTest: break; case DeviceAction.resetEmergencyBattery: break; } }); } void _clearDeviceResult(BuildContext context, HelvarDevice device) { device.clearResult(); showSnackBarMsg(context, 'Cleared result for device ${device.deviceId}'); } 

// File: \lib\screens\dialogs\flowsheet_actions.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; import '../../providers/flowsheet_provider.dart'; void createNewFlowsheet(BuildContext context, WidgetRef ref) { final nameController = TextEditingController(text: 'New Flowsheet'); showDialog( context: context, builder: (context) => AlertDialog( title: const Text('Create New Flowsheet'), content: TextField( controller: nameController, decoration: const InputDecoration( labelText: 'Flowsheet Name', border: OutlineInputBorder(), ), autofocus: true, ), actions: [ cancelAction(context), TextButton( onPressed: () async { final name = nameController.text.trim(); if (name.isNotEmpty) { final flowsheet = await ref .read(flowsheetsProvider.notifier) .createFlowsheet(name); await ref .read(flowsheetsProvider.notifier) .saveFlowsheet(flowsheet.id); Navigator.of(context).pop(); } }, child: const Text('Create'), ), ], ), ); } Future<bool> confirmDeleteFlowsheet( BuildContext context, String flowsheetId, String name, WidgetRef ref, ) async { final result = await showDialog<bool>( context: context, builder: (context) => AlertDialog( title: const Text('Delete Flowsheet'), content: Text('Are you sure you want to delete "$name"?'), actions: [ cancelAction(context), TextButton( style: TextButton.styleFrom(foregroundColor: Colors.red), onPressed: () => Navigator.of(context).pop(true), child: const Text('Delete'), ), ], ), ); if (result == true) { final success = await ref .read(flowsheetsProvider.notifier) .deleteFlowsheet(flowsheetId); return success; } return false; } 

// File: \lib\screens\dialogs\network_interface_dialog.dart
import 'package:flutter/material.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; class NetworkInterfaceDialog extends StatefulWidget { const NetworkInterfaceDialog({super.key, required this.interfaces}); final List<NetworkInterfaceDetails> interfaces; @override NetworkInterfaceDialogState createState() => NetworkInterfaceDialogState(); } class NetworkInterfaceDialogState extends State<NetworkInterfaceDialog> { NetworkInterfaceDetails? selectedInterface; @override void initState() { super.initState(); if (widget.interfaces.isNotEmpty) { selectedInterface = widget.interfaces.first; } } @override Widget build(BuildContext context) { return AlertDialog( title: const Text('Select Interface / Address'), content: DropdownButton<NetworkInterfaceDetails>( isExpanded: true, value: selectedInterface, onChanged: (NetworkInterfaceDetails? newValue) { if (newValue != null) { setState(() { selectedInterface = newValue; }); } }, items: widget.interfaces.map<DropdownMenuItem<NetworkInterfaceDetails>>( (NetworkInterfaceDetails interface) { return DropdownMenuItem<NetworkInterfaceDetails>( value: interface, child: Text('${interface.name} - ${interface.ipv4 ?? "No IP"}'), ); }, ).toList(), ), actions: <Widget>[ cancelAction(context), TextButton( child: const Text('OK'), onPressed: () { Navigator.of(context).pop(selectedInterface); }, ), ], ); } } class NetworkInterfaceDetails { final String name; String? ipv4; String? subnetMask; String? gateway; NetworkInterfaceDetails({required this.name}); @override String toString() { return ''' Interface: $name IPv4: ${ipv4 ?? 'N/A'} Subnet Mask: ${subnetMask ?? 'N/A'} '''; } } 

// File: \lib\screens\dialogs\paste_special_dialog.dart


// File: \lib\screens\dialogs\router_selection.dart
import 'package:flutter/material.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; import '../../models/helvar_models/helvar_router.dart'; Widget buildRouterSelectionDialog( List<Map<String, dynamic>> routersInfo, Set<int> selectedIndices, ) { return StatefulBuilder( builder: (context, setState) { return AlertDialog( title: const Text('Connect to Routers'), content: SizedBox( width: 400, height: 300, child: Column( children: [ Expanded( child: ListView.builder( itemCount: routersInfo.length, itemBuilder: (context, index) { final routerInfo = routersInfo[index]; final router = routerInfo['router'] as HelvarRouter; return CheckboxListTile( title: Text(router.description), subtitle: Text( '${routerInfo['workgroup']} - ${router.ipAddress}', ), value: selectedIndices.contains(index), onChanged: (selected) { setState(() { if (selected == true) { selectedIndices.add(index); } else { selectedIndices.remove(index); } }); }, ); }, ), ), Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ TextButton( onPressed: () { setState(() { if (selectedIndices.length == routersInfo.length) { selectedIndices.clear(); } else { selectedIndices.clear(); selectedIndices.addAll( List.generate(routersInfo.length, (i) => i), ); } }); }, child: Text( selectedIndices.length == routersInfo.length ? 'Deselect All' : 'Select All', ), ), ], ), ], ), ), actions: [ cancelAction(context), TextButton( onPressed: () => Navigator.of(context).pop(selectedIndices.toList()), child: const Text('Connect'), ), ], ); }, ); } 

// File: \lib\screens\dialogs\workgroup_selection_dialog.dart
import 'package:flutter/material.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; class WorkgroupSelectionDialog extends StatefulWidget { const WorkgroupSelectionDialog({super.key, required this.workgroups}); final List<String> workgroups; @override WorkgroupSelectionDialogState createState() => WorkgroupSelectionDialogState(); } class WorkgroupSelectionDialogState extends State<WorkgroupSelectionDialog> { String? selectedWorkgroup; final String addAllOption = '__ADD_ALL__'; @override void initState() { super.initState(); if (widget.workgroups.isNotEmpty) { selectedWorkgroup = widget.workgroups.first; } } @override Widget build(BuildContext context) { final List<String> allOptions = [...widget.workgroups, addAllOption]; return AlertDialog( title: const Text('Select Workgroup'), content: DropdownButton<String>( isExpanded: true, value: selectedWorkgroup ?? addAllOption, onChanged: (String? newValue) { if (newValue != null) { setState(() { selectedWorkgroup = newValue; }); } }, items: allOptions.map<DropdownMenuItem<String>>((String option) { return DropdownMenuItem<String>( value: option, child: Text( option == addAllOption ? 'Add All' : option, style: option == addAllOption ? const TextStyle( fontWeight: FontWeight.bold, color: Colors.blue, ) : null, ), ); }).toList(), ), actions: <Widget>[ cancelAction(context), TextButton( child: const Text('OK'), onPressed: () { Navigator.of(context).pop(selectedWorkgroup); }, ), ], ); } } 

// File: \lib\screens\home_screen.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/models/helvar_models/helvar_device.dart'; import 'package:grms_designer/models/helvar_models/input_device.dart'; import 'package:grms_designer/models/helvar_models/output_point.dart'; import 'package:grms_designer/providers/flowsheet_provider.dart'; import 'package:grms_designer/screens/details/device_detail_screen.dart'; import 'package:grms_designer/screens/details/output_point_detail_screen.dart'; import 'package:grms_designer/utils/date_utils.dart'; import '../comm/models/command_models.dart'; import '../comm/router_command_service.dart'; import 'project_screens/flow_screen.dart'; import '../models/helvar_models/helvar_group.dart'; import '../comm/models/router_connection_status.dart'; import '../models/helvar_models/helvar_router.dart'; import '../models/helvar_models/workgroup.dart'; import '../providers/project_settings_provider.dart'; import '../providers/router_connection_provider.dart'; import '../services/app_directory_service.dart'; import '../utils/general_ui.dart'; import '../widgets/app_tree_view.dart'; import 'details/group_detail_screen.dart'; import 'details/router_detail_screen.dart'; import 'dialogs/router_selection.dart'; import 'lists/groups_list_screen.dart'; import 'lists/flowsheet_list_screen.dart'; import 'log_panel_screen.dart'; import 'project_screens/settings_screen.dart'; import 'details/workgroup_detail_screen.dart'; import 'lists/workgroup_list_screen.dart'; import '../providers/workgroups_provider.dart'; import 'project_screens/project_settings_screen.dart'; import 'project_screens/project_files_screen.dart'; import '../screens/details/subnet_detail_screen.dart'; import '../screens/details/points_detail_screen.dart'; import 'details/input_point_detail_screen.dart'; import '../screens/details/output_points_detail_screen.dart'; import '../models/helvar_models/output_device.dart'; class HomeScreen extends ConsumerStatefulWidget { const HomeScreen({super.key}); @override HomeScreenState createState() => HomeScreenState(); } class HomeScreenState extends ConsumerState<HomeScreen> { bool openWorkGroups = false; bool openWiresheet = false; bool openSettings = false; bool showingImages = false; String? currentFileDirectory; String? selectedWiresheetId; Workgroup? selectedWorkgroup; HelvarGroup? selectedGroup; HelvarRouter? selectedRouter; bool showingProject = true; bool showingWorkgroup = false; bool showingGroups = false; bool showingProjectSettings = false; bool showingSubnetDetail = false; int? selectedSubnetNumber; bool showingDeviceDetail = false; HelvarDevice? selectedDevice; bool showingOutputPointsDetail = false; OutputPoint? selectedOutputPoint; List<HelvarDevice>? selectedSubnetDevices; bool showingPointsDetail = false; bool showingPointDetail = false; bool showingOutputPointDetail = false; ButtonPoint? selectedPoint; double _leftPanelWidth = 500; bool _isDragging = false; AsyncValue<RouterConnectionStatus>? connectionStream; Set<int> selectedIndices = <int>{}; final Map<String, List<QueuedCommand>> _liveQueues = {}; @override Widget build(BuildContext context) { final workgroups = ref.watch(workgroupsProvider); final wiresheets = ref.watch(flowsheetsProvider); final projectName = ref.watch(projectNameProvider); connectionStream = ref.watch(routerConnectionStatusStreamProvider); ref.listen<AsyncValue<QueuedCommand>>(commandStatusStreamProvider, ( previous, next, ) { next.whenData((command) { final list = _liveQueues.putIfAbsent(command.routerIp, () => []); final index = list.indexWhere((c) => c.id == command.id); if (index != -1) { list[index] = command; } else { list.add(command); } }); }); return Scaffold( appBar: AppBar( leadingWidth: 300, toolbarHeight: 100, leading: Image.asset("assets/logo.jpg"), title: Text('HelvarNet Manager - $projectName'), centerTitle: true, actions: [ IconButton( icon: const Icon(Icons.search), tooltip: 'Search', onPressed: () {}, ), IconButton( icon: const Icon(Icons.note), tooltip: 'Application Director', onPressed: () { Navigator.push( context, MaterialPageRoute(builder: (context) => const LogPanelScreen()), ); }, ), IconButton( icon: const Icon(Icons.settings), tooltip: 'Settings', onPressed: () { Navigator.of(context).push( MaterialPageRoute(builder: (context) => const SettingsScreen()), ); }, ), ], ), body: Row( children: [ SizedBox( width: _leftPanelWidth, height: MediaQuery.of(context).size.height - 56, child: Container( color: Colors.grey[400], child: AppTreeView( selectedSubnetNumber: selectedSubnetNumber, showingSubnetDetail: showingSubnetDetail, showingOutputPointsDetail: showingOutputPointsDetail, showingDeviceDetail: showingDeviceDetail, showingPointsDetail: showingPointsDetail, selectedOutputPoint: selectedOutputPoint, showingOutputPointDetail: showingOutputPointDetail, selectedDevice: selectedDevice, wiresheets: wiresheets, workgroups: workgroups, showingProject: showingProject, openSettings: openSettings, selectedPoint: selectedPoint, openWorkGroups: openWorkGroups, showingPointDetail: showingPointDetail, showingWorkgroup: showingWorkgroup, openWiresheet: openWiresheet, showingImages: showingImages, showingGroups: showingGroups, currentFileDirectory: currentFileDirectory, selectedWiresheetId: selectedWiresheetId, selectedWorkgroup: selectedWorkgroup, selectedGroup: selectedGroup, selectedRouter: selectedRouter, setActiveNode: _setActiveNode, ), ), ), MouseRegion( cursor: SystemMouseCursors.resizeLeftRight, child: GestureDetector( behavior: HitTestBehavior.opaque, onPanStart: (details) { setState(() => _isDragging = true); }, onPanUpdate: (details) { setState(() { _leftPanelWidth += details.delta.dx; _leftPanelWidth = _leftPanelWidth.clamp( 200, MediaQuery.of(context).size.width * 0.7, ); }); }, onPanEnd: (details) { setState(() => _isDragging = false); }, child: Container( width: 8, color: _isDragging ? Colors.blue : Colors.grey, ), ), ), Expanded(child: _buildMainContent()), ], ), ); } Widget _buildMainContent() { if (showingProject) { return _buildConnectionMonitor(); } if (openSettings) { return const ProjectSettingsScreen(); } if (openWorkGroups) { return const WorkgroupListScreen(); } if (showingGroups) { return GroupsListScreen(workgroup: selectedWorkgroup!); } if (showingImages) { return const ProjectFilesScreen( directoryName: AppDirectoryService.imagesDir, ); } if (openWiresheet) { return const FlowsheetListScreen(); } if (selectedWiresheetId != null) { return FlowScreen(flowsheetId: selectedWiresheetId!); } if (selectedWorkgroup != null) { if (showingDeviceDetail && selectedRouter != null && selectedDevice != null) { return DeviceDetailScreen( workgroup: selectedWorkgroup!, router: selectedRouter!, device: selectedDevice!, ); } if (showingPointDetail && selectedRouter != null && selectedDevice != null && selectedPoint != null) { return InputPointDetailScreen( workgroup: selectedWorkgroup!, router: selectedRouter!, device: selectedDevice!, point: selectedPoint!, ); } if (showingOutputPointDetail && selectedRouter != null && selectedDevice != null && selectedOutputPoint != null) { return OutputPointDetailScreen( workgroup: selectedWorkgroup!, router: selectedRouter!, device: selectedDevice!, point: selectedOutputPoint!, ); } if (showingPointsDetail && selectedRouter != null && selectedDevice != null) { return PointsDetailScreen( workgroup: selectedWorkgroup!, router: selectedRouter!, device: selectedDevice!, onNavigate: _setActiveNode, ); } if (showingOutputPointsDetail && selectedRouter != null && selectedDevice != null && selectedDevice is HelvarDriverOutputDevice) { return OutputPointsDetailScreen( workgroup: selectedWorkgroup!, router: selectedRouter!, device: selectedDevice!, onNavigate: _setActiveNode, ); } if (showingSubnetDetail && selectedRouter != null && selectedSubnetNumber != null && selectedSubnetDevices != null) { return SubnetDetailScreen( workgroup: selectedWorkgroup!, router: selectedRouter!, subnetNumber: selectedSubnetNumber!, devices: selectedSubnetDevices!, onNavigate: _setActiveNode, ); } if (selectedGroup != null) { return GroupDetailScreen( group: selectedGroup!, workgroup: selectedWorkgroup!, ); } if (selectedRouter != null) { return RouterDetailScreen( workgroup: selectedWorkgroup!, router: selectedRouter!, ); } return WorkgroupDetailScreen(workgroup: selectedWorkgroup!); } return const FlowsheetListScreen(); } Widget _buildConnectionMonitor() { final connectionManager = ref.watch(routerConnectionManagerProvider); final stats = connectionManager.getConnectionStats(); final connections = connectionManager.connections; final statuses = connections.values.map((c) => c.status).toList(); return Card( child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text( 'Router Connections', style: Theme.of(context).textTheme.titleLarge, ), const SizedBox(height: 8), Row( mainAxisAlignment: MainAxisAlignment.spaceAround, children: [ _buildStatCard(context, 'Total', stats['total']), _buildStatCard( context, 'Connected', stats['connected'], Colors.green, ), _buildStatCard( context, 'Connecting', stats['connecting'], Colors.blue, ), _buildStatCard( context, 'Reconnecting', stats['reconnecting'], Colors.orange, ), _buildStatCard(context, 'Failed', stats['failed'], Colors.red), _buildStatCard( context, 'Disconnected', stats['disconnected'], Colors.grey, ), ], ), const SizedBox(height: 16), ElevatedButton( onPressed: () => _connectToExistingRouters(context), child: const Text('Connect to Routers'), ), statuses.isEmpty ? const Center(child: Text('No active router connections')) : Expanded( child: ListView.builder( itemCount: statuses.length, itemBuilder: (context, index) { return _buildConnectionStatusItem( context, statuses[index], ); }, ), ), ], ), ), ); } Future<void> _connectToExistingRouters(BuildContext context) async { final workgroups = ref.read(workgroupsProvider); final List<Map<String, dynamic>> routersInfo = []; for (final workgroup in workgroups) { for (final router in workgroup.routers) { routersInfo.add({ 'workgroup': workgroup.description, 'router': router, 'workgroupId': workgroup.id, }); } } if (routersInfo.isEmpty) { if (mounted) { showSnackBarMsg(context, 'No routers found in workgroups'); } return; } if (mounted) { final selectedRouters = await showDialog<List<int>>( context: context, builder: (context) => buildRouterSelectionDialog(routersInfo, selectedIndices), ); if (selectedRouters == null || selectedRouters.isEmpty) { return; } final connectionService = ref.read(connectionServiceProvider); showDialog( context: context, barrierDismissible: false, builder: (context) => const AlertDialog( content: Column( mainAxisSize: MainAxisSize.min, children: [ CircularProgressIndicator(), SizedBox(height: 16), Text('Connecting to routers...'), ], ), ), ); final routersToConnect = selectedRouters .map((i) => routersInfo[i]['router'] as HelvarRouter) .toList(); final result = await connectionService.connectToRouters(routersToConnect); if (mounted) { Navigator.of(context).pop(); showSnackBarMsg( context, 'Connected to ${result.successCount} routers (${result.failureCount} failed)', ); } } } Widget _buildStatCard( BuildContext context, String label, int value, [ Color? color, ]) { return Card( color: color?.withValues(alpha: 0.1 * 255), child: Padding( padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0), child: Column( children: [ Text( value.toString(), style: Theme.of(context).textTheme.headlineMedium?.copyWith( color: color, fontWeight: FontWeight.bold, ), ), Text(label), ], ), ), ); } Widget _buildConnectionStatusItem( BuildContext context, RouterConnectionStatus status, ) { IconData icon; Color color; switch (status.state) { case RouterConnectionState.connected: icon = Icons.check_circle; color = Colors.green; break; case RouterConnectionState.connecting: icon = Icons.pending; color = Colors.blue; break; case RouterConnectionState.reconnecting: icon = Icons.sync; color = Colors.orange; break; case RouterConnectionState.failed: icon = Icons.error; color = Colors.red; break; case RouterConnectionState.disconnected: icon = Icons.cancel; color = Colors.grey; break; } final commands = _liveQueues[status.routerIp] ?? []; return Card( margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 8), child: Padding( padding: const EdgeInsets.all(8.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ ListTile( contentPadding: EdgeInsets.zero, leading: Icon(icon, color: color), title: Text(status.routerIp), subtitle: Text( status.errorMessage != null ? 'Error: ${status.errorMessage}' : 'Last change: ${formatDateTime(status.lastStateChange)}', ), trailing: status.reconnectAttempts > 0 ? Chip(label: Text('Retry: ${status.reconnectAttempts}')) : null, ), if (commands.isNotEmpty) Padding( padding: const EdgeInsets.only(left: 16.0, top: 4.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: commands .map( (cmd) => Text( '• [${cmd.status.name}] ${cmd.command}', style: TextStyle( fontSize: 12, color: getStatusColor(cmd.status), ), ), ) .toList(), ), ), ], ), ), ); } void _setActiveNode( String nodeName, { Workgroup? workgroup, HelvarGroup? group, HelvarRouter? router, String? wiresheetId, int? subnetNumber, List<HelvarDevice>? subnetDevices, HelvarDevice? device, ButtonPoint? point, OutputPoint? outputPoint, }) { setState(() { showingPointsDetail = false; showingPointDetail = false; showingOutputPointsDetail = false; showingOutputPointDetail = false; selectedPoint = null; selectedOutputPoint = null; openWorkGroups = false; openWiresheet = false; openSettings = false; showingImages = false; showingProject = false; showingGroups = false; showingProjectSettings = false; showingSubnetDetail = false; showingDeviceDetail = false; selectedRouter = null; selectedGroup = null; selectedWiresheetId = null; selectedWorkgroup = null; selectedSubnetNumber = null; selectedSubnetDevices = null; selectedDevice = null; currentFileDirectory = null; showingWorkgroup = false; switch (nodeName) { case 'project': showingProject = true; break; case 'settings': openSettings = true; break; case 'workgroups': openWorkGroups = true; break; case 'workgroupDetail': showingWorkgroup = true; selectedWorkgroup = workgroup; break; case 'wiresheet': selectedWiresheetId = wiresheetId; break; case 'images': currentFileDirectory = AppDirectoryService.imagesDir; break; case 'files': currentFileDirectory = null; break; case 'wiresheets': openWiresheet = true; break; case 'groups': showingGroups = true; selectedWorkgroup = workgroup; break; case 'groupDetail': selectedWorkgroup = workgroup; selectedGroup = group; break; case 'projectSettings': showingProjectSettings = true; break; case 'router': selectedWorkgroup = workgroup; selectedRouter = router; break; case 'subnetDetail': showingSubnetDetail = true; selectedWorkgroup = workgroup; selectedRouter = router; selectedSubnetNumber = subnetNumber; selectedSubnetDevices = subnetDevices; break; case 'deviceDetail': showingDeviceDetail = true; selectedWorkgroup = workgroup; selectedRouter = router; selectedDevice = device; break; case 'pointsDetail': showingPointsDetail = true; selectedWorkgroup = workgroup; selectedRouter = router; selectedDevice = device; break; case 'pointDetail': showingPointDetail = true; selectedWorkgroup = workgroup; selectedRouter = router; selectedDevice = device; selectedPoint = point; break; case 'outputPointsDetail': showingOutputPointsDetail = true; selectedWorkgroup = workgroup; selectedRouter = router; selectedDevice = device; break; case 'outputPointDetail': showingOutputPointDetail = true; selectedWorkgroup = workgroup; selectedRouter = router; selectedDevice = device; selectedOutputPoint = outputPoint; break; default: showingProject = true; } }); } } 

// File: \lib\screens\lists\flowsheet_list_screen.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; import '../../models/flowsheet.dart'; import '../../providers/flowsheet_provider.dart'; import '../../utils/file_dialog_helper.dart'; import '../../utils/general_ui.dart'; import '../project_screens/flow_screen.dart'; class FlowsheetListScreen extends ConsumerStatefulWidget { const FlowsheetListScreen({super.key}); @override FlowsheetListScreenState createState() => FlowsheetListScreenState(); } class FlowsheetListScreenState extends ConsumerState<FlowsheetListScreen> { bool _isLoading = false; @override Widget build(BuildContext context) { final flowsheets = ref.watch(flowsheetsProvider); return Scaffold( appBar: AppBar( title: const Text('Flowsheets'), centerTitle: true, actions: [ IconButton( icon: const Icon(Icons.add), tooltip: 'Create New Flowsheet', onPressed: () => _createNewFlowsheet(context, ref), ), IconButton( icon: const Icon(Icons.upload_file), tooltip: 'Import Flowsheet', onPressed: () => _importFlowsheet(context), ), ], ), body: _isLoading ? const Center(child: CircularProgressIndicator()) : flowsheets.isEmpty ? _buildEmptyState() : _buildFlowsheetList(flowsheets), ); } Widget _buildEmptyState() { return Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ const Icon(Icons.description_outlined, size: 64, color: Colors.grey), const SizedBox(height: 16), const Text('No flowsheets found', style: TextStyle(fontSize: 18)), const SizedBox(height: 24), ElevatedButton.icon( icon: const Icon(Icons.add), label: const Text('Create New Flowsheet'), onPressed: () => _createNewFlowsheet(context, ref), ), ], ), ); } Widget _buildFlowsheetList(List<Flowsheet> flowsheets) { return ListView.builder( padding: const EdgeInsets.all(16.0), itemCount: flowsheets.length, itemBuilder: (context, index) { final flowsheet = flowsheets[index]; return _buildFlowsheetCard(flowsheet); }, ); } Widget _buildFlowsheetCard(Flowsheet flowsheet) { final itemCount = flowsheet.components.length; final lastModified = flowsheet.modifiedAt; final formattedDate = '${lastModified.day}/${lastModified.month}/${lastModified.year} ${lastModified.hour}:${lastModified.minute.toString().padLeft(2, '0')}'; return Card( margin: const EdgeInsets.only(bottom: 16.0), child: Column( children: [ ListTile( leading: const CircleAvatar( backgroundColor: Colors.green, child: Icon(Icons.account_tree, color: Colors.white), ), title: Text( flowsheet.name, style: const TextStyle(fontWeight: FontWeight.bold), ), subtitle: Text( 'Components: $itemCount\nLast modified: $formattedDate', ), isThreeLine: true, onTap: () => _openFlowsheet(flowsheet), ), Padding( padding: const EdgeInsets.all(8.0), child: Row( mainAxisAlignment: MainAxisAlignment.end, children: [ IconButton( icon: const Icon(Icons.edit), tooltip: 'Rename', onPressed: () => _renameFlowsheet(flowsheet), ), IconButton( icon: const Icon(Icons.content_copy), tooltip: 'Duplicate', onPressed: () => _duplicateFlowsheet(flowsheet), ), IconButton( icon: const Icon(Icons.file_download), tooltip: 'Export', onPressed: () => _exportFlowsheet(flowsheet), ), IconButton( icon: const Icon(Icons.delete), tooltip: 'Delete', color: Colors.red, onPressed: () => _confirmDeleteFlowsheet(flowsheet), ), ], ), ), ], ), ); } void _openFlowsheet(Flowsheet flowsheet) { final activeFlowsheetId = ref .read(flowsheetsProvider.notifier) .activeFlowsheetId; if (activeFlowsheetId != null && activeFlowsheetId != flowsheet.id) { ref.read(flowsheetsProvider.notifier).saveActiveFlowsheet(); } ref.read(flowsheetsProvider.notifier).setActiveFlowsheet(flowsheet.id); Navigator.pushReplacement( context, MaterialPageRoute( builder: (context) => FlowScreen(key: ValueKey(flowsheet.id), flowsheetId: flowsheet.id), ), ); } void _createNewFlowsheet(BuildContext context, WidgetRef ref) { final nameController = TextEditingController(text: 'New Flowsheet'); showDialog( context: context, builder: (context) => AlertDialog( title: const Text('Create New Flowsheet'), content: TextField( controller: nameController, decoration: const InputDecoration( labelText: 'Flowsheet Name', border: OutlineInputBorder(), ), autofocus: true, ), actions: [ cancelAction(context), TextButton( onPressed: () async { final name = nameController.text.trim(); if (name.isNotEmpty) { setState(() { _isLoading = true; }); final flowsheet = await ref .read(flowsheetsProvider.notifier) .createFlowsheet(name); if (mounted) { setState(() { _isLoading = false; }); Navigator.of(context).pop(); _openFlowsheet(flowsheet); } } }, child: const Text('Create'), ), ], ), ); } void _renameFlowsheet(Flowsheet flowsheet) { final nameController = TextEditingController(text: flowsheet.name); showDialog( context: context, builder: (context) => AlertDialog( title: const Text('Rename Flowsheet'), content: TextField( controller: nameController, decoration: const InputDecoration( labelText: 'Flowsheet Name', border: OutlineInputBorder(), ), autofocus: true, ), actions: [ cancelAction(context), TextButton( onPressed: () { final newName = nameController.text.trim(); if (newName.isNotEmpty) { ref .read(flowsheetsProvider.notifier) .renameFlowsheet(flowsheet.id, newName); Navigator.of(context).pop(); } }, child: const Text('Rename'), ), ], ), ); } void _duplicateFlowsheet(Flowsheet flowsheet) { final nameController = TextEditingController( text: '${flowsheet.name} (Copy)', ); showDialog( context: context, builder: (context) => AlertDialog( title: const Text('Duplicate Flowsheet'), content: TextField( controller: nameController, decoration: const InputDecoration( labelText: 'New Flowsheet Name', border: OutlineInputBorder(), ), autofocus: true, ), actions: [ cancelAction(context), TextButton( onPressed: () async { final newName = nameController.text.trim(); if (newName.isNotEmpty) { final duplicate = await ref .read(flowsheetsProvider.notifier) .duplicateFlowsheet(flowsheet.id, newName); if (duplicate != null && context.mounted) { Navigator.of(context).pop(); showSnackBarMsg(context, 'Flowsheet "$newName" created'); } } }, child: const Text('Duplicate'), ), ], ), ); } Future<void> _exportFlowsheet(Flowsheet flowsheet) async { try { setState(() { _isLoading = true; }); final filePath = await FileDialogHelper.pickJsonFileToSave( 'helvarnet_flowsheet.json', ); if (filePath == null) { setState(() { _isLoading = false; }); return; } final storageService = ref.read(flowsheetStorageServiceProvider); final success = await storageService.exportFlowsheet( flowsheet.id, filePath, ); if (mounted) { setState(() { _isLoading = false; }); showSnackBarMsg( context, success ? 'Flowsheet "${flowsheet.name}" exported successfully' : 'Failed to export flowsheet', ); } } catch (e) { if (mounted) { setState(() { _isLoading = false; }); showSnackBarMsg(context, 'Error exporting flowsheet: $e'); } } } Future<void> _importFlowsheet(BuildContext context) async { try { setState(() { _isLoading = true; }); final filePath = await FileDialogHelper.pickFileToOpen( allowedExtensions: ['json'], dialogTitle: 'Select flowsheet file to import', ); if (filePath == null) { setState(() { _isLoading = false; }); return; } final storageService = ref.read(flowsheetStorageServiceProvider); final importedFlowsheet = await storageService.importFlowsheet(filePath); if (mounted) { setState(() { _isLoading = false; }); if (importedFlowsheet != null) { showSnackBarMsg( context, 'Flowsheet "${importedFlowsheet.name}" imported successfully', ); } else { showSnackBarMsg(context, 'Failed to import flowsheet'); } } } catch (e) { if (mounted) { setState(() { _isLoading = false; }); showSnackBarMsg(context, 'Error importing flowsheet: $e'); } } } void _confirmDeleteFlowsheet(Flowsheet flowsheet) async { final result = await showDialog<bool>( context: context, builder: (context) => AlertDialog( title: const Text('Delete Flowsheet'), content: Text('Are you sure you want to delete "${flowsheet.name}"?'), actions: [ cancelAction(context), TextButton( style: TextButton.styleFrom(foregroundColor: Colors.red), onPressed: () => Navigator.of(context).pop(true), child: const Text('Delete'), ), ], ), ); if (result == true && mounted) { final success = await ref .read(flowsheetsProvider.notifier) .deleteFlowsheet(flowsheet.id); if (mounted) { showSnackBarMsg( context, success ? 'Flowsheet deleted' : 'Failed to delete flowsheet', ); } } } } 

// File: \lib\screens\lists\groups_list_screen.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; import '../../models/helvar_models/helvar_group.dart'; import '../../models/helvar_models/workgroup.dart'; import '../../providers/router_connection_provider.dart'; import '../../providers/workgroups_provider.dart'; import '../../utils/general_ui.dart'; import '../details/group_detail_screen.dart'; class GroupsListScreen extends ConsumerStatefulWidget { final Workgroup workgroup; const GroupsListScreen({super.key, required this.workgroup}); @override GroupsListScreenState createState() => GroupsListScreenState(); } class GroupsListScreenState extends ConsumerState<GroupsListScreen> { bool _isLoading = false; Map<String, bool> expandedGroups = {}; bool _showGroups = true; @override void initState() { super.initState(); _isLoading = false; for (var group in widget.workgroup.groups) { expandedGroups[group.groupId] = false; } } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Groups - ${widget.workgroup.description}'), centerTitle: true, ), body: _isLoading ? const Center(child: CircularProgressIndicator()) : SingleChildScrollView( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [_buildGroupsSection(context)], ), ), ); } Widget _buildGroupsSection(BuildContext context) { return Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ const Text( 'Groups', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold), ), Row( children: [ IconButton( icon: Icon( _showGroups ? Icons.visibility : Icons.visibility_off, ), tooltip: _showGroups ? 'Hide Groups' : 'Show Groups', onPressed: () { setState(() { _showGroups = !_showGroups; }); }, ), if (_showGroups) ...[ IconButton( icon: const Icon(Icons.unfold_less), tooltip: 'Collapse All', onPressed: () { setState(() { for (var group in widget.workgroup.groups) { expandedGroups[group.groupId] = false; } }); }, ), IconButton( icon: const Icon(Icons.unfold_more), tooltip: 'Expand All', onPressed: () { setState(() { for (var group in widget.workgroup.groups) { expandedGroups[group.groupId] = true; } }); }, ), IconButton( icon: const Icon(Icons.search), tooltip: 'Discover Groups', onPressed: () => _discoverGroups(context), ), ], ], ), ], ), const SizedBox(height: 8), if (_showGroups) _buildCollapsibleGroupsList(context), ], ); } Widget _buildCollapsibleGroupsList(BuildContext context) { return widget.workgroup.groups.isEmpty ? Card( margin: const EdgeInsets.symmetric(vertical: 16, horizontal: 8), child: Padding( padding: const EdgeInsets.all(16.0), child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ const Icon(Icons.group_work, size: 48, color: Colors.grey), const SizedBox(height: 16), const Text( 'No groups found for this workgroup', style: TextStyle(fontSize: 16), ), const SizedBox(height: 24), ElevatedButton.icon( icon: const Icon(Icons.search), label: const Text('Discover Groups'), onPressed: () => _discoverGroups(context), ), ], ), ), ) : ListView.builder( shrinkWrap: true, physics: const NeverScrollableScrollPhysics(), itemCount: widget.workgroup.groups.length, itemBuilder: (context, index) { final group = widget.workgroup.groups[index]; return _buildCollapsibleGroupItem(context, group); }, ); } Widget _buildCollapsibleGroupItem(BuildContext context, HelvarGroup group) { final isExpanded = expandedGroups[group.groupId] ?? false; return Card( margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 8), child: Column( children: [ ListTile( title: Text( group.description.isEmpty ? "Group ${group.groupId}" : group.description, style: const TextStyle(fontWeight: FontWeight.bold), ), subtitle: Text('Group ID: ${group.groupId}'), leading: const CircleAvatar( backgroundColor: Colors.green, child: Icon(Icons.layers, color: Colors.white), ), trailing: Row( mainAxisSize: MainAxisSize.min, children: [ IconButton( icon: Icon( isExpanded ? Icons.keyboard_arrow_up : Icons.keyboard_arrow_down, ), onPressed: () { setState(() { expandedGroups[group.groupId] = !isExpanded; }); }, ), IconButton( icon: const Icon(Icons.edit), onPressed: () => _editGroup(context, group), ), IconButton( icon: const Icon(Icons.delete), onPressed: () => _confirmDeleteGroup(context, group), ), ], ), onTap: () { setState(() { expandedGroups[group.groupId] = !isExpanded; }); }, ), if (isExpanded) Padding( padding: const EdgeInsets.symmetric( horizontal: 16.0, vertical: 8.0, ), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ _buildDetailRow('Type', group.type), if (group.lsig != null) _buildDetailRow('LSIG', group.lsig.toString()), _buildDetailRow( 'Power Polling', '${group.powerPollingMinutes} minutes', ), if (group.gatewayRouterIpAddress.isNotEmpty) _buildDetailRow( 'Gateway Router', group.gatewayRouterIpAddress, ), _buildDetailRow( 'Refresh Props After Action', group.refreshPropsAfterAction.toString(), ), OverflowBar( alignment: MainAxisAlignment.end, children: [ TextButton( onPressed: () => _showGroupDetails(context, group), child: const Text('View Details'), ), ], ), ], ), ), ], ), ); } Widget _buildDetailRow(String label, String value) { return Padding( padding: const EdgeInsets.symmetric(vertical: 4.0), child: Row( crossAxisAlignment: CrossAxisAlignment.start, children: [ SizedBox( width: 140, child: Text( '$label:', style: const TextStyle(fontWeight: FontWeight.bold), ), ), Expanded(child: Text(value)), ], ), ); } void _editGroup(BuildContext context, HelvarGroup group) { showSnackBarMsg(context, 'Edit Group feature coming soon'); } void _showGroupDetails(BuildContext context, HelvarGroup group) { Navigator.push( context, MaterialPageRoute( builder: (context) => GroupDetailScreen(group: group, workgroup: widget.workgroup), ), ); } Future<void> _confirmDeleteGroup( BuildContext context, HelvarGroup group, ) async { final result = await showDialog<bool>( context: context, builder: (context) => AlertDialog( title: const Text('Delete Group'), content: Text( 'Are you sure you want to delete the group "${group.description.isEmpty ? 'Group ${group.groupId}' : group.description}"?', ), actions: [ cancelAction(context), TextButton( onPressed: () => Navigator.of(context).pop(true), child: const Text('Delete', style: TextStyle(color: Colors.red)), ), ], ), ); if (result == true) { await ref .read(workgroupsProvider.notifier) .removeGroupFromWorkgroup(widget.workgroup.id, group); if (!mounted) return; showSnackBarMsg(context, 'Group deleted'); } } Future<void> _discoverGroups(BuildContext context) async { if (widget.workgroup.routers.isEmpty) { showSnackBarMsg(context, 'No routers available to discover groups'); return; } setState(() { _isLoading = true; }); try { final router = widget.workgroup.routers.first; final discoveryService = ref.watch(discoveryServiceProvider); final discoveredGroups = await discoveryService.discoverGroups( router.ipAddress, ); if (discoveredGroups.isEmpty) { if (!mounted) return; showSnackBarMsg(context, 'No groups discovered'); setState(() { _isLoading = false; }); return; } if (!mounted) return; final shouldAdd = await showDialog<bool>( context: context, builder: (context) => AlertDialog( title: const Text('Groups Discovered'), content: Text( 'Found ${discoveredGroups.length} groups. Do you want to add them?', ), actions: [ cancelAction(context), TextButton( onPressed: () => Navigator.of(context).pop(true), child: const Text('Add Groups'), ), ], ), ) ?? false; if (!shouldAdd || !mounted) { setState(() { _isLoading = false; }); return; } final existingGroupIds = widget.workgroup.groups .map((g) => g.groupId) .toSet(); final newGroups = discoveredGroups .where((g) => !existingGroupIds.contains(g.groupId)) .toList(); for (final group in newGroups) { await ref .read(workgroupsProvider.notifier) .addGroupToWorkgroup(widget.workgroup.id, group); } if (!mounted) return; showSnackBarMsg(context, 'Added ${newGroups.length} groups'); setState(() { _isLoading = false; }); } catch (e) { if (!mounted) return; showSnackBarMsg(context, 'Error discovering groups: $e'); setState(() { _isLoading = false; }); } } } 

// File: \lib\screens\lists\workgroup_list_screen.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/screens/details/workgroup_detail_screen.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; import 'package:grms_designer/utils/logger.dart'; import 'package:collection/collection.dart'; import 'package:grms_designer/utils/network_utils.dart'; import '../../models/helvar_models/workgroup.dart'; import '../../models/helvar_models/helvar_router.dart'; import '../../comm/discovery_manager.dart'; import '../../utils/file_dialog_helper.dart'; import '../../utils/general_ui.dart'; import '../dialogs/network_interface_dialog.dart'; import '../dialogs/workgroup_selection_dialog.dart'; import '../../providers/settings_provider.dart'; import '../../providers/workgroups_provider.dart'; class WorkgroupListScreen extends ConsumerStatefulWidget { const WorkgroupListScreen({super.key}); @override WorkgroupListScreenState createState() => WorkgroupListScreenState(); } class WorkgroupListScreenState extends ConsumerState<WorkgroupListScreen> { bool isDiscovering = false; DiscoveryManager? discoveryManager; void _navigateToWorkgroupDetail(Workgroup workgroup) { Navigator.of(context).push( MaterialPageRoute( builder: (context) => WorkgroupDetailScreen(workgroup: workgroup), ), ); } Future<List<Map<String, String>>> _performRouterDiscovery( NetworkInterfaceDetails interfaceResult, ) async { setState(() { isDiscovering = true; }); try { await discoveryManager!.start(interfaceResult.ipv4!); final discoveryTimeout = ref.read(discoveryTimeoutProvider); final broadcastAddress = calculateBroadcastAddress( interfaceResult.ipv4!, interfaceResult.subnetMask!, ); await discoveryManager!.sendDiscoveryRequest( discoveryTimeout, broadcastAddress, ); return discoveryManager!.getDiscoveredRouters(); } catch (e) { _showErrorMessage('Discovery error: ${e.toString()}'); return []; } finally { if (discoveryManager != null) { discoveryManager!.stop(); discoveryManager = null; } setState(() { isDiscovering = false; }); } } Future<dynamic> _selectWorkgroup(List<String> workgroupNames) async { if (workgroupNames.isEmpty) { if (!mounted) return null; await showDialog( context: context, builder: (BuildContext context) { return AlertDialog( title: const Text('Discovery Result'), content: const Text( 'No Helvar routers were discovered on the network.', ), actions: [confirmAction(context)], ); }, ); return null; } if (!mounted) return null; return showDialog<dynamic>( context: context, builder: (BuildContext context) { return WorkgroupSelectionDialog(workgroups: workgroupNames); }, ); } String _generateUniqueWorkgroupId(List<Workgroup> workgroups) { final existingIds = workgroups.map((w) => w.id).toSet(); int counter = 1; while (existingIds.contains(counter.toString())) { counter++; } return counter.toString(); } List<HelvarRouter> _buildNewRoutersForExistingWorkgroup( Workgroup workgroup, List<Map<String, String>> discoveredRouters, ) { final existingRouterIps = workgroup.routers.map((r) => r.ipAddress).toSet(); return discoveredRouters .where( (router) => router['workgroup'] == workgroup.description && !existingRouterIps.contains(router['ip']), ) .map( (router) => HelvarRouter( ipAddress: router['ip'] ?? '', description: '${router['workgroup']} Router', ), ) .toList(); } List<HelvarRouter> _buildRoutersForNewWorkgroup( List<Map<String, String>> discoveredRouters, String workgroupName, ) { return discoveredRouters .where((router) => router['workgroup'] == workgroupName) .map((router) { final ipParts = router['ip']!.split('.'); return HelvarRouter( address: '@${ipParts[2]}.${ipParts[3]}', ipAddress: router['ip'] ?? '', description: '${router['workgroup']} Router', ); }) .toList(); } void _updateExistingWorkgroup( Workgroup existing, List<HelvarRouter> newRouters, ) { final updated = Workgroup( id: _generateUniqueWorkgroupId(ref.read(workgroupsProvider)), description: existing.description, networkInterface: existing.networkInterface, routers: [...existing.routers, ...newRouters], ); ref.read(workgroupsProvider.notifier).updateWorkgroup(updated); if (mounted) { showSnackBarMsg( context, 'Updated workgroup: ${existing.description} with ${newRouters.length} new routers', ); } } void _createNewWorkgroup( String workgroupName, String networkInterfaceName, List<HelvarRouter> routers, ) { final workgroup = Workgroup( id: _generateUniqueWorkgroupId(ref.read(workgroupsProvider)), description: workgroupName, networkInterface: networkInterfaceName, routers: routers, ); ref.read(workgroupsProvider.notifier).addWorkgroup(workgroup); if (mounted) { logInfo('Added workgroup: $workgroupName with ${routers.length} routers'); } } void _createWorkgroup( String workgroupName, String networkInterfaceName, List<Map<String, String>> discoveredRouters, ) { final existingWorkgroups = ref.read(workgroupsProvider); final existingWorkgroup = existingWorkgroups.firstWhereOrNull( (wg) => wg.description == workgroupName, ); if (existingWorkgroup != null) { final newRouters = _buildNewRoutersForExistingWorkgroup( existingWorkgroup, discoveredRouters, ); if (newRouters.isNotEmpty) { _updateExistingWorkgroup(existingWorkgroup, newRouters); } else if (mounted) { showSnackBarMsg( context, 'No new routers found for existing workgroup: $workgroupName', ); } return; } final newRouters = _buildRoutersForNewWorkgroup( discoveredRouters, workgroupName, ); if (newRouters.isNotEmpty) { _createNewWorkgroup(workgroupName, networkInterfaceName, newRouters); } } void _showErrorMessage(String message) { logError('Error: $message'); if (mounted) { showSnackBarMsg(context, message); } } Future<void> _discoverWorkgroups() async { discoveryManager = DiscoveryManager(); final interfaceResult = await selectNetworkInterface(context); if (interfaceResult == null) return; List<Map<String, String>> discoveredRouters = await _performRouterDiscovery( interfaceResult, ); List<String> workgroupNames = discoveredRouters .map((router) => router['workgroup'] ?? 'Unknown') .toSet() .toList(); final selectedResult = await _selectWorkgroup(workgroupNames); if (selectedResult == null) return; if (selectedResult == '__ADD_ALL__') { for (String workgroupName in workgroupNames) { _createWorkgroup( workgroupName, interfaceResult.name, discoveredRouters, ); } if (mounted) { logInfo('Added all ${workgroupNames.length} workgroups'); } } else { _createWorkgroup(selectedResult, interfaceResult.name, discoveredRouters); } } @override Widget build(BuildContext context) { final workgroups = ref.watch(workgroupsProvider); return isDiscovering ? const Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ CircularProgressIndicator(), SizedBox(height: 16), Text('Discovering Helvar routers...'), ], ), ) : Column( children: [ Row( mainAxisAlignment: MainAxisAlignment.center, children: [ ConstrainedBox( constraints: const BoxConstraints(maxWidth: 300), child: Padding( padding: const EdgeInsets.all(16.0), child: ElevatedButton.icon( icon: const Icon(Icons.search), label: const Text('Discover New Workgroup'), style: ElevatedButton.styleFrom( minimumSize: const Size.fromHeight(50), ), onPressed: isDiscovering ? null : _discoverWorkgroups, ), ), ), ConstrainedBox( constraints: const BoxConstraints(maxWidth: 300), child: Padding( padding: const EdgeInsets.all(16.0), child: ElevatedButton.icon( icon: const Icon(Icons.upload_file), label: const Text('Export Workgroups'), style: ElevatedButton.styleFrom( minimumSize: const Size.fromHeight(50), ), onPressed: () => _exportWorkgroups(context), ), ), ), ConstrainedBox( constraints: const BoxConstraints(maxWidth: 300), child: Padding( padding: const EdgeInsets.all(16.0), child: ElevatedButton.icon( icon: const Icon(Icons.download_rounded), label: const Text('Import Workgroups'), style: ElevatedButton.styleFrom( minimumSize: const Size.fromHeight(50), ), onPressed: () => _importWorkgroups(context), ), ), ), ], ), Expanded( child: ListView.builder( itemCount: workgroups.length, itemBuilder: (context, index) { final workgroup = workgroups[index]; return Card( margin: const EdgeInsets.symmetric( horizontal: 16, vertical: 8, ), child: Column( children: [ ListTile( title: Text( workgroup.description, style: const TextStyle( fontWeight: FontWeight.bold, ), ), subtitle: Text( 'Network: ${workgroup.networkInterface}\n' 'Routers: ${workgroup.routers.length}', ), isThreeLine: true, onTap: () => _navigateToWorkgroupDetail(workgroup), trailing: IconButton( icon: const Icon(Icons.delete), onPressed: () => _confirmDeleteWorkgroup(workgroup), tooltip: 'Remove workgroup', ), ), const Divider(), Padding( padding: const EdgeInsets.only(bottom: 8.0), child: Row( mainAxisAlignment: MainAxisAlignment.end, children: [ TextButton.icon( icon: const Icon(Icons.search), label: const Text('Discover More Routers'), onPressed: () => _discoverMoreRouters(workgroup), ), const SizedBox(width: 8), TextButton.icon( icon: const Icon(Icons.edit), label: const Text('Edit'), onPressed: () => _navigateToWorkgroupDetail(workgroup), ), ], ), ), ], ), ); }, ), ), ], ); } Future<void> _exportWorkgroups(BuildContext context) async { try { final filePath = await FileDialogHelper.pickJsonFileToSave( 'helvarnet_workgroups.json', ); if (filePath != null) { await ref.read(workgroupsProvider.notifier).exportWorkgroups(filePath); if (mounted) { showSnackBarMsg(context, 'Workgroups exported to $filePath'); } } } catch (e) { if (mounted) { showSnackBarMsg(context, 'Error exporting workgroups: $e'); } } } Future<void> _importWorkgroups(BuildContext context) async { try { final filePath = await FileDialogHelper.pickJsonFileToOpen(); if (filePath != null) { if (mounted) { final result = await showDialog<bool>( context: context, builder: (context) => AlertDialog( title: const Text('Import Workgroups'), content: const Text( 'Do you want to merge with existing workgroups or replace them?', ), actions: [ TextButton( onPressed: () => Navigator.of(context).pop(false), child: const Text('Replace'), ), TextButton( onPressed: () => Navigator.of(context).pop(true), child: const Text('Merge'), ), ], ), ); if (result != null) { await ref .read(workgroupsProvider.notifier) .importWorkgroups(filePath, merge: result); if (mounted) { showSnackBarMsg( context, 'Workgroups ${result ? 'merged' : 'imported'} from $filePath', ); } } } } } catch (e) { if (mounted) { showSnackBarMsg(context, 'Error importing workgroups: $e'); } } } Future<void> _confirmDeleteWorkgroup(Workgroup workgroup) async { final result = await showDialog<bool>( context: context, builder: (context) => AlertDialog( title: const Text('Delete Workgroup'), content: Text( 'Are you sure you want to delete the workgroup "${workgroup.description}"?' '\n\nThis will remove ${workgroup.routers.length} router(s) from the list.', ), actions: [ cancelAction(context), TextButton( onPressed: () => Navigator.of(context).pop(true), child: const Text('Delete', style: TextStyle(color: Colors.red)), ), ], ), ); if (result == true) { ref.read(workgroupsProvider.notifier).removeWorkgroup(workgroup.id); if (mounted) { showSnackBarMsg( context, 'Workgroup "${workgroup.description}" deleted', ); } } } Future<void> _discoverMoreRouters(Workgroup workgroup) async { discoveryManager = DiscoveryManager(); final interfaceResult = await selectNetworkInterface(context); if (interfaceResult == null) return; List<Map<String, String>> discoveredRouters = await _performRouterDiscovery( interfaceResult, ); final matchingRouters = discoveredRouters .where((router) => router['workgroup'] == workgroup.description) .toList(); if (matchingRouters.isEmpty) { if (mounted) { showSnackBarMsg( context, 'No matching routers found for this workgroup', ); } return; } _createWorkgroup( workgroup.description, workgroup.networkInterface, matchingRouters, ); } @override void dispose() { if (discoveryManager != null) { discoveryManager!.stop(); discoveryManager = null; } super.dispose(); } } 

// File: \lib\screens\log_panel_screen.dart
import 'dart:io'; import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; import '../services/log_service.dart'; import '../utils/file_dialog_helper.dart'; import '../utils/general_ui.dart'; import '../utils/logger.dart'; class LogPanelScreen extends ConsumerStatefulWidget { const LogPanelScreen({super.key}); @override LogPanelScreenState createState() => LogPanelScreenState(); } class LogPanelScreenState extends ConsumerState<LogPanelScreen> { LogLevel? _selectedLevel; String _searchQuery = ''; final TextEditingController _searchController = TextEditingController(); final ScrollController _scrollController = ScrollController(); bool _autoScroll = true; @override void dispose() { _searchController.dispose(); _scrollController.dispose(); super.dispose(); } @override Widget build(BuildContext context) { List<LogEntry> logs = ref.watch(logServiceProvider); if (_selectedLevel != null) { logs = logs.where((log) => log.level == _selectedLevel).toList(); } if (_searchQuery.isNotEmpty) { logs = logs .where( (log) => log.message.toLowerCase().contains( _searchQuery.toLowerCase(), ) || (log.tag?.toLowerCase().contains(_searchQuery.toLowerCase()) ?? false), ) .toList(); } return Scaffold( appBar: AppBar( title: const Text('Log Viewer'), actions: [ IconButton( icon: const Icon(Icons.clear_all), tooltip: 'Clear Logs', onPressed: () => ref.read(logServiceProvider.notifier).clear(), ), IconButton( icon: const Icon(Icons.download), tooltip: 'Export Logs', onPressed: _exportLogs, ), IconButton( icon: Icon( _autoScroll ? Icons.vertical_align_bottom : Icons.vertical_align_center, ), tooltip: _autoScroll ? 'Auto-scroll On' : 'Auto-scroll Off', onPressed: () { setState(() { _autoScroll = !_autoScroll; if (_autoScroll && logs.isNotEmpty) { _scrollToBottom(); } }); }, ), ], ), body: Column( children: [ _buildFilterBar(), Expanded( child: logs.isEmpty ? const Center(child: Text('No logs to display')) : _buildLogList(logs), ), ], ), ); } Widget _buildFilterBar() { return Padding( padding: const EdgeInsets.all(8.0), child: Row( children: [ Expanded( child: TextField( controller: _searchController, decoration: InputDecoration( hintText: 'Search logs...', prefixIcon: const Icon(Icons.search), suffixIcon: _searchQuery.isNotEmpty ? IconButton( icon: const Icon(Icons.clear), onPressed: () { setState(() { _searchController.clear(); _searchQuery = ''; }); }, ) : null, border: const OutlineInputBorder(), ), onChanged: (value) { setState(() { _searchQuery = value; }); }, ), ), const SizedBox(width: 8), PopupMenuButton<LogLevel?>( initialValue: _selectedLevel, tooltip: 'Filter by Level', icon: const Icon(Icons.filter_list), onSelected: (LogLevel? level) { setState(() { _selectedLevel = level; }); }, itemBuilder: (context) => [ const PopupMenuItem(value: null, child: Text('All Levels')), ...LogLevel.values.map( (level) => PopupMenuItem( value: level, child: Text(level.toString().split('.').last.toUpperCase()), ), ), ], ), ], ), ); } Future<void> _exportLogs() async { try { final logs = ref.read(logServiceProvider); if (logs.isEmpty) { showSnackBarMsg(context, 'No logs to export'); return; } final now = DateTime.now(); final fileName = 'helvarnet_logs_${now.year}${now.month}${now.day}_${now.hour}${now.minute}.txt'; final filePath = await FileDialogHelper.pickTextFileToSave(fileName); if (filePath == null) return; final file = File(filePath); final buffer = StringBuffer(); for (final log in logs) { buffer.writeln( '${log.formattedTime} [${log.levelName}]${log.tag != null ? ' [${log.tag}]' : ''}: ${log.message}', ); if (log.stackTrace != null) { buffer.writeln(log.stackTrace); buffer.writeln(); } } await file.writeAsString(buffer.toString()); if (mounted) { showSnackBarMsg(context, 'Logs exported to $filePath'); } } catch (e) { if (mounted) { showSnackBarMsg(context, 'Error exporting logs: $e'); } logError('Error exporting logs: $e', tag: 'LogPanel'); } } Widget _buildLogList(List<LogEntry> logs) { if (_autoScroll && logs.isNotEmpty) { WidgetsBinding.instance.addPostFrameCallback((_) { _scrollToBottom(); }); } return ListView.builder( controller: _scrollController, itemCount: logs.length, itemBuilder: (context, index) { final log = logs[index]; return Card( margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4), child: ListTile( leading: Container(width: 8, height: 24, color: log.levelColor), title: Text( log.message, style: const TextStyle(fontFamily: 'monospace'), ), subtitle: Row( children: [ Text(log.formattedTime, style: const TextStyle(fontSize: 12)), const SizedBox(width: 8), Container( padding: const EdgeInsets.symmetric( horizontal: 4, vertical: 2, ), decoration: BoxDecoration( color: log.levelColor.withValues(alpha: 0.2 * 255), borderRadius: BorderRadius.circular(4), ), child: Text( log.levelName, style: TextStyle( fontSize: 12, color: log.levelColor, fontWeight: FontWeight.bold, ), ), ), if (log.tag != null) ...[ const SizedBox(width: 8), Container( padding: const EdgeInsets.symmetric( horizontal: 4, vertical: 2, ), decoration: BoxDecoration( color: Colors.grey.withValues(alpha: 0.2 * 255), borderRadius: BorderRadius.circular(4), ), child: Text( log.tag!, style: const TextStyle( fontSize: 12, fontWeight: FontWeight.bold, ), ), ), ], ], ), onTap: log.stackTrace != null ? () => _showStackTrace(log) : null, ), ); }, ); } void _showStackTrace(LogEntry log) { showDialog( context: context, builder: (context) => AlertDialog( title: Text('${log.levelName}: ${log.message}'), content: Container( width: double.maxFinite, height: 300, padding: const EdgeInsets.all(8), decoration: BoxDecoration( color: Colors.grey[900], borderRadius: BorderRadius.circular(8), ), child: SingleChildScrollView( child: Text( log.stackTrace.toString(), style: const TextStyle( color: Colors.white, fontFamily: 'monospace', fontSize: 12, ), ), ), ), actions: [closeAction(context)], ), ); } void _scrollToBottom() { if (_scrollController.hasClients) { _scrollController.animateTo( _scrollController.position.maxScrollExtent, duration: const Duration(milliseconds: 300), curve: Curves.easeOut, ); } } } 

// File: \lib\screens\project_screens\flow_screen.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; import '../../models/flowsheet.dart'; import '../../providers/flowsheet_provider.dart'; import '../../widgets/wiresheet_flow_editor.dart'; import '../../utils/logger.dart'; class FlowScreen extends ConsumerWidget { final String flowsheetId; const FlowScreen({super.key, required this.flowsheetId}); @override Widget build(BuildContext context, WidgetRef ref) { final flowsheets = ref.watch(flowsheetsProvider); final flowsheet = flowsheets.firstWhere( (sheet) => sheet.id == flowsheetId, orElse: () => throw Exception('Flowsheet not found'), ); ref.read(flowsheetsProvider.notifier).setActiveFlowsheet(flowsheetId); return Scaffold( appBar: AppBar( title: Text(flowsheet.name), actions: [ IconButton( icon: const Icon(Icons.edit), tooltip: 'Rename Flowsheet', onPressed: () => _renameFlowsheet(context, ref, flowsheet), ), IconButton( icon: const Icon(Icons.content_copy), tooltip: 'Duplicate Flowsheet', onPressed: () => _duplicateFlowsheet(context, ref, flowsheet), ), const SizedBox(width: 8), ], ), body: WiresheetFlowEditor( key: ValueKey(flowsheet.id), flowsheet: flowsheet, ), ); } void _renameFlowsheet( BuildContext context, WidgetRef ref, Flowsheet flowsheet, ) { final nameController = TextEditingController(text: flowsheet.name); showDialog( context: context, builder: (context) => AlertDialog( title: const Text('Rename Flowsheet'), content: TextField( controller: nameController, decoration: const InputDecoration( labelText: 'Flowsheet Name', border: OutlineInputBorder(), ), autofocus: true, ), actions: [ cancelAction(context), TextButton( onPressed: () { final newName = nameController.text.trim(); if (newName.isNotEmpty) { ref .read(flowsheetsProvider.notifier) .renameFlowsheet(flowsheet.id, newName); Navigator.of(context).pop(); } }, child: const Text('Rename'), ), ], ), ); } void _duplicateFlowsheet( BuildContext context, WidgetRef ref, Flowsheet flowsheet, ) { final nameController = TextEditingController( text: '${flowsheet.name} (Copy)', ); showDialog( context: context, builder: (context) => AlertDialog( title: const Text('Duplicate Flowsheet'), content: TextField( controller: nameController, decoration: const InputDecoration( labelText: 'New Flowsheet Name', border: OutlineInputBorder(), ), autofocus: true, ), actions: [ cancelAction(context), TextButton( onPressed: () async { final newName = nameController.text.trim(); if (newName.isNotEmpty) { final duplicate = await ref .read(flowsheetsProvider.notifier) .duplicateFlowsheet(flowsheet.id, newName); if (duplicate != null && context.mounted) { Navigator.of(context).pop(); logInfo("Flowsheet created: $newName"); } } }, child: const Text('Duplicate'), ), ], ), ); } } 

// File: \lib\screens\project_screens\project_files_screen.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; import '../../services/app_directory_service.dart'; import 'dart:io'; import 'package:file_picker/file_picker.dart'; import '../../utils/file_dialog_helper.dart'; import '../../utils/general_ui.dart'; import '../../utils/logger.dart'; class ProjectFilesScreen extends ConsumerStatefulWidget { final String directoryName; const ProjectFilesScreen({super.key, required this.directoryName}); @override ProjectFilesScreenState createState() => ProjectFilesScreenState(); } class ProjectFilesScreenState extends ConsumerState<ProjectFilesScreen> { final AppDirectoryService _directoryService = AppDirectoryService(); List<FileSystemEntity> _files = []; bool _isLoading = true; @override void initState() { super.initState(); _loadFiles(); } Future<void> _loadFiles() async { setState(() { _isLoading = true; }); try { final files = await _directoryService.listFiles(widget.directoryName); setState(() { _files = files; _isLoading = false; }); } catch (e) { logError('Error loading files: $e'); setState(() { _isLoading = false; }); } } Future<void> _importFile() async { try { String? filePath; if (widget.directoryName == AppDirectoryService.imagesDir) { filePath = await FileDialogHelper.pickFileToOpen( type: FileType.image, dialogTitle: 'Select image to import', ); } else if (widget.directoryName == AppDirectoryService.workgroupsDir) { filePath = await FileDialogHelper.pickFileToOpen( allowedExtensions: ['json'], dialogTitle: 'Select workgroup file to import', ); } else if (widget.directoryName == AppDirectoryService.wiresheetsDir) { filePath = await FileDialogHelper.pickFileToOpen( allowedExtensions: ['json'], dialogTitle: 'Select wiresheet file to import', ); } else { filePath = await FileDialogHelper.pickFileToOpen( type: FileType.any, dialogTitle: 'Select file to import', ); } if (filePath != null) { setState(() { _isLoading = true; }); final fileName = filePath.split(Platform.pathSeparator).last; String targetPath; switch (widget.directoryName) { case AppDirectoryService.workgroupsDir: targetPath = await _directoryService.getWorkgroupFilePath(fileName); break; case AppDirectoryService.wiresheetsDir: targetPath = await _directoryService.getWiresheetFilePath(fileName); break; case AppDirectoryService.imagesDir: targetPath = await _directoryService.getImageFilePath(fileName); break; default: targetPath = await _directoryService.getFilePath( widget.directoryName, fileName, ); } final sourceFile = File(filePath); final targetFile = File(targetPath); if (await targetFile.exists()) { if (!mounted) return; final shouldReplace = await showDialog<bool>( context: context, builder: (context) => AlertDialog( title: const Text('File Already Exists'), content: Text( 'A file named "$fileName" already exists. Do you want to replace it?', ), actions: [ cancelAction(context), TextButton( onPressed: () => Navigator.of(context).pop(true), child: const Text('Replace'), ), ], ), ); if (shouldReplace != true) { setState(() { _isLoading = false; }); return; } } await sourceFile.copy(targetPath); await _loadFiles(); if (mounted) { showSnackBarMsg(context, 'File "$fileName" imported successfully'); } } } catch (e) { setState(() { _isLoading = false; }); if (mounted) { showSnackBarMsg(context, 'Error importing file: $e'); } logError('Error importing file: $e'); } } Future<void> _deleteFile(FileSystemEntity file) async { try { final fileName = file.path.split(Platform.pathSeparator).last; await _directoryService.deleteFile(widget.directoryName, fileName); _loadFiles(); } catch (e) { logError('Error deleting file: $e'); } } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text(widget.directoryName.toUpperCase())), body: _isLoading ? const Center(child: CircularProgressIndicator()) : _files.isEmpty ? Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ const Icon(Icons.folder_open, size: 64, color: Colors.grey), const SizedBox(height: 16), const Text( 'No files found in this directory', style: TextStyle(fontSize: 16), ), const SizedBox(height: 24), ElevatedButton.icon( icon: const Icon(Icons.add), label: const Text('Import File'), onPressed: _importFile, ), ], ), ) : ListView.builder( itemCount: _files.length, itemBuilder: (context, index) { final file = _files[index]; final fileName = file.path.split(Platform.pathSeparator).last; return ListTile( leading: Icon( file is Directory ? Icons.folder : Icons.insert_drive_file, color: file is Directory ? Colors.amber : Colors.blue, ), title: Text(fileName), subtitle: FutureBuilder<FileStat>( future: file.stat(), builder: (context, snapshot) { if (snapshot.hasData) { final stat = snapshot.data!; final modified = stat.modified .toString() .split('.') .first; final size = '${(stat.size / 1024).toStringAsFixed(2)} KB'; return Text('Modified: $modified\nSize: $size'); } return const Text('Loading file info...'); }, ), trailing: IconButton( icon: const Icon(Icons.delete), onPressed: () => _deleteFile(file), ), isThreeLine: true, ); }, ), floatingActionButton: FloatingActionButton( onPressed: _importFile, child: const Icon(Icons.add), ), ); } } 

// File: \lib\screens\project_screens\project_settings_screen.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; import '../../providers/project_settings_provider.dart'; import '../../providers/settings_provider.dart'; class ProjectSettingsScreen extends ConsumerWidget { const ProjectSettingsScreen({super.key}); @override Widget build(BuildContext context, WidgetRef ref) { final projectSettings = ref.watch(projectSettingsProvider); final discoveryTimeout = ref.watch(discoveryTimeoutProvider); return Scaffold( appBar: AppBar(title: const Text('Project Settings')), body: ListView( padding: const EdgeInsets.all(16.0), children: [ Card( margin: const EdgeInsets.only(bottom: 16.0), child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ const Text( 'Project', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold), ), const SizedBox(height: 16), ListTile( title: const Text('Project Name'), subtitle: Text(projectSettings.projectName), trailing: const Icon(Icons.edit), onTap: () => _showProjectNameDialog( context, ref, projectSettings.projectName, ), ), ], ), ), ), Card( margin: const EdgeInsets.only(bottom: 16.0), child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ const Text( 'Router Connection', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold), ), const SizedBox(height: 16), ListTile( title: const Text('Socket Timeout'), subtitle: Text( '${projectSettings.socketTimeoutMs / 1000} seconds', ), trailing: const Icon(Icons.timer), onTap: () => _showSocketTimeoutDialog( context, ref, projectSettings.socketTimeoutMs, ), ), ListTile( title: const Text('Discovery Timeout'), subtitle: Text('${discoveryTimeout / 1000} seconds'), trailing: const Icon(Icons.timer_outlined), onTap: () => _showDiscoveryTimeoutDialog( context, ref, discoveryTimeout, ), ), ], ), ), ), Card( margin: const EdgeInsets.only(bottom: 16.0), child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ const Text( 'Auto Save', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold), ), const SizedBox(height: 16), SwitchListTile( title: const Text('Auto Save Enabled'), value: projectSettings.autoSave, onChanged: (value) { ref .read(projectSettingsProvider.notifier) .setAutoSave(value); }, ), ListTile( title: const Text('Auto Save Interval'), subtitle: Text( '${projectSettings.autoSaveIntervalMinutes} minutes', ), trailing: const Icon(Icons.timelapse), enabled: projectSettings.autoSave, onTap: projectSettings.autoSave ? () => _showAutoSaveIntervalDialog( context, ref, projectSettings.autoSaveIntervalMinutes, ) : null, ), ListTile( title: const Text('Protocol Version'), subtitle: Text('${projectSettings.protocolVersion}'), trailing: const Icon(Icons.sync), onTap: () => _showProtocolVersionDialog( context, ref, projectSettings.protocolVersion, ), ), ], ), ), ), Card( margin: const EdgeInsets.only(bottom: 16.0), child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ const Text( 'Command Settings', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold), ), const SizedBox(height: 16), ListTile( title: const Text('Command Timeout'), subtitle: Text( '${projectSettings.commandTimeoutMs / 1000} seconds', ), trailing: const Icon(Icons.timer), onTap: () => _showCommandTimeoutDialog( context, ref, projectSettings.commandTimeoutMs, ), ), ListTile( title: const Text('Heartbeat Interval'), subtitle: Text( '${projectSettings.heartbeatIntervalSeconds} seconds', ), trailing: const Icon(Icons.favorite), onTap: () => _showHeartbeatIntervalDialog( context, ref, projectSettings.heartbeatIntervalSeconds, ), ), ListTile( title: const Text('Max Command Retries'), subtitle: Text('${projectSettings.maxCommandRetries}'), trailing: const Icon(Icons.replay), onTap: () => _showMaxRetriesDialog( context, ref, projectSettings.maxCommandRetries, ), ), ListTile( title: const Text('Max Concurrent Commands'), subtitle: Text( '${projectSettings.maxConcurrentCommandsPerRouter}', ), trailing: const Icon(Icons.call_split), onTap: () => _showMaxConcurrentCommandsDialog( context, ref, projectSettings.maxConcurrentCommandsPerRouter, ), ), ListTile( title: const Text('Command History Size'), subtitle: Text( '${projectSettings.commandHistorySize} entries', ), trailing: const Icon(Icons.history), onTap: () => _showCommandHistorySizeDialog( context, ref, projectSettings.commandHistorySize, ), ), ], ), ), ), ], ), ); } void _showProtocolVersionDialog( BuildContext context, WidgetRef ref, int currentVersion, ) { showDialog( context: context, builder: (context) => AlertDialog( title: const Text('Protocol Version'), content: Column( mainAxisSize: MainAxisSize.min, children: [ const Text('Select HelvarNet protocol version:'), const SizedBox(height: 16), Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: [ ElevatedButton( style: ElevatedButton.styleFrom( backgroundColor: currentVersion == 1 ? Colors.blue : null, foregroundColor: currentVersion == 1 ? Colors.white : null, ), onPressed: () { ref .read(projectSettingsProvider.notifier) .setProtocolVersion(1); Navigator.of(context).pop(); }, child: const Text('Version 1'), ), ElevatedButton( style: ElevatedButton.styleFrom( backgroundColor: currentVersion == 2 ? Colors.blue : null, foregroundColor: currentVersion == 2 ? Colors.white : null, ), onPressed: () { ref .read(projectSettingsProvider.notifier) .setProtocolVersion(2); Navigator.of(context).pop(); }, child: const Text('Version 2'), ), ], ), const SizedBox(height: 16), const Text( 'Version 2 is recommended for newer systems. Only use Version 1 for legacy compatibility.', textAlign: TextAlign.center, style: TextStyle(fontSize: 12, color: Colors.grey), ), ], ), actions: [cancelAction(context)], ), ); } void _showCommandTimeoutDialog( BuildContext context, WidgetRef ref, int currentTimeout, ) { double timeoutInSec = currentTimeout / 1000; showDialog( context: context, builder: (context) { return StatefulBuilder( builder: (context, setState) { return AlertDialog( title: const Text('Command Timeout'), content: Column( mainAxisSize: MainAxisSize.min, children: [ Text('${timeoutInSec.toStringAsFixed(1)} seconds'), Slider( min: 1.0, max: 30.0, divisions: 29, value: timeoutInSec, onChanged: (value) { setState(() { timeoutInSec = value; }); }, ), const Text( 'Longer timeouts give more time for commands to complete but may make the application less responsive if a command fails.', style: TextStyle(fontSize: 12, color: Colors.grey), ), ], ), actions: [ cancelAction(context), TextButton( onPressed: () { final timeoutMs = (timeoutInSec * 1000).round(); ref .read(projectSettingsProvider.notifier) .setCommandTimeout(timeoutMs); Navigator.of(context).pop(); }, child: const Text('Save'), ), ], ); }, ); }, ); } void _showDiscoveryTimeoutDialog( BuildContext context, WidgetRef ref, int currentTimeout, ) { double timeoutInSec = currentTimeout / 1000; showDialog( context: context, builder: (context) { return StatefulBuilder( builder: (context, setState) { return AlertDialog( title: const Text('Discovery Timeout'), content: Column( mainAxisSize: MainAxisSize.min, children: [ Text('${timeoutInSec.toStringAsFixed(1)} seconds'), Slider( min: 1.0, max: 30.0, divisions: 29, value: timeoutInSec, onChanged: (value) { setState(() { timeoutInSec = value; }); }, ), const Text( 'Longer timeouts may find more devices but will take longer to complete.', style: TextStyle(fontSize: 12, color: Colors.grey), ), ], ), actions: [ cancelAction(context), TextButton( onPressed: () { final timeoutMs = (timeoutInSec * 1000).round(); ref .read(settingsProvider.notifier) .setDiscoveryTimeout(timeoutMs); Navigator.of(context).pop(); }, child: const Text('Save'), ), ], ); }, ); }, ); } void _showProjectNameDialog( BuildContext context, WidgetRef ref, String currentName, ) { final nameController = TextEditingController(text: currentName); showDialog( context: context, builder: (context) { return AlertDialog( title: const Text('Project Name'), content: TextField( controller: nameController, decoration: const InputDecoration( labelText: 'Name', border: OutlineInputBorder(), ), autofocus: true, ), actions: [ cancelAction(context), TextButton( onPressed: () { final newName = nameController.text.trim(); if (newName.isNotEmpty) { ref .read(projectSettingsProvider.notifier) .setProjectName(newName); Navigator.of(context).pop(); } }, child: const Text('Save'), ), ], ); }, ); } void _showSocketTimeoutDialog( BuildContext context, WidgetRef ref, int currentTimeout, ) { double timeoutInSec = currentTimeout / 1000; showDialog( context: context, builder: (context) { return StatefulBuilder( builder: (context, setState) { return AlertDialog( title: const Text('Socket Timeout'), content: Column( mainAxisSize: MainAxisSize.min, children: [ Text('${timeoutInSec.toStringAsFixed(1)} seconds'), Slider( min: 1.0, max: 60.0, divisions: 59, value: timeoutInSec, onChanged: (value) { setState(() { timeoutInSec = value; }); }, ), const Text( 'Longer timeouts may be needed for slower networks.', style: TextStyle(fontSize: 12, color: Colors.grey), ), ], ), actions: [ cancelAction(context), TextButton( onPressed: () { final timeoutMs = (timeoutInSec * 1000).round(); ref .read(projectSettingsProvider.notifier) .setSocketTimeout(timeoutMs); Navigator.of(context).pop(); }, child: const Text('Save'), ), ], ); }, ); }, ); } void _showAutoSaveIntervalDialog( BuildContext context, WidgetRef ref, int currentInterval, ) { final intervalController = TextEditingController( text: currentInterval.toString(), ); showDialog( context: context, builder: (context) { return AlertDialog( title: const Text('Auto Save Interval'), content: TextField( controller: intervalController, decoration: const InputDecoration( labelText: 'Minutes', border: OutlineInputBorder(), ), keyboardType: TextInputType.number, autofocus: true, ), actions: [ cancelAction(context), TextButton( onPressed: () { final String text = intervalController.text.trim(); final int? minutes = int.tryParse(text); if (minutes != null && minutes > 0) { ref .read(projectSettingsProvider.notifier) .setAutoSaveInterval(minutes); Navigator.of(context).pop(); } }, child: const Text('Save'), ), ], ); }, ); } void _showHeartbeatIntervalDialog( BuildContext context, WidgetRef ref, int heartbeatIntervalSeconds, ) { double intervalInSec = heartbeatIntervalSeconds.toDouble(); showDialog( context: context, builder: (context) { return StatefulBuilder( builder: (context, setState) { return AlertDialog( title: const Text('Heartbeat Interval'), content: Column( mainAxisSize: MainAxisSize.min, children: [ Text('${intervalInSec.toStringAsFixed(0)} seconds'), Slider( min: 5.0, max: 300.0, divisions: 59, value: intervalInSec, onChanged: (value) { setState(() { intervalInSec = value; }); }, ), const Text( 'The heartbeat interval determines how often the application checks if router connections are still alive.', style: TextStyle(fontSize: 12, color: Colors.grey), ), ], ), actions: [ cancelAction(context), TextButton( onPressed: () { final interval = intervalInSec.round(); ref .read(projectSettingsProvider.notifier) .setHeartbeatInterval(interval); Navigator.of(context).pop(); }, child: const Text('Save'), ), ], ); }, ); }, ); } void _showMaxRetriesDialog( BuildContext context, WidgetRef ref, int maxCommandRetries, ) { final retriesController = TextEditingController( text: maxCommandRetries.toString(), ); showDialog( context: context, builder: (context) { return AlertDialog( title: const Text('Max Command Retries'), content: Column( mainAxisSize: MainAxisSize.min, children: [ TextField( controller: retriesController, decoration: const InputDecoration( labelText: 'Retries', border: OutlineInputBorder(), ), keyboardType: TextInputType.number, autofocus: true, ), const SizedBox(height: 16), const Text( 'Maximum number of times to retry a failed command before giving up.', style: TextStyle(fontSize: 12, color: Colors.grey), ), ], ), actions: [ cancelAction(context), TextButton( onPressed: () { final String text = retriesController.text.trim(); final int? retries = int.tryParse(text); if (retries != null && retries >= 0) { ref .read(projectSettingsProvider.notifier) .setMaxCommandRetries(retries); Navigator.of(context).pop(); } }, child: const Text('Save'), ), ], ); }, ); } void _showMaxConcurrentCommandsDialog( BuildContext context, WidgetRef ref, int maxConcurrentCommandsPerRouter, ) { final commandsController = TextEditingController( text: maxConcurrentCommandsPerRouter.toString(), ); showDialog( context: context, builder: (context) { return AlertDialog( title: const Text('Max Concurrent Commands'), content: Column( mainAxisSize: MainAxisSize.min, children: [ TextField( controller: commandsController, decoration: const InputDecoration( labelText: 'Commands', border: OutlineInputBorder(), ), keyboardType: TextInputType.number, autofocus: true, ), const SizedBox(height: 16), const Text( 'Maximum number of commands that can be executed simultaneously on a single router.', style: TextStyle(fontSize: 12, color: Colors.grey), ), ], ), actions: [ cancelAction(context), TextButton( onPressed: () { final String text = commandsController.text.trim(); final int? commands = int.tryParse(text); if (commands != null && commands > 0) { ref .read(projectSettingsProvider.notifier) .setMaxConcurrentCommands(commands); Navigator.of(context).pop(); } }, child: const Text('Save'), ), ], ); }, ); } void _showCommandHistorySizeDialog( BuildContext context, WidgetRef ref, int commandHistorySize, ) { final historySizeController = TextEditingController( text: commandHistorySize.toString(), ); showDialog( context: context, builder: (context) { return AlertDialog( title: const Text('Command History Size'), content: Column( mainAxisSize: MainAxisSize.min, children: [ TextField( controller: historySizeController, decoration: const InputDecoration( labelText: 'History Size', border: OutlineInputBorder(), ), keyboardType: TextInputType.number, autofocus: true, ), const SizedBox(height: 16), const Text( 'Number of commands to keep in the history. Older commands will be removed when this limit is reached.', style: TextStyle(fontSize: 12, color: Colors.grey), ), ], ), actions: [ cancelAction(context), TextButton( onPressed: () { final String text = historySizeController.text.trim(); final int? size = int.tryParse(text); if (size != null && size > 0) { ref .read(projectSettingsProvider.notifier) .setCommandHistorySize(size); Navigator.of(context).pop(); } }, child: const Text('Save'), ), ], ); }, ); } } 

// File: \lib\screens\project_screens\settings_screen.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import '../../providers/settings_provider.dart'; class SettingsScreen extends ConsumerWidget { const SettingsScreen({super.key}); @override Widget build(BuildContext context, WidgetRef ref) { final themeMode = ref.watch(themeModeProvider); return Scaffold( appBar: AppBar( title: const Text('Settings'), ), body: ListView( padding: const EdgeInsets.all(16.0), children: [ Card( margin: const EdgeInsets.only(bottom: 16.0), child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ const Text( 'Appearance', style: TextStyle( fontSize: 18, fontWeight: FontWeight.bold, ), ), const SizedBox(height: 16), ListTile( title: const Text('Theme'), subtitle: Text(_getThemeModeName(themeMode)), trailing: const Icon(Icons.brightness_4), onTap: () => _showThemeModeDialog(context, ref, themeMode), ), ], ), ), ), ], ), ); } String _getThemeModeName(ThemeMode mode) { switch (mode) { case ThemeMode.system: return 'System'; case ThemeMode.light: return 'Light'; case ThemeMode.dark: return 'Dark'; } } void _showThemeModeDialog( BuildContext context, WidgetRef ref, ThemeMode currentMode) { showDialog( context: context, builder: (context) { return AlertDialog( title: const Text('Choose Theme'), content: Column( mainAxisSize: MainAxisSize.min, children: [ _buildThemeOption(context, ref, ThemeMode.system, currentMode), _buildThemeOption(context, ref, ThemeMode.light, currentMode), _buildThemeOption(context, ref, ThemeMode.dark, currentMode), ], ), ); }, ); } Widget _buildThemeOption(BuildContext context, WidgetRef ref, ThemeMode mode, ThemeMode currentMode) { return RadioListTile<ThemeMode>( title: Text(_getThemeModeName(mode)), value: mode, groupValue: currentMode, onChanged: (ThemeMode? value) { if (value != null) { ref.read(settingsProvider.notifier).setThemeMode(value); Navigator.of(context).pop(); } }, ); } } 

// File: \lib\services\app_directory_service.dart
import 'dart:io'; import 'package:path_provider/path_provider.dart'; import 'package:path/path.dart' as path; import '../utils/logger.dart'; class AppDirectoryService { static const String _appFolderName = 'GRMS_Designer'; static const String workgroupsDir = 'workgroups'; static const String routersDir = 'routers'; static const String wiresheetsDir = 'wiresheets'; static const String flowsheetsDir = 'flowsheets'; static const String imagesDir = 'images'; static const String backupsDir = 'backups'; static const String exportsDir = 'exports'; static const String settingsDir = 'settings'; static final AppDirectoryService _instance = AppDirectoryService._internal(); factory AppDirectoryService() => _instance; AppDirectoryService._internal(); String? _baseDirectoryPath; Future<void> initialize() async { await _getBaseDirectory(); await createWorkgroupsDirectory(); await createRoutersDirectory(); await createWiresheetsDirectory(); await createImagesDirectory(); await createBackupsDirectory(); await createExportsDirectory(); await createSettingsDirectory(); } Future<String> _getBaseDirectory() async { if (_baseDirectoryPath != null) { return _baseDirectoryPath!; } final documentsDir = await getApplicationDocumentsDirectory(); final baseDir = Directory(path.join(documentsDir.path, _appFolderName)); if (!await baseDir.exists()) { await baseDir.create(recursive: true); } _baseDirectoryPath = baseDir.path; return _baseDirectoryPath!; } Future<String> _getSubdirectory(String subDirName) async { final baseDir = await _getBaseDirectory(); final subDir = Directory(path.join(baseDir, subDirName)); if (!await subDir.exists()) { await subDir.create(recursive: true); } return subDir.path; } Future<String> createWorkgroupsDirectory() async { return _getSubdirectory(workgroupsDir); } Future<String> createRoutersDirectory() async { return _getSubdirectory(routersDir); } Future<String> createWiresheetsDirectory() async { return _getSubdirectory(wiresheetsDir); } Future<String> createImagesDirectory() async { return _getSubdirectory(imagesDir); } Future<String> createBackupsDirectory() async { return _getSubdirectory(backupsDir); } Future<String> createExportsDirectory() async { return _getSubdirectory(exportsDir); } Future<String> createSettingsDirectory() async { return _getSubdirectory(settingsDir); } Future<String> getFilePath(String subDir, String fileName) async { final dirPath = await _getSubdirectory(subDir); return path.join(dirPath, fileName); } Future<String> getWorkgroupFilePath(String fileName) async { return getFilePath(workgroupsDir, fileName); } Future<String> getRouterFilePath(String fileName) async { return getFilePath(routersDir, fileName); } Future<String> getWiresheetFilePath(String fileName) async { return getFilePath(wiresheetsDir, fileName); } Future<String> getFlowsheetFilePath(String fileName) async { return getFilePath(flowsheetsDir, fileName); } Future<String> getImageFilePath(String fileName) async { return getFilePath(imagesDir, fileName); } Future<String> getBackupFilePath(String fileName) async { return getFilePath(backupsDir, fileName); } Future<String> getExportFilePath(String fileName) async { return getFilePath(exportsDir, fileName); } Future<String> getSettingsFilePath(String fileName) async { return getFilePath(settingsDir, fileName); } Future<List<FileSystemEntity>> listFiles(String subDir) async { final dirPath = await _getSubdirectory(subDir); final dir = Directory(dirPath); return dir.listSync(); } Future<bool> deleteFile(String subDir, String fileName) async { try { final filePath = await getFilePath(subDir, fileName); final file = File(filePath); if (await file.exists()) { await file.delete(); return true; } return false; } catch (e) { logError('Error deleting file: $e'); return false; } } Future<String?> createBackup(String sourceSubDir, String fileName) async { try { final sourceFilePath = await getFilePath(sourceSubDir, fileName); final sourceFile = File(sourceFilePath); if (!await sourceFile.exists()) { return null; } final timestamp = DateTime.now().millisecondsSinceEpoch; final backupFileName = '${path.basenameWithoutExtension(fileName)}_backup_$timestamp${path.extension(fileName)}'; final backupFilePath = await getBackupFilePath(backupFileName); await sourceFile.copy(backupFilePath); return backupFilePath; } catch (e) { logError('Error creating backup: $e'); return null; } } Future<String?> exportFile( String sourceSubDir, String fileName, String exportName) async { try { final sourceFilePath = await getFilePath(sourceSubDir, fileName); final sourceFile = File(sourceFilePath); if (!await sourceFile.exists()) { return null; } final exportFilePath = await getExportFilePath(exportName); await sourceFile.copy(exportFilePath); return exportFilePath; } catch (e) { logError('Error exporting file: $e'); return null; } } } 

// File: \lib\services\app_initialization.dart
import 'dart:async'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import '../utils/logger.dart'; import '../providers/group_polling_provider.dart'; import '../providers/workgroups_provider.dart'; import 'app_directory_service.dart'; class AppInitializationService { static Future<void> initialize() async { try { await _initializeDirectories(); } catch (e) { logError('Error during application initialization: $e'); rethrow; } } static Future<void> _initializeDirectories() async { final directoryService = AppDirectoryService(); await directoryService.initialize(); logInfo('Application directories initialized successfully'); } static Future<void> initializePolling(WidgetRef ref) async { try { logInfo('Initializing automatic power consumption polling...'); final workgroups = ref.read(workgroupsProvider); if (workgroups.isEmpty) { logInfo('No workgroups found, polling initialization skipped'); return; } final pollingNotifier = ref.read(pollingStateProvider.notifier); pollingNotifier.initializePolling(); final enabledWorkgroups = workgroups .where((wg) => wg.pollEnabled) .toList(); if (enabledWorkgroups.isNotEmpty) { logInfo( 'Started automatic polling for ${enabledWorkgroups.length} workgroups:', ); for (final wg in enabledWorkgroups) { logInfo('  - ${wg.description} (${wg.groups.length} groups)'); for (final group in wg.groups) { logDebug( '    * Group ${group.groupId}: ${group.powerPollingMinutes} min interval', ); } } } else { logInfo('No workgroups have polling enabled'); } } catch (e) { logError('Error initializing polling: $e'); } } static Future<void> handleInitializationFailure(dynamic error) async { logError('Application initialization failed: $error'); } } 

// File: \lib\services\command_history_service.dart
import '../comm/models/command_models.dart'; class CommandHistoryService { final int maxHistorySize; final List<QueuedCommand> _history = []; CommandHistoryService({this.maxHistorySize = 100}); void add(QueuedCommand command) { _history.insert(0, command); if (_history.length > maxHistorySize) { _history.removeLast(); } } List<QueuedCommand> get all => List.unmodifiable(_history); void clear() => _history.clear(); } 

// File: \lib\services\connection_service.dart
import '../comm/router_connection_manager.dart'; import '../models/helvar_models/helvar_router.dart'; class ConnectionBatchResult { final int successCount; final int failureCount; final List<String> errors; ConnectionBatchResult({ required this.successCount, required this.failureCount, required this.errors, }); } class ConnectionService { final RouterConnectionManager manager; ConnectionService(this.manager); Future<ConnectionBatchResult> connectToRouters( List<HelvarRouter> routers) async { int success = 0; int failure = 0; List<String> errors = []; for (final router in routers) { try { if (router.ipAddress.isNotEmpty) { await manager.getConnection(router.ipAddress); success++; } } catch (e) { failure++; errors.add('Failed to connect to ${router.ipAddress}: $e'); } } return ConnectionBatchResult( successCount: success, failureCount: failure, errors: errors, ); } } 

// File: \lib\services\device_query_service.dart
import '../comm/router_command_service.dart'; import '../models/helvar_models/output_device.dart'; import '../protocol/query_commands.dart'; import '../protocol/protocol_parser.dart'; import '../utils/logger.dart'; class DeviceQueryService { final RouterCommandService commandService; DeviceQueryService(this.commandService); Future<bool> queryOutputDevicePoints( String routerIpAddress, HelvarDriverOutputDevice device, ) async { try { logInfo('Querying output device points for: ${device.address}'); await _queryDeviceState(routerIpAddress, device); await _queryLampFailure(routerIpAddress, device); await _queryMissingStatus(routerIpAddress, device); await _queryFaultyStatus(routerIpAddress, device); await _queryOutputLevel(routerIpAddress, device); await _queryPowerConsumption(routerIpAddress, device); logInfo('Successfully updated all points for device: ${device.address}'); return true; } catch (e) { logError('Error querying output device points: $e'); return false; } } Future<void> _queryDeviceState( String routerIpAddress, HelvarDriverOutputDevice device, ) async { try { final command = HelvarNetCommands.queryDeviceState(device.address); final result = await commandService.sendCommand(routerIpAddress, command); if (result.success && result.response != null) { final stateValue = ProtocolParser.extractResponseValue( result.response!, ); if (stateValue != null) { final stateCode = int.tryParse(stateValue) ?? 0; final isNormal = stateCode == 0; await device.updatePointValue(1, isNormal); logInfo( 'Device ${device.address} state: $stateCode (Normal: $isNormal)', ); } } } catch (e) { logError('Error querying device state: $e'); } } Future<void> _queryLampFailure( String routerIpAddress, HelvarDriverOutputDevice device, ) async { try { final command = HelvarNetCommands.queryLampFailure(device.address); final result = await commandService.sendCommand(routerIpAddress, command); if (result.success && result.response != null) { final failureValue = ProtocolParser.extractResponseValue( result.response!, ); if (failureValue != null) { final hasFailure = failureValue == '1' || failureValue.toLowerCase() == 'true'; await device.updatePointValue(2, hasFailure); logInfo('Device ${device.address} lamp failure: $hasFailure'); } } } catch (e) { logError('Error querying lamp failure: $e'); } } Future<void> _queryMissingStatus( String routerIpAddress, HelvarDriverOutputDevice device, ) async { try { final command = HelvarNetCommands.queryDeviceIsMissing(device.address); final result = await commandService.sendCommand(routerIpAddress, command); if (result.success && result.response != null) { final missingValue = ProtocolParser.extractResponseValue( result.response!, ); if (missingValue != null) { final isMissing = missingValue == '1' || missingValue.toLowerCase() == 'true'; await device.updatePointValue(3, isMissing); logInfo('Device ${device.address} missing: $isMissing'); } } } catch (e) { logError('Error querying missing status: $e'); } } Future<void> _queryFaultyStatus( String routerIpAddress, HelvarDriverOutputDevice device, ) async { try { final command = HelvarNetCommands.queryDeviceIsFaulty(device.address); final result = await commandService.sendCommand(routerIpAddress, command); if (result.success && result.response != null) { final faultyValue = ProtocolParser.extractResponseValue( result.response!, ); if (faultyValue != null) { final isFaulty = faultyValue == '1' || faultyValue.toLowerCase() == 'true'; await device.updatePointValue(4, isFaulty); logInfo('Device ${device.address} faulty: $isFaulty'); } } } catch (e) { logError('Error querying faulty status: $e'); } } Future<void> _queryOutputLevel( String routerIpAddress, HelvarDriverOutputDevice device, ) async { try { final command = HelvarNetCommands.queryLoadLevel(device.address); final result = await commandService.sendCommand(routerIpAddress, command); if (result.success && result.response != null) { final levelValue = ProtocolParser.extractResponseValue( result.response!, ); if (levelValue != null) { final level = double.tryParse(levelValue) ?? 0.0; await device.updatePointValue(5, level); device.level = level.round(); logInfo('Device ${device.address} output level: $level%'); } } } catch (e) { logError('Error querying output level: $e'); } } Future<void> _queryPowerConsumption( String routerIpAddress, HelvarDriverOutputDevice device, ) async { try { final command = HelvarNetCommands.queryPowerConsumption(device.address); final result = await commandService.sendCommand(routerIpAddress, command); if (result.success && result.response != null) { final powerValue = ProtocolParser.extractResponseValue( result.response!, ); if (powerValue != null) { final power = double.tryParse(powerValue) ?? 0.0; await device.updatePointValue(6, power); device.powerConsumption = power; logInfo('Device ${device.address} power consumption: ${power}W'); } } } catch (e) { logError('Error querying power consumption: $e'); } } Future<bool> queryOutputDevicePoint( String routerIpAddress, HelvarDriverOutputDevice device, int pointId, ) async { try { switch (pointId) { case 1: await _queryDeviceState(routerIpAddress, device); break; case 2: await _queryLampFailure(routerIpAddress, device); break; case 3: await _queryMissingStatus(routerIpAddress, device); break; case 4: await _queryFaultyStatus(routerIpAddress, device); break; case 5: await _queryOutputLevel(routerIpAddress, device); break; case 6: await _queryPowerConsumption(routerIpAddress, device); break; default: logWarning('Unknown point ID: $pointId'); return false; } return true; } catch (e) { logError('Error querying point $pointId: $e'); return false; } } static String getPointDescription(int pointId) { switch (pointId) { case 1: return 'Device State - Indicates if device has any state issues'; case 2: return 'Lamp Failure - Indicates if the lamp has failed'; case 3: return 'Missing - Indicates if the device is missing/not responding'; case 4: return 'Faulty - Indicates if the device is in a faulty state'; case 5: return 'Output Level - Current output level percentage (0-100%)'; case 6: return 'Power Consumption - Current power consumption in Watts'; default: return 'Unknown point'; } } } 

// File: \lib\services\discovery_service.dart
import 'dart:async'; import 'package:grms_designer/services/scene_query_service.dart'; import 'package:uuid/uuid.dart'; import '../comm/models/command_models.dart'; import '../models/helvar_models/helvar_device.dart'; import '../models/helvar_models/helvar_group.dart'; import '../models/helvar_models/helvar_router.dart'; import '../protocol/device_types.dart'; import '../protocol/protocol_constants.dart'; import '../protocol/query_commands.dart'; import '../comm/router_command_service.dart'; import '../utils/logger.dart'; import '../factories/helvar_device_factory.dart'; import '../protocol/protocol_parser.dart'; class DiscoveryService { final RouterCommandService commandService; DiscoveryService(this.commandService); Future<HelvarDevice?> _createDeviceFromDiscovery( HelvarRouter router, int subnet, int deviceId, int typeCode, ) async { final routerIpAddress = router.ipAddress; final deviceAddress = '${router.clusterId}.${router.clusterMemberId}.$subnet.$deviceId'; final descResponse = await commandService.sendCommand( routerIpAddress, HelvarNetCommands.queryDescriptionDevice(deviceAddress), ); final description = descResponse.success && descResponse.response != null ? ProtocolParser.extractResponseValue(descResponse.response!) ?? 'Device $deviceId' : 'Device $deviceId'; final deviceStateResponse = await commandService.sendCommand( routerIpAddress, HelvarNetCommands.queryDeviceState(deviceAddress), ); int? deviceStateCode; String deviceState = ''; if (deviceStateResponse.success && deviceStateResponse.response != null) { final deviceStateValue = ProtocolParser.extractResponseValue( deviceStateResponse.response!, ); deviceStateCode = int.tryParse(deviceStateValue!) ?? 0; deviceState = getStateFlagsDescription(deviceStateCode); logInfo('  State: $deviceStateCode ($deviceState)'); } int? loadLevel; if (typeCode == 1 || typeCode == 1025 || typeCode == 1537) { try { final levelResponse = await commandService.sendCommand( routerIpAddress, HelvarNetCommands.queryLoadLevel(deviceAddress), ); if (levelResponse.success && levelResponse.response != null) { final levelValue = ProtocolParser.extractResponseValue( levelResponse.response!, ); loadLevel = int.tryParse(levelValue!) ?? 0; } } catch (e) { logError('Error getting load level: $e'); } } final bool isButton = isButtonDevice(typeCode); final bool isMultisensor = isDeviceMultisensor(typeCode); final String deviceTypeString = getDeviceTypeDescription(typeCode); return HelvarDeviceFactory.createDevice( deviceId: deviceId, deviceAddress: deviceAddress, deviceState: deviceState, description: description, deviceTypeString: deviceTypeString, typeCode: typeCode, deviceStateCode: deviceStateCode, loadLevel: loadLevel, isButton: isButton, isMultisensor: isMultisensor, ); } Future<HelvarGroup> discoverGroupScenes( String routerIpAddress, HelvarGroup group, SceneQueryService sceneQueryService, ) async { try { logInfo('Discovering scenes for group: ${group.groupId}'); final groupIdInt = int.tryParse(group.groupId); if (groupIdInt == null) { logError('Invalid group ID: ${group.groupId}'); return group; } final sceneData = await sceneQueryService.exploreGroupScenes( routerIpAddress, groupIdInt, ); final lsig = await sceneQueryService.queryLastSceneInGroup( routerIpAddress, groupIdInt, ); int? lsib1; int? lsib2; final sceneTable = sceneQueryService.buildSceneTable(sceneData); final updatedGroup = group.copyWith( lsig: lsig, lsib1: lsib1,  lsib2: lsib2,  sceneTable: sceneTable, ); logInfo( 'Scene discovery complete for group ${group.groupId}. Scene table: $sceneTable', ); return updatedGroup; } catch (e) { logError('Error discovering group scenes: $e'); return group; } } Future<List<HelvarGroup>> discoverScenesForGroups( String routerIpAddress, List<HelvarGroup> groups, SceneQueryService sceneQueryService, ) async { final updatedGroups = <HelvarGroup>[]; for (final group in groups) { try { final updatedGroup = await discoverGroupScenes( routerIpAddress, group, sceneQueryService, ); updatedGroups.add(updatedGroup); await Future.delayed(const Duration(milliseconds: 200)); } catch (e) { logError('Error discovering scenes for group ${group.groupId}: $e'); updatedGroups.add(group); } } return updatedGroups; } Future<List<HelvarDevice>> _discoverSubnetDevices( HelvarRouter router, int subnet, ) async { final routerIpAddress = router.ipAddress; final subnetAddress = '${router.clusterId}.${router.clusterMemberId}.$subnet'; final devicesResponse = await commandService.sendCommand( routerIpAddress, HelvarNetCommands.queryDeviceTypesAndAddresses(subnetAddress), ); if (!devicesResponse.success || devicesResponse.response == null) { return []; } final devicesValue = ProtocolParser.extractResponseValue( devicesResponse.response!, ); if (devicesValue == null || devicesValue.isEmpty) { logWarning('No devices found on subnet $subnet'); return []; } final deviceAddressTypes = ProtocolParser.parseDeviceAddressesAndTypes( devicesValue, ); final subnetDevices = <HelvarDevice>[]; for (final entry in deviceAddressTypes.entries) { final deviceId = entry.key; final typeCode = entry.value; if (deviceId >= 65500) { logWarning('Skipping high device ID: $deviceId'); continue; } final device = await _createDeviceFromDiscovery( router, subnet, deviceId, typeCode, ); if (device != null) { subnetDevices.add(device); } } return subnetDevices; } Future<void> _fetchRouterMetadata(HelvarRouter router) async { final routerIpAddress = router.ipAddress; final routerAddress = "${router.clusterId}.${router.clusterMemberId}"; final typeResponse = await commandService.sendCommand( routerIpAddress, HelvarNetCommands.queryDeviceType(routerAddress), priority: CommandPriority.high, ); if (typeResponse.success && typeResponse.response != null) { final typeValue = ProtocolParser.extractResponseValue( typeResponse.response!, ); if (typeValue != null) { final typeCode = int.tryParse(typeValue) ?? 0; router.deviceTypeCode = typeCode; router.deviceType = getDeviceTypeDescription(typeCode); } } else { logDebug('Failed to get router type: $typeResponse'); } final descResponse = await commandService.sendCommand( routerIpAddress, HelvarNetCommands.queryDescriptionDevice(routerAddress), ); if (descResponse.success && descResponse.response != null) { final descValue = ProtocolParser.extractResponseValue( descResponse.response!, ); if (descValue != null) { router.description = descValue; } else { logDebug('Failed to get router description: $descResponse'); } } final stateResponse = await commandService.sendCommand( routerIpAddress, HelvarNetCommands.queryDeviceState(routerAddress), ); if (stateResponse.success && stateResponse.response != null) { final stateValue = ProtocolParser.extractResponseValue( stateResponse.response!, ); if (stateValue != null) { final stateCode = int.tryParse(stateValue) ?? 0; router.deviceStateCode = stateCode; router.deviceState = getStateFlagsDescription(stateCode); } else { logDebug('Failed to get router state: $stateResponse'); } } final typesAndAddressesResponse = await commandService.sendCommand( routerIpAddress, HelvarNetCommands.queryDeviceTypesAndAddresses(router.address), ); if (typesAndAddressesResponse.success && typesAndAddressesResponse.response != null) { final addressesValue = ProtocolParser.extractResponseValue( typesAndAddressesResponse.response!, ); if (addressesValue != null) { router.deviceAddresses = addressesValue.split(','); } else { logDebug( 'Failed to get device types and addresses: $typesAndAddressesResponse', ); } } } Future<HelvarRouter?> discoverRouterWithPersistentConnection( String routerIpAddress, ) async { try { bool connected = await commandService.ensureConnection(routerIpAddress); if (!connected) { return null; } return await discoverRouter(routerIpAddress); } catch (e) { logError('Error discovering router with persistent connection: $e'); return null; } } Future<HelvarRouter?> _createBasicRouter(String routerIpAddress) async { final ipParts = routerIpAddress.split('.'); if (ipParts.length != 4) { logDebug('Invalid router IP address format: $routerIpAddress'); return null; } final clusterId = int.parse(ipParts[2]); final clusterMemberId = int.parse(ipParts[3]); final routerAddress = '$clusterId.$clusterMemberId'; logInfo('Router address derived as: $routerAddress'); return HelvarRouter( address: routerAddress, ipAddress: routerIpAddress, description: 'Router $clusterMemberId', clusterId: clusterId, clusterMemberId: clusterMemberId, ); } Future<void> _discoverRouterDevices(HelvarRouter router) async { for (int subnet = 1; subnet <= 4; subnet++) { final subnetDevices = await _discoverSubnetDevices(router, subnet); if (subnetDevices.isNotEmpty) { router.devicesBySubnet[subnet] = subnetDevices; for (final device in subnetDevices) { router.devices.add(device); } } else { logWarning('No devices found on subnet $subnet'); } } } Future<HelvarRouter?> discoverRouter(String routerIpAddress) async { try { final router = await _createBasicRouter(routerIpAddress); if (router == null) { return null; } await _fetchRouterMetadata(router); await _discoverRouterDevices(router); return router; } catch (e) { logError('Error discovering router: $e'); return null; } } Future<List<HelvarGroup>> discoverGroups(String routerIpAddress) async { final groups = <HelvarGroup>[]; try { final groupsResponse = await commandService.sendCommand( routerIpAddress, HelvarNetCommands.queryGroups(), priority: CommandPriority.high, ); final groupsValue = ProtocolParser.extractResponseValue( groupsResponse.response ?? '', ); if (groupsValue != null && groupsValue.isNotEmpty) { final groupIds = groupsValue.split(','); for (final groupId in groupIds) { if (groupId.isEmpty) continue; try { final descResponse = await commandService.sendCommand( routerIpAddress, HelvarNetCommands.queryDescriptionGroup(int.parse(groupId)), priority: CommandPriority.high, ); final description = ProtocolParser.extractResponseValue( descResponse.response ?? '', ) ?? 'Group $groupId'; groups.add( HelvarGroup( id: const Uuid().v4(), groupId: groupId, description: description, type: 'Group', powerPollingMinutes: 15, gatewayRouterIpAddress: routerIpAddress, ), ); } catch (e) { logError('Error processing group $groupId: $e'); } } } return groups; } catch (e) { logError('Error discovering groups: $e'); return []; } } Future<List<HelvarRouter>> discoverWorkgroup( List<String> routerIpAddresses, ) async { final routers = <HelvarRouter>[]; for (final ipAddress in routerIpAddresses) { logInfo('Discovering router at $ipAddress...'); final router = await discoverRouter(ipAddress); if (router != null) { routers.add(router); } } return routers; } } 

// File: \lib\services\file_storage_service.dart
import 'dart:convert'; import 'dart:io'; import '../models/helvar_models/workgroup.dart'; import '../utils/logger.dart'; import 'app_directory_service.dart'; class FileStorageService { static const String _defaultFilename = 'helvarnet_workgroups.json'; final AppDirectoryService _directoryService = AppDirectoryService(); Future<void> saveWorkgroups(List<Workgroup> workgroups) async { try { final filePath = await _directoryService.getWorkgroupFilePath(_defaultFilename); final file = File(filePath); final jsonData = workgroups.map((workgroup) => workgroup.toJson()).toList(); final jsonString = jsonEncode(jsonData); await file.writeAsString(jsonString); logInfo('Workgroups saved to: $filePath'); } catch (e) { logError('Error saving workgroups: $e'); rethrow; } } Future<List<Workgroup>> loadWorkgroups() async { try { final filePath = await _directoryService.getWorkgroupFilePath(_defaultFilename); final file = File(filePath); if (!await file.exists()) { logWarning('No saved workgroups file found.'); return []; } final jsonString = await file.readAsString(); final List<dynamic> jsonData = jsonDecode(jsonString); return jsonData.map((json) => Workgroup.fromJson(json)).toList(); } catch (e) { logError('Error loading workgroups: $e'); return []; } } Future<void> exportWorkgroups( List<Workgroup> workgroups, String filePath) async { try { final file = File(filePath); final jsonData = workgroups.map((workgroup) => workgroup.toJson()).toList(); final jsonString = jsonEncode(jsonData); await file.writeAsString(jsonString); logInfo('Workgroups exported to: $filePath'); final fileName = filePath.split(Platform.pathSeparator).last; await _directoryService.exportFile( AppDirectoryService.workgroupsDir, _defaultFilename, fileName); } catch (e) { logError('Error exporting workgroups: $e'); rethrow; } } Future<List<Workgroup>> importWorkgroups(String filePath) async { try { final file = File(filePath); if (!await file.exists()) { throw FileSystemException('File not found', filePath); } final jsonString = await file.readAsString(); final List<dynamic> jsonData = jsonDecode(jsonString); await _directoryService.createBackup( AppDirectoryService.workgroupsDir, _defaultFilename); return jsonData.map((json) => Workgroup.fromJson(json)).toList(); } catch (e) { logError('Error importing workgroups: $e'); rethrow; } } Future<String?> createWorkgroupsBackup() async { return _directoryService.createBackup( AppDirectoryService.workgroupsDir, _defaultFilename); } Future<List<FileSystemEntity>> listWorkgroupBackups() async { return _directoryService.listFiles(AppDirectoryService.backupsDir); } Future<bool> restoreWorkgroupsFromBackup(String backupFileName) async { try { final backupFilePath = await _directoryService.getBackupFilePath(backupFileName); final backupFile = File(backupFilePath); if (!await backupFile.exists()) { return false; } final targetFilePath = await _directoryService.getWorkgroupFilePath(_defaultFilename); await backupFile.copy(targetFilePath); return true; } catch (e) { logError('Error restoring workgroups from backup: $e'); return false; } } } 

// File: \lib\services\flowsheet_storage_service.dart
import 'dart:convert'; import 'dart:io'; import 'dart:ui'; import 'package:uuid/uuid.dart'; import '../models/flowsheet.dart'; import '../niagara/models/component.dart'; import '../niagara/models/connection.dart'; import '../utils/helpers.dart'; import '../utils/logger.dart'; import 'app_directory_service.dart'; class FlowsheetStorageService { final AppDirectoryService _directoryService = AppDirectoryService(); static const String flowsheetsDir = 'flowsheets'; Future<void> initialize() async { await _directoryService.initialize(); await _createFlowsheetsDirectory(); } Future<String> _createFlowsheetsDirectory() async { return _directoryService.getFlowsheetFilePath(flowsheetsDir); } Future<String> _getFlowsheetFilePath(String id) async { return _directoryService.getFilePath(flowsheetsDir, 'flowsheet_$id.json'); } Future<void> saveFlowsheet(Flowsheet flowsheet) async { try { final filePath = await _getFlowsheetFilePath(flowsheet.id); final file = File(filePath); final jsonString = jsonEncode(flowsheet.toJson()); await file.writeAsString(jsonString); } catch (e) { logError('Error saving flowsheet: $e'); rethrow; } } Future<Flowsheet?> loadFlowsheet(String id) async { try { final filePath = await _getFlowsheetFilePath(id); final file = File(filePath); if (!await file.exists()) { logWarning('No flowsheet file found for ID: $id'); return null; } final jsonString = await file.readAsString(); final json = jsonDecode(jsonString); return Flowsheet.fromJson(json); } catch (e) { logError('Error loading flowsheet: $e'); return null; } } Future<bool> deleteFlowsheet(String id) async { try { final filePath = await _getFlowsheetFilePath(id); final file = File(filePath); if (await file.exists()) { await _directoryService.createBackup( flowsheetsDir, 'flowsheet_$id.json'); await file.delete(); logInfo('Flowsheet deleted: $filePath'); return true; } logWarning('Flowsheet file not found for deletion: $filePath'); return false; } catch (e) { logError('Error deleting flowsheet: $e'); return false; } } Future<List<Flowsheet>> listFlowsheets() async { try { await _createFlowsheetsDirectory(); final entities = await _directoryService.listFiles(flowsheetsDir); final List<Flowsheet> flowsheets = []; for (var entity in entities) { if (entity is File && entity.path.endsWith('.json')) { try { final jsonString = await entity.readAsString(); final json = jsonDecode(jsonString); flowsheets.add(Flowsheet.fromJson(json)); } catch (e) { logError('Error reading flowsheet file ${entity.path}: $e'); } } } flowsheets.sort((a, b) => b.modifiedAt.compareTo(a.modifiedAt)); return flowsheets; } catch (e) { logError('Error listing flowsheets: $e'); return []; } } Future<Flowsheet> createFlowsheet(String name) async { final id = const Uuid().v4(); final flowsheet = Flowsheet( id: id, name: name, ); await saveFlowsheet(flowsheet); return flowsheet; } Future<Flowsheet> ensureDefaultFlowsheet() async { final flowsheets = await listFlowsheets(); if (flowsheets.isEmpty) { return createFlowsheet('Default Flowsheet'); } else { return flowsheets.first; } } Future<Flowsheet?> renameFlowsheet(String id, String newName) async { final flowsheet = await loadFlowsheet(id); if (flowsheet != null) { flowsheet.name = newName; flowsheet.modifiedAt = DateTime.now(); await saveFlowsheet(flowsheet); return flowsheet; } return null; } Future<Flowsheet?> duplicateFlowsheet(String id, String newName) async { final original = await loadFlowsheet(id); if (original != null) { final newId = const Uuid().v4(); final Map<String, String> oldToNewIdMap = {}; final List<Component> newComponents = []; for (var originalComponent in original.components) { final String oldId = originalComponent.id; final String newComponentId = "${originalComponent.id}_copy"; oldToNewIdMap[oldId] = newComponentId; Component newComponent = deepCopyComponent(originalComponent, newComponentId); newComponents.add(newComponent); } final List<Connection> newConnections = []; for (var originalConnection in original.connections) { if (oldToNewIdMap.containsKey(originalConnection.fromComponentId) && oldToNewIdMap.containsKey(originalConnection.toComponentId)) { newConnections.add(Connection( fromComponentId: oldToNewIdMap[originalConnection.fromComponentId]!, fromPortIndex: originalConnection.fromPortIndex, toComponentId: oldToNewIdMap[originalConnection.toComponentId]!, toPortIndex: originalConnection.toPortIndex, )); } } final Map<String, Offset> newComponentPositions = {}; final Map<String, double> newComponentWidths = {}; original.componentPositions.forEach((oldId, position) { if (oldToNewIdMap.containsKey(oldId)) { newComponentPositions[oldToNewIdMap[oldId]!] = position; } }); original.componentWidths.forEach((oldId, width) { if (oldToNewIdMap.containsKey(oldId)) { newComponentWidths[oldToNewIdMap[oldId]!] = width; } }); final duplicate = Flowsheet( id: newId, name: newName, components: newComponents, connections: newConnections, canvasSize: original.canvasSize, canvasOffset: original.canvasOffset, ); newComponentPositions.forEach((id, position) { duplicate.updateComponentPosition(id, position); }); newComponentWidths.forEach((id, width) { duplicate.updateComponentWidth(id, width); }); await saveFlowsheet(duplicate); return duplicate; } return null; } Future<bool> exportFlowsheet(String id, String filePath) async { try { final flowsheet = await loadFlowsheet(id); if (flowsheet == null) return false; final file = File(filePath); final jsonString = jsonEncode(flowsheet.toJson()); await file.writeAsString(jsonString); final fileName = filePath.split(Platform.pathSeparator).last; await file.copy(await _directoryService.getFilePath( AppDirectoryService.exportsDir, fileName)); return true; } catch (e) { logError('Error exporting flowsheet: $e'); return false; } } Future<Flowsheet?> importFlowsheet(String filePath, {String? newName}) async { try { final file = File(filePath); if (!await file.exists()) return null; final jsonString = await file.readAsString(); final json = jsonDecode(jsonString); final newId = const Uuid().v4(); final flowsheet = Flowsheet.fromJson(json); final importedFlowsheet = Flowsheet( id: newId, name: newName ?? '${flowsheet.name} (Imported)', createdAt: DateTime.now(), modifiedAt: DateTime.now(), components: flowsheet.components, connections: flowsheet.connections, canvasSize: flowsheet.canvasSize, canvasOffset: flowsheet.canvasOffset, ); await saveFlowsheet(importedFlowsheet); return importedFlowsheet; } catch (e) { logError('Error importing flowsheet: $e'); return null; } } Future<String?> createFlowsheetBackup(String id) async { try { return _directoryService.createBackup( flowsheetsDir, 'flowsheet_$id.json'); } catch (e) { logError('Error creating flowsheet backup: $e'); return null; } } } 

// File: \lib\services\group_polling_service.dart
import 'dart:async'; import '../comm/router_command_service.dart'; import '../models/helvar_models/helvar_group.dart'; import '../models/helvar_models/workgroup.dart'; import '../protocol/query_commands.dart'; import '../protocol/protocol_parser.dart'; import '../utils/logger.dart'; class GroupPollingService { final RouterCommandService _commandService; final Map<String, Timer> _workgroupTimers = {}; final Map<String, Timer> _groupTimers = {}; bool _isDisposed = false; GroupPollingService(this._commandService); Function(HelvarGroup updatedGroup)? onGroupPowerUpdated; void startWorkgroupPolling(Workgroup workgroup) { if (_isDisposed || !workgroup.pollEnabled) return; stopWorkgroupPolling(workgroup.id); logInfo('Starting polling for workgroup: ${workgroup.description}'); for (final group in workgroup.groups) { _startGroupPolling(workgroup, group); } logInfo( 'Started polling for ${workgroup.groups.length} groups in workgroup ${workgroup.description}', ); } void _startGroupPolling(Workgroup workgroup, HelvarGroup group) { if (_isDisposed) return; final groupKey = '${workgroup.id}_${group.id}'; _groupTimers[groupKey]?.cancel(); final intervalDuration = Duration(minutes: group.powerPollingMinutes); logInfo( 'Starting polling for group ${group.groupId} with ${group.powerPollingMinutes} minute interval', ); _pollGroupPowerConsumption(workgroup, group); _groupTimers[groupKey] = Timer.periodic(intervalDuration, (timer) { if (_isDisposed) { timer.cancel(); return; } _pollGroupPowerConsumption(workgroup, group); }); } void stopWorkgroupPolling(String workgroupId) { logInfo('Stopping polling for workgroup: $workgroupId'); final keysToRemove = <String>[]; for (final entry in _groupTimers.entries) { if (entry.key.startsWith('${workgroupId}_')) { entry.value.cancel(); keysToRemove.add(entry.key); } } for (final key in keysToRemove) { _groupTimers.remove(key); } _workgroupTimers[workgroupId]?.cancel(); _workgroupTimers.remove(workgroupId); } void updateWorkgroupPolling(Workgroup workgroup) { if (_isDisposed) return; if (workgroup.pollEnabled) { startWorkgroupPolling(workgroup); } else { stopWorkgroupPolling(workgroup.id); } } void updateGroupPolling(Workgroup workgroup, HelvarGroup group) { if (_isDisposed || !workgroup.pollEnabled) return; logInfo( 'Updating polling interval for group ${group.groupId} to ${group.powerPollingMinutes} minutes', ); _startGroupPolling(workgroup, group); } Future<void> _pollGroupPowerConsumption( Workgroup workgroup, HelvarGroup group, ) async { try { if (_isDisposed) return; if (workgroup.routers.isEmpty) { logWarning( 'No routers available for workgroup ${workgroup.description}', ); return; } final router = workgroup.routers.first; final groupIdInt = int.tryParse(group.groupId); if (groupIdInt == null) { logError('Invalid group ID: ${group.groupId}'); return; } logDebug('Polling power consumption for group ${group.groupId}'); final powerCommand = HelvarNetCommands.queryGroupPowerConsumption( groupIdInt, ); final powerResult = await _commandService.sendCommand( router.ipAddress, powerCommand, ); if (powerResult.success && powerResult.response != null) { final powerValue = ProtocolParser.extractResponseValue( powerResult.response!, ); if (powerValue != null) { final powerConsumption = double.tryParse(powerValue) ?? 0.0; final now = DateTime.now(); final updatedGroup = group.copyWith( powerConsumption: powerConsumption, lastPowerUpdateTime: now, ); logInfo( 'Polled power consumption for group ${group.groupId}: ${powerConsumption}W', ); onGroupPowerUpdated?.call(updatedGroup); } else { logWarning( 'Empty power consumption value received for group ${group.groupId}', ); } } else { logWarning( 'Failed to poll power consumption for group ${group.groupId}: ${powerResult.response}', ); } } catch (e) { logError( 'Error polling power consumption for group ${group.groupId}: $e', ); } } bool isWorkgroupPollingActive(String workgroupId) { return _groupTimers.keys.any((key) => key.startsWith('${workgroupId}_')); } Map<String, int> getActivePollingIntervals(String workgroupId) { final intervals = <String, int>{}; for (final entry in _groupTimers.entries) { if (entry.key.startsWith('${workgroupId}_')) { final groupId = entry.key.split('_').last; } } return intervals; } void dispose() { _isDisposed = true; for (final timer in _workgroupTimers.values) { timer.cancel(); } _workgroupTimers.clear(); for (final timer in _groupTimers.values) { timer.cancel(); } _groupTimers.clear(); logInfo('Group polling service disposed'); } } 

// File: \lib\services\log_service.dart
import 'package:flutter/foundation.dart'; import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; enum LogLevel { verbose, debug, info, warning, error } class LogEntry { final String message; final LogLevel level; final DateTime timestamp; final String? tag; final StackTrace? stackTrace; LogEntry({ required this.message, required this.level, required this.timestamp, this.tag, this.stackTrace, }); String get formattedTime => '${timestamp.hour.toString().padLeft(2, '0')}:${timestamp.minute.toString().padLeft(2, '0')}:${timestamp.second.toString().padLeft(2, '0')}.${timestamp.millisecond.toString().padLeft(3, '0')}'; Color get levelColor { switch (level) { case LogLevel.verbose: return Colors.grey; case LogLevel.debug: return Colors.blue; case LogLevel.info: return Colors.green; case LogLevel.warning: return Colors.orange; case LogLevel.error: return Colors.red; } } String get levelName => level.toString().split('.').last.toUpperCase(); } class LogService extends StateNotifier<List<LogEntry>> { LogService() : super([]); static const int _maxLogEntries = 1000; void log( String message, { LogLevel level = LogLevel.info, String? tag, StackTrace? stackTrace, }) { final entry = LogEntry( message: message, level: level, timestamp: DateTime.now(), tag: tag, stackTrace: stackTrace, ); if (kDebugMode) { switch (level) { case LogLevel.error: debugPrint( '❌ ${entry.formattedTime} - ${entry.levelName}: ${entry.message}', ); break; case LogLevel.warning: debugPrint( '⚠️ ${entry.formattedTime} - ${entry.levelName}: ${entry.message}', ); break; default: debugPrint( '${entry.formattedTime} - ${entry.levelName}: ${entry.message}', ); } } if (state.length > _maxLogEntries) { state = state.sublist(0, _maxLogEntries); } } void verbose(String message, {String? tag, StackTrace? stackTrace}) { log(message, level: LogLevel.verbose, tag: tag, stackTrace: stackTrace); } void debug(String message, {String? tag, StackTrace? stackTrace}) { log(message, level: LogLevel.debug, tag: tag, stackTrace: stackTrace); } void info(String message, {String? tag, StackTrace? stackTrace}) { log(message, level: LogLevel.info, tag: tag, stackTrace: stackTrace); } void warning(String message, {String? tag, StackTrace? stackTrace}) { log(message, level: LogLevel.warning, tag: tag, stackTrace: stackTrace); } void error(String message, {String? tag, StackTrace? stackTrace}) { log(message, level: LogLevel.error, tag: tag, stackTrace: stackTrace); } void clear() { state = []; } List<LogEntry> getLogsByLevel(LogLevel level) { return state.where((entry) => entry.level == level).toList(); } List<LogEntry> getLogsByTag(String tag) { return state.where((entry) => entry.tag == tag).toList(); } List<LogEntry> searchLogs(String query) { final lowercaseQuery = query.toLowerCase(); return state .where( (entry) => entry.message.toLowerCase().contains(lowercaseQuery) || (entry.tag?.toLowerCase().contains(lowercaseQuery) ?? false), ) .toList(); } } final logServiceProvider = StateNotifierProvider<LogService, List<LogEntry>>(( ref, ) { return LogService(); }); 

// File: \lib\services\router_storage_service.dart
import 'dart:convert'; import 'dart:io'; import 'package:path_provider/path_provider.dart'; import '../models/helvar_models/helvar_router.dart'; import '../models/helvar_models/helvar_device.dart'; import '../utils/logger.dart'; class RouterStorageService { Future<String> get _localPath async { final directory = await getApplicationDocumentsDirectory(); return directory.path; } Future<String> _getRouterFilePath( String workgroupId, String routerAddress) async { final path = await _localPath; return '$path/workgroup_${workgroupId}_router_$routerAddress.json'; } Future<void> saveRouterDevices(String workgroupId, String routerAddress, List<HelvarDevice> devices) async { try { final filePath = await _getRouterFilePath(workgroupId, routerAddress); final file = File(filePath); final jsonData = devices.map((device) => device.toJson()).toList(); final jsonString = jsonEncode(jsonData); await file.writeAsString(jsonString); logInfo('Router devices saved to: $filePath'); } catch (e) { logError('Error saving router devices: $e'); rethrow; } } Future<List<HelvarDevice>> loadRouterDevices( String workgroupId, String routerAddress) async { try { final filePath = await _getRouterFilePath(workgroupId, routerAddress); final file = File(filePath); if (!await file.exists()) { logWarning('No saved router devices file found.'); return []; } final jsonString = await file.readAsString(); final List<dynamic> jsonData = jsonDecode(jsonString); return jsonData.map((json) => HelvarDevice.fromJson(json)).toList(); } catch (e) { logError('Error loading router devices: $e'); return []; } } Future<void> exportRouterDevices( List<HelvarDevice> devices, String filePath) async { try { final file = File(filePath); final jsonData = devices.map((device) => device.toJson()).toList(); final jsonString = jsonEncode(jsonData); await file.writeAsString(jsonString); logInfo('Router devices exported to: $filePath'); } catch (e) { logError('Error exporting router devices: $e'); rethrow; } } Future<List<HelvarDevice>> importRouterDevices(String filePath) async { try { final file = File(filePath); if (!await file.exists()) { throw FileSystemException('File not found', filePath); } final jsonString = await file.readAsString(); final List<dynamic> jsonData = jsonDecode(jsonString); return jsonData.map((json) => HelvarDevice.fromJson(json)).toList(); } catch (e) { logError('Error importing router devices: $e'); rethrow; } } Future<void> updateRouterDevices( String workgroupId, HelvarRouter router) async { try { await saveRouterDevices(workgroupId, router.address, router.devices); } catch (e) { logError('Error updating router devices: $e'); rethrow; } } } 

// File: \lib\services\scene_query_service.dart
import '../comm/router_command_service.dart'; import '../protocol/query_commands.dart'; import '../protocol/protocol_parser.dart'; import '../utils/logger.dart'; class SceneQueryService { final RouterCommandService commandService; SceneQueryService(this.commandService); Future<int?> queryLastSceneInBlock( String routerIpAddress, int groupId, int blockId, ) async { try { logInfo('Querying last scene in block $blockId for group $groupId'); final command = HelvarNetCommands.queryLastSceneInBlock(groupId, blockId); final result = await commandService.sendCommand(routerIpAddress, command); if (result.success && result.response != null) { final sceneValue = ProtocolParser.extractResponseValue( result.response!, ); if (sceneValue != null) { final sceneNumber = int.tryParse(sceneValue); logInfo('Last scene in block $blockId: $sceneNumber'); return sceneNumber; } } logWarning('Failed to query last scene in block: ${result.response}'); return null; } catch (e) { logError('Error querying last scene in block: $e'); return null; } } Future<int?> queryLastSceneInGroup( String routerIpAddress, int groupId, ) async { try { logInfo('Querying last scene in group $groupId'); final command = HelvarNetCommands.queryLastSceneInGroup(groupId); final result = await commandService.sendCommand(routerIpAddress, command); if (result.success && result.response != null) { final sceneValue = ProtocolParser.extractResponseValue( result.response!, ); if (sceneValue != null) { final sceneNumber = int.tryParse(sceneValue); logInfo('Last scene in group: $sceneNumber'); return sceneNumber; } } logWarning('Failed to query last scene in group: ${result.response}'); return null; } catch (e) { logError('Error querying last scene in group: $e'); return null; } } Future<List<String>> querySceneNames(String routerIpAddress) async { try { logInfo('Querying scene names'); final command = HelvarNetCommands.querySceneNames(); final result = await commandService.sendCommand(routerIpAddress, command); if (result.success && result.response != null) { final sceneNamesValue = ProtocolParser.extractResponseValue( result.response!, ); if (sceneNamesValue != null && sceneNamesValue.isNotEmpty) { final sceneNames = sceneNamesValue.split(','); logInfo('Found ${sceneNames.length} scene names: $sceneNames'); return sceneNames; } } logWarning('Failed to query scene names: ${result.response}'); return []; } catch (e) { logError('Error querying scene names: $e'); return []; } } Future<Map<String, dynamic>?> querySceneInfo( String routerIpAddress, String address, ) async { try { logInfo('Querying scene info for address: $address'); final command = HelvarNetCommands.querySceneInfo(address); final result = await commandService.sendCommand(routerIpAddress, command); if (result.success && result.response != null) { final sceneInfoValue = ProtocolParser.extractResponseValue( result.response!, ); if (sceneInfoValue != null && sceneInfoValue.isNotEmpty) { logInfo('Scene info for $address: $sceneInfoValue'); final parsedInfo = ProtocolParser.parseFullResponse(result.response!); return parsedInfo; } } logWarning('Failed to query scene info: ${result.response}'); return null; } catch (e) { logError('Error querying scene info: $e'); return null; } } Future<Map<int, int?>> exploreGroupScenes( String routerIpAddress, int groupId, ) async { try { logInfo('Exploring scenes for group $groupId'); final sceneData = <int, int?>{}; for (int block = 1; block <= 8; block++) { final lastScene = await queryLastSceneInBlock( routerIpAddress, groupId, block, ); sceneData[block] = lastScene; await Future.delayed(const Duration(milliseconds: 100)); } logInfo('Scene exploration complete for group $groupId: $sceneData'); return sceneData; } catch (e) { logError('Error exploring group scenes: $e'); return {}; } } List<int> buildSceneTable(Map<int, int?> sceneData) { final sceneSet = <int>{}; for (final entry in sceneData.entries) { if (entry.value != null && entry.value! > 0) { sceneSet.add(entry.value!); } } final sceneTable = sceneSet.toList()..sort(); logInfo( 'Built scene table with ${sceneTable.length} distinct scenes: $sceneTable', ); return sceneTable; } } 

// File: \lib\utils\canvas_dialog_utils.dart
import 'package:flutter/material.dart'; import 'package:grms_designer/niagara/controllers/canvas_interaction_controller.dart'; import 'package:grms_designer/niagara/controllers/clipboard_manager.dart'; import 'package:grms_designer/niagara/models/component.dart'; import 'package:grms_designer/niagara/models/component_type.dart'; import 'package:grms_designer/niagara/models/ramp_component.dart'; import 'package:grms_designer/niagara/models/rectangle.dart'; import 'package:grms_designer/utils/canvas_utils.dart'; import 'package:grms_designer/utils/device_utils.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; import 'package:grms_designer/utils/general_ui.dart'; void showAddComponentDialogAtPosition( BuildContext context, Offset position, Function(ComponentType, {Offset? clickPosition}) addNewComponent, ) { showDialog( context: context, builder: (BuildContext context) { return Dialog( child: SizedBox( width: 400, height: 600, child: Column( children: [ AppBar( title: const Text('Add Component'), automaticallyImplyLeading: false, actions: [ IconButton( icon: const Icon(Icons.close), onPressed: () { Navigator.of(context).pop(); }, ), ], ), Expanded( child: SingleChildScrollView( child: Column( children: [ buildComponentCategorySection( context, 'Custom Components', [RectangleComponent.RECTANGLE, RampComponent.RAMP], position, addNewComponent, ), buildComponentCategorySection( context, 'Logic Gates', [ ComponentType.AND_GATE, ComponentType.OR_GATE, ComponentType.XOR_GATE, ComponentType.NOT_GATE, ], position, addNewComponent, ), buildComponentCategorySection( context, 'Math Operations', [ ComponentType.ADD, ComponentType.SUBTRACT, ComponentType.MULTIPLY, ComponentType.DIVIDE, ComponentType.MAX, ComponentType.MIN, ComponentType.POWER, ComponentType.ABS, ], position, addNewComponent, ), buildComponentCategorySection( context, 'Comparisons', [ ComponentType.IS_GREATER_THAN, ComponentType.IS_LESS_THAN, ComponentType.IS_EQUAL, ], position, addNewComponent, ), buildComponentCategorySection( context, 'Writable Points', [ ComponentType.BOOLEAN_WRITABLE, ComponentType.NUMERIC_WRITABLE, ComponentType.STRING_WRITABLE, ], position, addNewComponent, ), buildComponentCategorySection( context, 'Read-Only Points', [ ComponentType.BOOLEAN_POINT, ComponentType.NUMERIC_POINT, ComponentType.STRING_POINT, ], position, addNewComponent, ), ], ), ), ), ], ), ), ); }, ); } Widget buildComponentCategorySection( BuildContext context, String title, List<String> typeStrings, Offset position, Function(ComponentType, {Offset? clickPosition}) addNewComponent, ) { List<ComponentType> types = typeStrings.map((t) => ComponentType(t)).toList(); return Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Padding( padding: const EdgeInsets.only(top: 12.0, bottom: 6.0), child: Text( title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16), ), ), const Divider(), Wrap( spacing: 8.0, runSpacing: 8.0, children: types.map((type) { return InkWell( onTap: () { addNewComponent(type, clickPosition: position); Navigator.pop(context); }, child: Container( padding: const EdgeInsets.all(8.0), decoration: BoxDecoration( border: Border.all(color: Colors.grey), borderRadius: BorderRadius.circular(4.0), ), child: Column( children: [ Icon(getIconForComponentType(type)), const SizedBox(height: 4.0), Text( getNameForComponentType(type), style: const TextStyle(fontSize: 12), textAlign: TextAlign.center, ), ], ), ), ); }).toList(), ), ], ); } void showPasteSpecialDialog( BuildContext context, ClipboardManager clipboardManager, Offset pastePosition, Function(Offset, int, bool) handlePasteSpecialComponent, ) { if (clipboardManager.isEmpty) return; TextEditingController copiesController = TextEditingController(text: '1'); ValueNotifier<bool> keepConnections = ValueNotifier<bool>(true); showDialog( context: context, builder: (BuildContext context) { return AlertDialog( title: const Row( children: [ Icon(Icons.copy, size: 20), SizedBox(width: 8), Text('Paste Special'), ], ), content: Column( mainAxisSize: MainAxisSize.min, crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( children: [ const Text('Number of copies'), const SizedBox(width: 12), SizedBox( width: 50, child: TextField( textAlign: TextAlign.center, keyboardType: TextInputType.number, decoration: const InputDecoration( contentPadding: EdgeInsets.symmetric( horizontal: 6, vertical: 0, ), border: OutlineInputBorder(), ), controller: copiesController, ), ), ], ), const SizedBox(height: 16), ValueListenableBuilder<bool>( valueListenable: keepConnections, builder: (context, value, child) { return Row( children: [ Checkbox( value: value, onChanged: (newValue) { keepConnections.value = newValue ?? true; }, ), const Text('Keep all links'), ], ); }, ), ], ), actions: [ cancelAction(context), TextButton( onPressed: () { int copies = int.tryParse(copiesController.text) ?? 1; copies = copies.clamp(1, 20); handlePasteSpecialComponent( pastePosition, copies, keepConnections.value, ); Navigator.of(context).pop(); }, child: const Text('OK'), ), ], ); }, ); } void showCanvasContextMenu( BuildContext context, Offset globalPosition, GlobalKey canvasKey, ClipboardManager clipboardManager, CanvasInteractionController canvasController, Function(Offset) handlePasteComponent, Function(Offset) showAddComponentDialog, Function(Offset) showPasteSpecialDialog, Function() selectAllComponents, ) { final canvasBox = canvasKey.currentContext?.findRenderObject() as RenderBox?; final canvasPosition = canvasBox != null ? canvasController.getCanvasPosition(globalPosition, canvasBox) : null; if (canvasPosition == null) return; final RenderBox overlay = Overlay.of(context).context.findRenderObject() as RenderBox; showMenu( context: context, position: RelativeRect.fromRect( Rect.fromPoints(globalPosition, globalPosition), Offset.zero & overlay.size, ), items: [...canvasMenuOptions(clipboardManager)], ).then((value) { if (value == null) return; switch (value) { case 'add-component': showAddComponentDialog(canvasPosition); break; case 'paste': handlePasteComponent(canvasPosition); break; case 'paste-special': showPasteSpecialDialog(canvasPosition); break; case 'select-all': selectAllComponents(); break; } }); } void showComponentContextMenu( BuildContext context, Offset position, Component component, ClipboardManager clipboardManager, Function(Component) handleCopyComponent, Function(BuildContext, Component) handleEditComponent, Function(Component) handleDeleteComponent, Function() handleCopyMultipleComponents, bool hasMultipleSelection, ) { final RenderBox overlay = Overlay.of(context).context.findRenderObject() as RenderBox; showMenu( context: context, position: RelativeRect.fromRect( Rect.fromPoints(position, position), Offset.zero & overlay.size, ), items: showContextMenuOptions(clipboardManager), ).then((value) { if (value == null) return; switch (value) { case 'copy': if (hasMultipleSelection) { handleCopyMultipleComponents(); } else { handleCopyComponent(component); } break; case 'edit': handleEditComponent(context, component); break; case 'delete': handleDeleteComponent(component); break; } }); } 

// File: \lib\utils\canvas_utils.dart
import 'package:flutter/material.dart'; import 'package:grms_designer/niagara/controllers/canvas_interaction_controller.dart'; import 'package:grms_designer/niagara/controllers/clipboard_manager.dart'; import 'package:grms_designer/niagara/controllers/flow_editor_state.dart'; import 'package:grms_designer/utils/dialog_utils.dart'; Offset getDefaultPosition( CanvasInteractionController canvasController, FlowEditorState editorState, ) { final RenderBox? viewerChildRenderBox = editorState.interactiveViewerChildKey.currentContext?.findRenderObject() as RenderBox?; if (viewerChildRenderBox != null) { final viewportSize = viewerChildRenderBox.size; final viewportCenter = Offset( viewportSize.width / 2, viewportSize.height / 2, ); return canvasController.getCanvasPosition( viewportCenter, viewerChildRenderBox, ) ?? Offset( canvasController.canvasSize.width / 2, canvasController.canvasSize.height / 2, ); } return Offset( canvasController.canvasSize.width / 2, canvasController.canvasSize.height / 2, ); } List<PopupMenuEntry<String>> canvasMenuOptions( ClipboardManager clipboardManager, ) { return [ PopupMenuItem( value: 'paste', enabled: !clipboardManager.isEmpty, child: Row( children: [ Icon( Icons.content_paste, size: 18, color: !clipboardManager.isEmpty ? null : Colors.grey, ), const SizedBox(width: 8), Text( 'Paste', style: TextStyle( color: !clipboardManager.isEmpty ? null : Colors.grey, ), ), ], ), ), PopupMenuItem( value: 'paste-special', enabled: !clipboardManager.isEmpty, child: Row( children: [ Icon( Icons.copy_all, size: 18, color: !clipboardManager.isEmpty ? null : Colors.grey, ), const SizedBox(width: 8), Text( 'Paste Special...', style: TextStyle( color: !clipboardManager.isEmpty ? null : Colors.grey, ), ), ], ), ), const PopupMenuItem( value: 'add-component', child: Row( children: [ Icon(Icons.add_box, size: 18), SizedBox(width: 8), Text('Add New Component...'), ], ), ), const PopupMenuItem( value: 'select-all', child: Row( children: [ Icon(Icons.select_all, size: 18), SizedBox(width: 8), Text('Select All'), ], ), ), ]; } List<PopupMenuEntry<String>> showContextMenuOptions( ClipboardManager clipboardManager, ) { return [ const PopupMenuItem( value: 'copy', child: Row( children: [ Icon(Icons.copy, size: 18), SizedBox(width: 8), Text('Copy'), ], ), ), const PopupMenuItem( value: 'edit', child: Row( children: [ Icon(Icons.edit, size: 18), SizedBox(width: 8), Text('Edit'), ], ), ), const PopupMenuItem( value: 'delete', child: Row( children: [ Icon(Icons.delete, size: 18), SizedBox(width: 8), Text('Delete'), ], ), ), ]; } AlertDialog showPasteSpecialDialog( BuildContext context, TextEditingController copiesController, ValueNotifier<bool> keepConnections, Function handlePasteSpecialComponent, Offset pastePosition, ) { return AlertDialog( title: const Text('Paste Special'), content: Column( mainAxisSize: MainAxisSize.min, children: [ Row( children: [ const Text('Number of copies:'), const SizedBox(width: 10), SizedBox( width: 50, child: TextField( controller: copiesController, keyboardType: TextInputType.number, decoration: const InputDecoration( border: OutlineInputBorder(), contentPadding: EdgeInsets.symmetric( horizontal: 8, vertical: 8, ), ), ), ), ], ), const SizedBox(height: 15), ValueListenableBuilder<bool>( valueListenable: keepConnections, builder: (context, value, child) { return CheckboxListTile( title: const Text('Keep connections between copies'), value: value, contentPadding: EdgeInsets.zero, controlAffinity: ListTileControlAffinity.leading, onChanged: (val) { keepConnections.value = val ?? true; }, ); }, ), ], ), actions: [ cancelAction(context), TextButton( onPressed: () { Navigator.pop(context); int copies = int.tryParse(copiesController.text) ?? 1; copies = copies.clamp(1, 20); handlePasteSpecialComponent( pastePosition, copies, keepConnections.value, ); }, child: const Text('Paste'), ), ], ); } 

// File: \lib\utils\component_factory.dart
import 'package:flutter/material.dart'; import 'package:grms_designer/niagara/controllers/canvas_interaction_controller.dart'; import 'package:grms_designer/niagara/controllers/flow_editor_state.dart'; import 'package:grms_designer/niagara/home/command.dart'; import 'package:grms_designer/niagara/home/manager.dart'; import 'package:grms_designer/niagara/models/component.dart'; import 'package:grms_designer/niagara/models/component_type.dart'; import 'package:grms_designer/niagara/models/port_type.dart'; import 'package:grms_designer/utils/canvas_utils.dart'; import 'package:grms_designer/utils/device_utils.dart'; import 'package:grms_designer/utils/logger.dart'; import 'package:grms_designer/utils/persistent_helper.dart'; import 'package:grms_designer/models/helvar_models/helvar_device.dart'; import 'package:grms_designer/models/helvar_models/input_device.dart'; void addNewComponent( ComponentType type, FlowManager flowManager, FlowEditorState editorState, PersistenceHelper persistenceHelper, CanvasInteractionController canvasController, Function() updateCanvasSize, { Offset? clickPosition, }) { String baseName = getNameForComponentType(type); int counter = 1; String newName = '$baseName $counter'; while (flowManager.components.any((comp) => comp.id == newName)) { counter++; newName = '$baseName $counter'; } Component newComponent = flowManager.createComponentByType( newName, type.type, ); Offset newPosition = clickPosition ?? getDefaultPosition(canvasController, editorState); Map<String, dynamic> state = { 'position': newPosition, 'key': editorState.getComponentKey(newComponent.id), 'positions': editorState.componentPositions, 'keys': editorState.componentKeys, }; final command = AddComponentCommand(flowManager, newComponent, state); editorState.commandHistory.execute(command); editorState.initializeComponentState( newComponent, position: newPosition, width: 160.0, ); persistenceHelper.saveAddComponent(newComponent); persistenceHelper.saveComponentPosition(newComponent.id, newPosition); persistenceHelper.saveComponentWidth(newComponent.id, 160.0); updateCanvasSize(); } void addNewDeviceComponent( Map<String, dynamic> deviceData, FlowManager flowManager, FlowEditorState editorState, PersistenceHelper persistenceHelper, CanvasInteractionController canvasController, Function() updateCanvasSize, { Offset? clickPosition, }) { HelvarDevice? device = deviceData["device"] as HelvarDevice?; if (device == null) { logError('Invalid device data'); return; } String deviceName = device.description.isEmpty ? "Device_${device.deviceId}" : device.description; int counter = 1; String componentId = deviceName; while (flowManager.components.any((comp) => comp.id == componentId)) { counter++; componentId = "${deviceName}_$counter"; } Component newComponent = createComponentFromDevice(componentId, device); Offset newPosition = clickPosition ?? getDefaultPosition(canvasController, editorState); Map<String, dynamic> state = { 'position': newPosition, 'key': editorState.getComponentKey(newComponent.id), 'positions': editorState.componentPositions, 'keys': editorState.componentKeys, }; final command = AddComponentCommand(flowManager, newComponent, state); editorState.commandHistory.execute(command); editorState.initializeComponentState( newComponent, position: newPosition, width: 180.0, ); persistenceHelper.saveAddComponent(newComponent); persistenceHelper.saveComponentPosition(newComponent.id, newPosition); persistenceHelper.saveComponentWidth(newComponent.id, 180.0); updateCanvasSize(); } void addNewButtonPointComponent( Map<String, dynamic> buttonPointData, FlowManager flowManager, FlowEditorState editorState, PersistenceHelper persistenceHelper, CanvasInteractionController canvasController, Function() updateCanvasSize, { Offset? clickPosition, Map<String, Map<String, dynamic>>? buttonPointMetadata, }) { final ButtonPoint buttonPoint = buttonPointData["buttonPoint"] as ButtonPoint; final HelvarDevice parentDevice = buttonPointData["parentDevice"] as HelvarDevice; String baseName = buttonPoint.name; String componentId = baseName; int counter = 1; while (flowManager.components.any((comp) => comp.id == componentId)) { componentId = "${baseName}_$counter"; counter++; } Component newComponent = flowManager.createComponentByType( componentId, ComponentType.BOOLEAN_POINT, ); bool initialValue = _getInitialButtonPointValue(buttonPoint); for (var property in newComponent.properties) { if (!property.isInput && property.type.type == PortType.BOOLEAN) { property.value = initialValue; break; } } if (buttonPointMetadata != null) { buttonPointMetadata[componentId] = { 'buttonPoint': buttonPoint, 'parentDevice': parentDevice, 'deviceAddress': parentDevice.address, 'buttonId': buttonPoint.buttonId, 'function': buttonPoint.function, }; } Offset newPosition = clickPosition ?? getDefaultPosition(canvasController, editorState); Map<String, dynamic> state = { 'position': newPosition, 'key': editorState.getComponentKey(newComponent.id), 'positions': editorState.componentPositions, 'keys': editorState.componentKeys, }; final command = AddComponentCommand(flowManager, newComponent, state); editorState.commandHistory.execute(command); editorState.initializeComponentState( newComponent, position: newPosition, width: 160.0, ); persistenceHelper.saveAddComponent(newComponent); persistenceHelper.saveComponentPosition(newComponent.id, newPosition); persistenceHelper.saveComponentWidth(newComponent.id, 160.0); updateCanvasSize(); } bool _getInitialButtonPointValue(ButtonPoint buttonPoint) { if (buttonPoint.function.contains('Status') || buttonPoint.name.toLowerCase().contains('missing')) { return false; } return false; } String generateUniqueComponentName(String baseName, FlowManager flowManager) { int counter = 1; String newName = '$baseName $counter'; while (flowManager.components.any((comp) => comp.id == newName)) { counter++; newName = '$baseName $counter'; } return newName; } void executeComponentAddition( Component newComponent, Offset position, FlowManager flowManager, FlowEditorState editorState, PersistenceHelper persistenceHelper, Function() updateCanvasSize, { double width = 160.0, }) { Map<String, dynamic> state = { 'position': position, 'key': editorState.getComponentKey(newComponent.id), 'positions': editorState.componentPositions, 'keys': editorState.componentKeys, }; final command = AddComponentCommand(flowManager, newComponent, state); editorState.commandHistory.execute(command); editorState.initializeComponentState( newComponent, position: position, width: width, ); persistenceHelper.saveAddComponent(newComponent); persistenceHelper.saveComponentPosition(newComponent.id, position); persistenceHelper.saveComponentWidth(newComponent.id, width); updateCanvasSize(); } 

// File: \lib\utils\date_utils.dart
String formatDateTime(DateTime dateTime) { final now = DateTime.now(); final difference = now.difference(dateTime); if (difference.inMinutes < 1) { return 'Just now'; } else if (difference.inHours < 1) { return '${difference.inMinutes}m ago'; } else if (difference.inDays < 1) { return '${difference.inHours}h ago'; } else { return '${difference.inDays}d ago'; } } String getLastUpdateTime() { return DateTime.now().toString().substring(11, 19); } 

// File: \lib\utils\device_icons.dart
import 'package:flutter/material.dart'; import '../models/helvar_models/helvar_device.dart'; String getDeviceIconAsset(HelvarDevice? device) { if (device == null) return 'assets/icons/device.png'; String hexId = device.hexId.startsWith('0x') ? device.hexId.substring(2) : device.hexId; hexId = hexId.toLowerCase(); if (device.isMultisensor || device.helvarType == 'input' && device.props.toLowerCase().contains('sensor')) { if (hexId == '312502') return 'assets/icons/312.png'; if (hexId == '315602') return 'assets/icons/315.png'; if (hexId == '5749701') return 'assets/icons/IR-Quattro-HD.png'; if (hexId == '5748001') return 'assets/icons/HF-360.png'; if (hexId == '5745901') return 'assets/icons/Dual-HF.png'; if (hexId == '6624601' || hexId == '6626001') { return 'assets/icons/IS-3360-MX.png'; } return 'assets/icons/sensor.png'; } if (device.isButtonDevice || device.helvarType == 'input') { if (hexId == '100802') return 'assets/icons/100.png'; if (hexId == '110702') return 'assets/icons/110.png'; if (hexId == '111402') return 'assets/icons/111.png'; if (hexId == '121302') return 'assets/icons/121.png'; if (hexId == '122002') return 'assets/icons/122.png'; if (hexId == '124402') return 'assets/icons/124.png'; if (hexId == '125102') return 'assets/icons/125.png'; if (hexId == '126802') return 'assets/icons/126.png'; if (hexId == '131202' || hexId.contains('131')) { return 'assets/icons/131.png'; } if (hexId == '134302' || hexId.contains('134')) { return 'assets/icons/134.png'; } if (hexId == '135002' || hexId.contains('135')) { return 'assets/icons/135.png'; } if (hexId == '136702' || hexId.contains('136')) { return 'assets/icons/136.png'; } if (hexId == '137402' || hexId.contains('137')) { return 'assets/icons/137.png'; } if (hexId == '170102') return 'assets/icons/170.png'; if (hexId.contains('142')) return 'assets/icons/142WD2.png'; if (hexId.contains('144')) return 'assets/icons/144WD2.png'; if (hexId.contains('146')) return 'assets/icons/146WD2.png'; if (hexId.contains('148')) return 'assets/icons/148WD2.png'; if (hexId.contains('160')) return 'assets/icons/160.PNG'; if (hexId.contains('935')) return 'assets/icons/935.png'; if (hexId.contains('939')) return 'assets/icons/939.png'; if (hexId.contains('434')) return 'assets/icons/EnOcean.png'; return 'assets/icons/device.png'; } if (device.helvarType == 'output') { if (hexId.contains('55') || hexId == '601' || hexId == '801') { return 'assets/icons/LEDunit.png'; } if (hexId.contains('492') || hexId.contains('493') || hexId.contains('42') || hexId.contains('43') || hexId == '1') { return 'assets/icons/ballast.png'; } if (hexId.contains('416') || hexId.contains('425') || hexId.contains('452') || hexId.contains('454') || hexId.contains('455') || hexId.contains('458') || hexId.contains('804') || hexId == '401') { return 'assets/icons/dimmer.png'; } if (hexId.contains('490')) return 'assets/icons/490.png'; if (hexId.contains('491') || hexId.contains('492') || hexId.contains('493') || hexId.contains('494') || hexId.contains('498') || hexId.contains('499') || hexId == '701' || hexId == '1793') { return 'assets/icons/491.png'; } if (hexId.contains('472') || hexId.contains('474') || hexId.contains('478') || hexId == '501') { return 'assets/icons/472.png'; } if (hexId.contains('208') || hexId.contains('108')) { return 'assets/icons/dmx.png'; } } if (device.helvarType == 'emergency' || device.emergency) { return 'assets/icons/outputemergency.png'; } if (hexId.contains('444') || hexId.contains('445') || hexId.contains('441')) { return 'assets/icons/444.png'; } if (hexId.contains('942')) { return 'assets/icons/942.png'; } return 'assets/icons/device.png'; } Widget getDeviceIconWidget(HelvarDevice? device, {IconData? iconData, double size = 24.0}) { if (iconData != null) { return Icon(iconData, size: size); } return Image.asset( getDeviceIconAsset(device), width: size, height: size, ); } 

// File: \lib\utils\device_utils.dart
import 'package:grms_designer/models/helvar_models/helvar_device.dart'; import 'package:grms_designer/niagara/models/component.dart'; import 'package:grms_designer/niagara/models/component_type.dart'; import 'package:grms_designer/niagara/models/helvar_device_component.dart'; import 'package:flutter/material.dart'; import 'package:grms_designer/niagara/models/port_type.dart'; import 'package:grms_designer/niagara/models/ramp_component.dart'; import 'package:grms_designer/niagara/models/rectangle.dart'; import 'package:grms_designer/utils/logger.dart'; import '../models/helvar_models/input_device.dart'; List<ButtonPoint> generateStandardButtonPoints(String deviceName) { final points = <ButtonPoint>[]; points.add( ButtonPoint(name: '${deviceName}_Missing', function: 'Status', buttonId: 0), ); for (int i = 1; i <= 7; i++) { points.add( ButtonPoint( name: '${deviceName}_Button$i', function: 'Button', buttonId: i, ), ); } for (int i = 1; i <= 7; i++) { points.add( ButtonPoint( name: '${deviceName}_IR$i', function: 'IR Receiver', buttonId: i + 100, ), ); } return points; } String handleRecallScene(String sceneParams, {bool logInfoOutput = false}) { if (sceneParams.isNotEmpty) { List<String> temp = sceneParams.split(','); String timestamp = DateTime.now().toString(); String s = "Success ($timestamp) Recalled Scene: ${temp.length > 1 ? temp[1] : temp[0]}"; if (logInfoOutput) { logInfo(s); } return s; } else { logWarning("Please pass a valid scene number!"); return "Please pass a valid scene number!"; } } Widget buildTypeIndicator(PortType type) { IconData icon; Color color; switch (type.type) { case PortType.BOOLEAN: icon = Icons.toggle_on_outlined; color = Colors.indigo; break; case PortType.NUMERIC: icon = Icons.numbers; color = Colors.green; break; case PortType.STRING: icon = Icons.text_fields; color = Colors.orange; break; case PortType.ANY: icon = Icons.all_inclusive; color = Colors.purple; break; default: icon = Icons.help_outline; color = Colors.grey; } return Icon(icon, color: color, size: 12); } String getNameForComponentType(ComponentType type) { if (type.type == RectangleComponent.RECTANGLE) { return 'Rectangle'; } if (type.type == RampComponent.RAMP) { return 'Ramp'; } switch (type.type) { case ComponentType.AND_GATE: return 'AND Gate'; case ComponentType.OR_GATE: return 'OR Gate'; case ComponentType.XOR_GATE: return 'XOR Gate'; case ComponentType.NOT_GATE: return 'NOT Gate'; case ComponentType.ADD: return 'Add'; case ComponentType.SUBTRACT: return 'Subtract'; case ComponentType.MULTIPLY: return 'Multiply'; case ComponentType.DIVIDE: return 'Divide'; case ComponentType.MAX: return 'Maximum'; case ComponentType.MIN: return 'Minimum'; case ComponentType.POWER: return 'Power'; case ComponentType.ABS: return 'Absolute Value'; case ComponentType.IS_GREATER_THAN: return 'Greater Than'; case ComponentType.IS_LESS_THAN: return 'Less Than'; case ComponentType.IS_EQUAL: return 'Equals'; case ComponentType.BOOLEAN_WRITABLE: return 'Boolean Writable'; case ComponentType.NUMERIC_WRITABLE: return 'Numeric Writable'; case ComponentType.STRING_WRITABLE: return 'String Writable'; case ComponentType.BOOLEAN_POINT: return 'Boolean Point'; case ComponentType.NUMERIC_POINT: return 'Numeric Point'; case ComponentType.STRING_POINT: return 'String Point'; default: return 'Unknown Component'; } } List<ComponentType> getCompatibleTypes(ComponentType currentType) { if (currentType.type == RectangleComponent.RECTANGLE) { return [const ComponentType(RectangleComponent.RECTANGLE)]; } if (currentType.type == RampComponent.RAMP) { return [const ComponentType(RampComponent.RAMP)]; } List<String> compatibleTypeStrings = []; if (currentType.type == ComponentType.AND_GATE || currentType.type == ComponentType.OR_GATE || currentType.type == ComponentType.XOR_GATE) { compatibleTypeStrings = [ ComponentType.AND_GATE, ComponentType.OR_GATE, ComponentType.XOR_GATE, ]; } else if (currentType.type == ComponentType.NOT_GATE) { compatibleTypeStrings = [ComponentType.NOT_GATE]; } else if (currentType.type == ComponentType.ADD || currentType.type == ComponentType.SUBTRACT || currentType.type == ComponentType.MULTIPLY || currentType.type == ComponentType.DIVIDE || currentType.type == ComponentType.MAX || currentType.type == ComponentType.MIN || currentType.type == ComponentType.POWER) { compatibleTypeStrings = [ ComponentType.ADD, ComponentType.SUBTRACT, ComponentType.MULTIPLY, ComponentType.DIVIDE, ComponentType.MAX, ComponentType.MIN, ComponentType.POWER, ]; } else if (currentType.type == ComponentType.IS_GREATER_THAN || currentType.type == ComponentType.IS_LESS_THAN) { compatibleTypeStrings = [ ComponentType.IS_GREATER_THAN, ComponentType.IS_LESS_THAN, ]; } else if (currentType.type == ComponentType.ABS) { compatibleTypeStrings = [ComponentType.ABS]; } else if (currentType.type == ComponentType.IS_EQUAL) { compatibleTypeStrings = [ComponentType.IS_EQUAL]; } else if (currentType.type == ComponentType.BOOLEAN_WRITABLE || currentType.type == ComponentType.BOOLEAN_POINT) { compatibleTypeStrings = [ ComponentType.BOOLEAN_WRITABLE, ComponentType.BOOLEAN_POINT, ]; } else if (currentType.type == ComponentType.NUMERIC_WRITABLE || currentType.type == ComponentType.NUMERIC_POINT) { compatibleTypeStrings = [ ComponentType.NUMERIC_WRITABLE, ComponentType.NUMERIC_POINT, ]; } else if (currentType.type == ComponentType.STRING_WRITABLE || currentType.type == ComponentType.STRING_POINT) { compatibleTypeStrings = [ ComponentType.STRING_WRITABLE, ComponentType.STRING_POINT, ]; } return compatibleTypeStrings .map((typeString) => ComponentType(typeString)) .toList(); } Component createComponentFromDevice(String id, HelvarDevice device) { return HelvarDeviceComponent( id: id, deviceId: device.deviceId, deviceAddress: device.address, deviceType: device.helvarType, description: device.description.isEmpty ? "Device_${device.deviceId}" : device.description, type: ComponentType(getHelvarComponentType(device.helvarType)), ); } String getHelvarComponentType(String helvarType) { switch (helvarType) { case 'output': return ComponentType.HELVAR_OUTPUT; case 'input': return ComponentType.HELVAR_INPUT; case 'emergency': return ComponentType.HELVAR_EMERGENCY; default: return ComponentType.HELVAR_DEVICE; } } 

// File: \lib\utils\dialog_utils.dart
import 'package:flutter/material.dart'; TextButton cancelAction(BuildContext context) { return TextButton( onPressed: () => Navigator.of(context).pop(false), child: const Text('Cancel'), ); } TextButton closeAction(BuildContext context) { return TextButton( onPressed: () => Navigator.of(context).pop(false), child: const Text('Close'), ); } TextButton confirmAction(BuildContext context) { return TextButton( onPressed: () => Navigator.of(context).pop(true), child: const Text('OK'), ); } TextButton confirmActionWithText(BuildContext context, String text) { return TextButton( onPressed: () => Navigator.of(context).pop(text), child: const Text('OK'), ); } 

// File: \lib\utils\file_dialog_helper.dart
import 'package:file_picker/file_picker.dart'; class FileDialogHelper { static Future<String?> pickJsonFileToOpen() async { FilePickerResult? result = await FilePicker.platform.pickFiles( type: FileType.custom, allowedExtensions: ['json'], dialogTitle: 'Select HelvarNet workgroups file to import', ); if (result != null && result.files.single.path != null) { return result.files.single.path; } return null; } static Future<String?> pickJsonFileToSave(String fileName) async { String? outputFile = await FilePicker.platform.saveFile( dialogTitle: 'Save HelvarNet configuration', fileName: fileName, type: FileType.custom, allowedExtensions: ['json'], ); return outputFile; } static Future<String?> pickTextFileToSave(String fileName) async { String? outputFile = await FilePicker.platform.saveFile( dialogTitle: 'Save Logs', fileName: fileName, type: FileType.custom, allowedExtensions: ['txt'], ); return outputFile; } static Future<String?> pickFileToOpen({ List<String> allowedExtensions = const ['json'], String dialogTitle = 'Select file to import', FileType type = FileType.custom, }) async { FilePickerResult? result = await FilePicker.platform.pickFiles( type: type, allowedExtensions: type == FileType.custom ? allowedExtensions : null, dialogTitle: dialogTitle, ); if (result != null && result.files.single.path != null) { return result.files.single.path; } return null; } } 

// File: \lib\utils\general_ui.dart
import 'package:flutter/material.dart'; import '../comm/models/command_models.dart'; import '../niagara/models/component.dart'; import '../niagara/models/component_type.dart'; import '../niagara/models/ramp_component.dart'; import '../niagara/models/rectangle.dart'; const double rowHeight = 22.0; String getComponentSymbol(Component component) { if (component.type.type == RectangleComponent.RECTANGLE) { return 'R'; } if (component.type.type == RampComponent.RAMP) { return '⏱️'; } switch (component.type.type) { case ComponentType.AND_GATE: return 'AND'; case ComponentType.OR_GATE: return 'OR'; case ComponentType.XOR_GATE: return 'XOR'; case ComponentType.NOT_GATE: return 'NOT'; case ComponentType.ADD: return '+'; case ComponentType.SUBTRACT: return '-'; case ComponentType.MULTIPLY: return '×'; case ComponentType.DIVIDE: return '÷'; case ComponentType.MAX: return 'MAX'; case ComponentType.MIN: return 'MIN'; case ComponentType.POWER: return 'POW'; case ComponentType.ABS: return '|x|'; case ComponentType.IS_GREATER_THAN: return '>'; case ComponentType.IS_LESS_THAN: return '<'; case ComponentType.IS_EQUAL: return '='; case ComponentType.BOOLEAN_WRITABLE: return 'BW'; case ComponentType.NUMERIC_WRITABLE: return 'NW'; case ComponentType.STRING_WRITABLE: return 'SW'; case ComponentType.BOOLEAN_POINT: return 'BP'; case ComponentType.NUMERIC_POINT: return 'NP'; case ComponentType.STRING_POINT: return 'SP'; default: return '?'; } } Color getComponentColor(Component component) { if (component.type.type == RectangleComponent.RECTANGLE) { return Colors.lime[100]!; } if (component.type.type == RampComponent.RAMP) { return Colors.amber[100]!; } if (component.type.isLogicGate) { return Colors.lightBlue[100]!; } else if (component.type.isMathOperation) { return Colors.lightGreen[100]!; } else if (component.type.type == ComponentType.BOOLEAN_WRITABLE || component.type.type == ComponentType.BOOLEAN_POINT) { return Colors.indigo[100]!; } else if (component.type.type == ComponentType.NUMERIC_WRITABLE || component.type.type == ComponentType.NUMERIC_POINT) { return Colors.teal[100]!; } else if (component.type.type == ComponentType.STRING_WRITABLE || component.type.type == ComponentType.STRING_POINT) { return Colors.orange[100]!; } else { return Colors.grey[100]!; } } Color getComponentTextColor(Component component) { if (component.type.type == RectangleComponent.RECTANGLE) { return Colors.green[800]!; } if (component.type.type == RampComponent.RAMP) { return Colors.amber[800]!; } if (component.type.isLogicGate) { return Colors.blue[800]!; } else if (component.type.isMathOperation) { return Colors.green[800]!; } else if (component.type.type == ComponentType.BOOLEAN_WRITABLE || component.type.type == ComponentType.BOOLEAN_POINT) { return Colors.indigo[800]!; } else if (component.type.type == ComponentType.NUMERIC_WRITABLE || component.type.type == ComponentType.NUMERIC_POINT) { return Colors.teal[800]!; } else if (component.type.type == ComponentType.STRING_WRITABLE || component.type.type == ComponentType.STRING_POINT) { return Colors.orange[800]!; } else { return Colors.grey[800]!; } } IconData getIconForComponentType(ComponentType type) { if (type.type == RectangleComponent.RECTANGLE) { return Icons.crop_square; } if (type.type == RampComponent.RAMP) { return Icons.show_chart; } switch (type.type) { case ComponentType.AND_GATE: return Icons.call_merge; case ComponentType.OR_GATE: return Icons.call_split; case ComponentType.XOR_GATE: return Icons.shuffle; case ComponentType.NOT_GATE: return Icons.block; case ComponentType.ADD: return Icons.add; case ComponentType.SUBTRACT: return Icons.remove; case ComponentType.MULTIPLY: return Icons.close; case ComponentType.DIVIDE: return Icons.expand; case ComponentType.MAX: return Icons.arrow_upward; case ComponentType.MIN: return Icons.arrow_downward; case ComponentType.POWER: return Icons.upload; case ComponentType.ABS: return Icons.straighten; case ComponentType.IS_GREATER_THAN: return Icons.navigate_next; case ComponentType.IS_LESS_THAN: return Icons.navigate_before; case ComponentType.IS_EQUAL: return Icons.drag_handle; case ComponentType.BOOLEAN_WRITABLE: return Icons.toggle_on; case ComponentType.NUMERIC_WRITABLE: return Icons.numbers; case ComponentType.STRING_WRITABLE: return Icons.text_fields; case ComponentType.BOOLEAN_POINT: return Icons.toggle_off; case ComponentType.NUMERIC_POINT: return Icons.format_list_numbered; case ComponentType.STRING_POINT: return Icons.text_snippet; default: return Icons.help_outline; } } void showSnackBarMsg(BuildContext context, String message) { ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(message))); } Widget buildInfoRow(String label, String value, {double? width}) { return Padding( padding: const EdgeInsets.symmetric(vertical: 4.0), child: Row( crossAxisAlignment: CrossAxisAlignment.start, children: [ SizedBox( width: width ?? 220, child: Text( '$label:', style: const TextStyle(fontWeight: FontWeight.w500), ), ), Expanded(child: Text(value)), ], ), ); } Color getStatusColor(CommandStatus status) { switch (status) { case CommandStatus.queued: return Colors.grey; case CommandStatus.executing: return Colors.blue; case CommandStatus.completed: return Colors.green; case CommandStatus.failed: return Colors.red; case CommandStatus.cancelled: return Colors.orange; case CommandStatus.timedOut: return Colors.black38; } } 

// File: \lib\utils\helpers.dart
import '../models/helvar_models/helvar_device.dart'; import '../models/helvar_models/workgroup.dart'; import '../niagara/models/component.dart'; import '../niagara/models/component_type.dart'; import '../niagara/models/logic_components.dart'; import '../niagara/models/math_components.dart'; import '../niagara/models/point_components.dart'; import '../niagara/models/port.dart'; import '../niagara/models/port_type.dart'; HelvarDevice? findDevice( int deviceId, List<Workgroup> workgroups, String deviceAddress) { for (final workgroup in workgroups) { for (final router in workgroup.routers) { for (final device in router.devices) { if (device.deviceId == deviceId && device.address == deviceAddress) { return device; } } } } return null; } Component deepCopyComponent(Component original, String newId) { Component copy; if (original is PointComponent) { copy = PointComponent( id: newId, type: ComponentType(original.type.type), ); } else if (original is LogicComponent) { copy = LogicComponent( id: newId, type: ComponentType(original.type.type), ); } else if (original is MathComponent) { copy = MathComponent( id: newId, type: ComponentType(original.type.type), ); } else { copy = PointComponent( id: newId, type: ComponentType(original.type.type), ); } copy.properties.clear(); copy.actions.clear(); copy.topics.clear(); for (var prop in original.properties) { final propCopy = Property( name: prop.name, index: prop.index, isInput: prop.isInput, type: PortType(prop.type.type), value: prop.value, ); copy.properties.add(propCopy); } for (var action in original.actions) { final actionCopy = ActionSlot( name: action.name, index: action.index, parameterType: action.parameterType != null ? PortType(action.parameterType!.type) : null, returnType: action.returnType != null ? PortType(action.returnType!.type) : null, parameter: action.parameter, returnValue: action.returnValue, ); copy.actions.add(actionCopy); } for (var topic in original.topics) { final topicCopy = Topic( name: topic.name, index: topic.index, eventType: PortType(topic.eventType.type), ); if (topic.lastEvent != null) { topicCopy.fire(topic.lastEvent); } copy.topics.add(topicCopy); } return copy; } 

// File: \lib\utils\logger.dart
import '../services/log_service.dart'; LogService? _logService; void initLogger(LogService service) { _logService = service; } void logVerbose(String message, {String? tag, StackTrace? stackTrace}) { _logService?.verbose(message, tag: tag, stackTrace: stackTrace); } void logDebug(String message, {String? tag, StackTrace? stackTrace}) { _logService?.debug(message, tag: tag, stackTrace: stackTrace); } void logInfo(String message, {String? tag, StackTrace? stackTrace}) { _logService?.info(message, tag: tag, stackTrace: stackTrace); } void logWarning(String message, {String? tag, StackTrace? stackTrace}) { _logService?.warning(message, tag: tag, stackTrace: stackTrace); } void logError(String message, {String? tag, StackTrace? stackTrace}) { _logService?.error(message, tag: tag, stackTrace: stackTrace); } 

// File: \lib\utils\network_utils.dart
import 'dart:io'; import 'package:flutter/material.dart'; import 'package:grms_designer/utils/general_ui.dart'; import '../screens/dialogs/network_interface_dialog.dart'; import 'logger.dart'; Future<List<NetworkInterfaceDetails>> getNetworkInterfaces() async { final result = await Process.run('ipconfig', ['/all']); final output = result.stdout.toString(); final interfaces = parseIpConfig(output); final filteredInterfaces = interfaces.where((interface) { return interface.ipv4 != null && interface.subnetMask != null; }).toList(); if (filteredInterfaces.isEmpty) { logWarning('No valid interfaces found.'); logVerbose('Raw ipconfig output:\n$output'); return []; } return filteredInterfaces; } Future<NetworkInterfaceDetails?> selectNetworkInterface( BuildContext context) async { try { List<NetworkInterfaceDetails> interfaces = await getNetworkInterfaces(); if (interfaces.isEmpty) { showSnackBarMsg(context, 'No network interfaces found'); return null; } final result = await showDialog<NetworkInterfaceDetails>( context: context, builder: (BuildContext context) { return NetworkInterfaceDialog(interfaces: interfaces); }, ); return result; } catch (e) { logError('Error selecting network interface: $e'); showSnackBarMsg(context, 'Error selecting network interface.'); return null; } } List<NetworkInterfaceDetails> parseIpConfig(String output) { final interfaces = <NetworkInterfaceDetails>[]; final lines = output.split('\n'); NetworkInterfaceDetails? currentInterface; for (final line in lines) { final trimmedLine = line.trim(); if (trimmedLine.contains('adapter') && trimmedLine.endsWith(':')) { if (currentInterface != null && (currentInterface.ipv4 != null || currentInterface.subnetMask != null)) { interfaces.add(currentInterface); } final name = trimmedLine.replaceAll('adapter', '').replaceAll(':', '').trim(); currentInterface = NetworkInterfaceDetails(name: name); } else if (currentInterface != null) { if (trimmedLine.startsWith('IPv4 Address') || trimmedLine.startsWith('IPv4-adres')) { currentInterface.ipv4 = _cleanValue(_extractAfterColon(trimmedLine)); } else if (trimmedLine.startsWith('Subnet Mask') || trimmedLine.startsWith('Subnetmasker')) { currentInterface.subnetMask = _cleanValue(_extractAfterColon(trimmedLine)); } else if (trimmedLine.startsWith('Default Gateway') || trimmedLine.startsWith('Standaardgateway')) { currentInterface.gateway = _cleanValue(_extractAfterColon(trimmedLine)); } } } if (currentInterface != null && (currentInterface.ipv4 != null || currentInterface.subnetMask != null)) { interfaces.add(currentInterface); } return interfaces; } String calculateBroadcastAddress(String ipAddress, String subnetMask) { List<String> ipParts = ipAddress.split('.'); List<String> maskParts = subnetMask.split('.'); List<String> broadcastParts = []; for (int i = 0; i < 4; i++) { int ip = int.parse(ipParts[i]); int mask = int.parse(maskParts[i]); int broadcast = ip | (~mask & 0xFF); broadcastParts.add(broadcast.toString()); } return broadcastParts.join('.'); } String _extractAfterColon(String line) { final parts = line.split(':'); if (parts.length < 2) return ''; return parts.sublist(1).join(':').trim(); } String _cleanValue(String value) { return value.replaceAll(RegExp(r'\(.*\)'), '').trim(); } 

// File: \lib\utils\persistent_helper.dart
import 'package:flutter/material.dart'; import '../models/flowsheet.dart'; import '../niagara/home/manager.dart'; import '../niagara/models/component.dart'; import '../niagara/models/connection.dart'; import '../services/flowsheet_storage_service.dart'; class PersistenceHelper { final Flowsheet flowsheet; final FlowsheetStorageService storageService; final FlowManager flowManager; final Map<String, Offset> componentPositions; final Map<String, double> componentWidths; final Function() getMountedStatus; final Function(Flowsheet) onFlowsheetUpdate; PersistenceHelper({ required this.flowsheet, required this.storageService, required this.flowManager, required this.componentPositions, required this.componentWidths, required this.getMountedStatus, required this.onFlowsheetUpdate, }); Future<void> saveFullState() async { if (!getMountedStatus()) return; try { final updatedFlowsheet = flowsheet.copy(); updatedFlowsheet.components = flowManager.components; final List<Connection> connections = []; for (final component in flowManager.components) { for (final entry in component.inputConnections.entries) { connections.add(Connection( fromComponentId: entry.value.componentId, fromPortIndex: entry.value.portIndex, toComponentId: component.id, toPortIndex: entry.key, )); } } updatedFlowsheet.connections = connections; for (final entry in componentPositions.entries) { updatedFlowsheet.updateComponentPosition(entry.key, entry.value); } for (final entry in componentWidths.entries) { updatedFlowsheet.updateComponentWidth(entry.key, entry.value); } if (getMountedStatus()) { await storageService.saveFlowsheet(updatedFlowsheet); onFlowsheetUpdate(updatedFlowsheet); } } catch (e) { print('Error saving flowsheet state: $e'); } } Future<void> _safeOperation(Future<void> Function() operation) async { if (!getMountedStatus()) return; try { await operation(); } catch (e) { print('Error during persistence operation: $e'); } } Future<void> saveComponentPosition( String componentId, Offset position) async { await _safeOperation(() async { if (!getMountedStatus()) return; flowsheet.updateComponentPosition(componentId, position); flowsheet.modifiedAt = DateTime.now(); await storageService.saveFlowsheet(flowsheet); }); } Future<void> saveComponentWidth(String componentId, double width) async { await _safeOperation(() async { if (!getMountedStatus()) return; flowsheet.updateComponentWidth(componentId, width); flowsheet.modifiedAt = DateTime.now(); await storageService.saveFlowsheet(flowsheet); }); } Future<void> saveAddComponent(Component component) async { await _safeOperation(() async { if (!getMountedStatus()) return; flowsheet.addComponent(component); await storageService.saveFlowsheet(flowsheet); }); } Future<void> saveUpdateComponent( String componentId, Component component) async { await _safeOperation(() async { if (!getMountedStatus()) return; flowsheet.updateComponent(componentId, component); await storageService.saveFlowsheet(flowsheet); }); } Future<void> saveRemoveComponent(String componentId) async { await _safeOperation(() async { if (!getMountedStatus()) return; flowsheet.removeComponent(componentId); await storageService.saveFlowsheet(flowsheet); }); } Future<void> saveAddConnection(Connection connection) async { await _safeOperation(() async { if (!getMountedStatus()) return; flowsheet.addConnection(connection); await storageService.saveFlowsheet(flowsheet); }); } Future<void> saveRemoveConnection(String fromComponentId, int fromPortIndex, String toComponentId, int toPortIndex) async { await _safeOperation(() async { if (!getMountedStatus()) return; flowsheet.removeConnection( fromComponentId, fromPortIndex, toComponentId, toPortIndex); await storageService.saveFlowsheet(flowsheet); }); } Future<void> savePortValue( String componentId, int slotIndex, dynamic value) async { await _safeOperation(() async { if (!getMountedStatus()) return; flowsheet.updatePortValue(componentId, slotIndex, value); await storageService.saveFlowsheet(flowsheet); }); } } 

// File: \lib\utils\scene_utils.dart
import 'package:flutter/material.dart'; String getSceneDisplayName(int scene) { switch (scene) { case 128: return 'Scene $scene (Off)'; case 129: return 'Scene $scene (Min Level)'; case 130: return 'Scene $scene (Max Level)'; case 137: return 'Scene $scene (0%)'; case 138: return 'Scene $scene (1%)'; case 237: return 'Scene $scene (100%)'; default: if (scene >= 137 && scene <= 237) { final percentage = scene - 137; return 'Scene $scene ($percentage%)'; } return 'Scene $scene'; } } Color getSceneChipColor(int scene) { switch (scene) { case 128:  return Colors.red.withValues(alpha: 0.1 * 255); case 129:  return Colors.orange.withValues(alpha: 0.1 * 255); case 130:  return Colors.green.withValues(alpha: 0.1 * 255); default: if (scene >= 137 && scene <= 237) { return Colors.purple.withValues(alpha: 0.1 * 255); } return Colors.blue.withValues(alpha: 0.1 * 255); } } 

// File: \lib\utils\treeview_utils.dart
import 'package:flutter/material.dart'; import 'package:grms_designer/models/helvar_models/input_device.dart'; import 'package:grms_designer/models/helvar_models/output_point.dart'; Color getOutputPointValueColor(OutputPoint outputPoint) { if (outputPoint.pointType == 'boolean') { final value = outputPoint.value as bool? ?? false; return value ? Colors.green : Colors.red; } else { final value = (outputPoint.value as num?)?.toDouble() ?? 0.0; if (value == 0) return Colors.grey; return Colors.blue; } } String formatOutputPointValue(OutputPoint outputPoint) { if (outputPoint.pointType == 'boolean') { final value = outputPoint.value as bool? ?? false; return value ? 'true' : 'false'; } else { final value = (outputPoint.value as num?)?.toDouble() ?? 0.0; if (outputPoint.pointId == 5) { return '${value.toStringAsFixed(0)}%'; } else if (outputPoint.pointId == 6) { return '${value.toStringAsFixed(1)}W'; } return value.toStringAsFixed(1); } } IconData getButtonPointIcon(ButtonPoint buttonPoint) { if (buttonPoint.function.contains('Status') || buttonPoint.name.contains('Missing')) { return Icons.info_outline; } else if (buttonPoint.function.contains('IR')) { return Icons.settings_remote; } else { return Icons.touch_app; } } String getButtonPointDisplayName(ButtonPoint buttonPoint) { return buttonPoint.name.split('_').last; } IconData getOutputPointIcon(OutputPoint outputPoint) { switch (outputPoint.pointId) { case 1: return Icons.device_hub; case 2: return Icons.lightbulb_outline; case 3: return Icons.help_outline; case 4: return Icons.warning; case 5: return Icons.tune; case 6: return Icons.power; default: return Icons.circle; } } 

// File: \lib\widgets\app_tree_view.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:flutter_simple_treeview/flutter_simple_treeview.dart'; import 'package:grms_designer/models/helvar_models/helvar_device.dart'; import 'package:grms_designer/models/helvar_models/output_device.dart'; import 'package:grms_designer/models/helvar_models/output_point.dart'; import 'package:grms_designer/utils/treeview_utils.dart'; import 'package:grms_designer/widgets/draggable_function_node.dart'; import 'package:grms_designer/widgets/logics_treenode.dart'; import 'package:grms_designer/widgets/project_treenode.dart'; import '../models/helvar_models/input_device.dart'; import '../models/helvar_models/helvar_group.dart'; import '../models/helvar_models/helvar_router.dart'; import '../models/helvar_models/workgroup.dart'; import '../models/flowsheet.dart'; import '../providers/tree_expansion_provider.dart'; import '../screens/actions.dart'; import '../screens/dialogs/device_context_menu.dart'; class AppTreeView extends ConsumerStatefulWidget { final List<Flowsheet> wiresheets; final List<Workgroup> workgroups; final bool showingProject; final bool openSettings; final bool showingWorkgroup; final bool openWorkGroups; final bool openWiresheet; final bool showingImages; final bool showingGroups; final String? currentFileDirectory; final String? selectedWiresheetId; final Workgroup? selectedWorkgroup; final HelvarGroup? selectedGroup; final HelvarRouter? selectedRouter; final HelvarDevice? selectedDevice; final int? selectedSubnetNumber; final bool showingSubnetDetail; final bool showingDeviceDetail; final bool showingPointsDetail; final bool showingOutputPointsDetail; final bool showingPointDetail; final bool showingOutputPointDetail; final ButtonPoint? selectedPoint; final OutputPoint? selectedOutputPoint; final Function( String, { Workgroup? workgroup, HelvarGroup? group, HelvarRouter? router, String? wiresheetId, int? subnetNumber, List<HelvarDevice>? subnetDevices, HelvarDevice? device, OutputPoint? outputPoint, ButtonPoint? point, }) setActiveNode; const AppTreeView({ super.key, this.selectedSubnetNumber, required this.showingSubnetDetail, required this.showingOutputPointsDetail, required this.showingOutputPointDetail, required this.showingDeviceDetail, required this.showingPointsDetail, required this.showingPointDetail, required this.selectedDevice, required this.selectedPoint, required this.selectedOutputPoint, required this.wiresheets, required this.workgroups, required this.showingProject, required this.openSettings, required this.openWorkGroups, required this.showingWorkgroup, required this.openWiresheet, required this.showingImages, required this.showingGroups, this.selectedRouter, required this.currentFileDirectory, required this.selectedWiresheetId, required this.selectedWorkgroup, required this.selectedGroup, required this.setActiveNode, }); @override AppTreeViewState createState() => AppTreeViewState(); } class AppTreeViewState extends ConsumerState<AppTreeView> { late TreeController _treeController; @override void initState() { super.initState(); _treeController = TreeController(allNodesExpanded: false); WidgetsBinding.instance.addPostFrameCallback((_) { ref.read(treeExpansionProvider.notifier).resetExpansionState(); Future.delayed(const Duration(milliseconds: 500), () { if (mounted) { ref.read(treeExpansionProvider.notifier).clearNewlyAddedNodes(); } }); }); } @override void dispose() { super.dispose(); } @override Widget build(BuildContext context) { ref.watch(treeExpansionProvider); return SingleChildScrollView( child: Column( children: [ TreeView( treeController: _treeController, nodes: [ buildProjectNode(widget, context, ref), TreeNode( content: GestureDetector( onDoubleTap: () { widget.setActiveNode('workgroups'); }, child: Row( children: [ const Icon(Icons.group_work), Padding( padding: const EdgeInsets.all(8.0), child: Text( 'Workgroups', style: TextStyle( fontWeight: widget.openWorkGroups ? FontWeight.bold : FontWeight.normal, color: widget.openWorkGroups ? Colors.blue : null, ), ), ), ], ), ), children: widget.workgroups .map( (workgroup) => TreeNode( content: GestureDetector( onDoubleTap: () { widget.setActiveNode( 'workgroupDetail', workgroup: workgroup, ); }, child: Row( children: [ const Icon(Icons.lan), Padding( padding: const EdgeInsets.all(8.0), child: Text( workgroup.description, style: TextStyle( fontWeight: widget.selectedWorkgroup == workgroup && widget.showingWorkgroup ? FontWeight.bold : FontWeight.normal, color: widget.selectedWorkgroup == workgroup && widget.showingWorkgroup ? Colors.blue : null, ), ), ), ], ), ), children: [ TreeNode( content: GestureDetector( onDoubleTap: () { widget.setActiveNode( 'groups', workgroup: workgroup, ); }, child: Row( children: [ const Icon( Icons.group_work, color: Colors.blue, ), Padding( padding: const EdgeInsets.all(8.0), child: Text( "Groups", style: TextStyle( fontWeight: widget.selectedWorkgroup == workgroup && widget.showingGroups ? FontWeight.bold : FontWeight.normal, color: widget.selectedWorkgroup == workgroup && widget.showingGroups ? Colors.blue : null, ), ), ), ], ), ), children: workgroup.groups .map( (group) => TreeNode( content: GestureDetector( onDoubleTap: () { widget.setActiveNode( 'groupDetail', workgroup: workgroup, group: group, ); }, onSecondaryTap: () { showGroupContextMenu( context, group, workgroup, ); }, child: Row( children: [ const Icon(Icons.group), Padding( padding: const EdgeInsets.all(8.0), child: Text( group.description.isEmpty ? "Group ${group.groupId}" : group.description, style: TextStyle( fontWeight: widget.selectedGroup == group ? FontWeight.bold : FontWeight.normal, color: widget.selectedGroup == group ? Colors.blue : null, ), ), ), ], ), ), ), ) .toList(), ), ...workgroup.routers.map( (router) => TreeNode( content: GestureDetector( onDoubleTap: () { widget.setActiveNode( 'router', workgroup: workgroup, router: router, ); }, onSecondaryTap: () { widget.setActiveNode( 'router', workgroup: workgroup, router: router, ); }, child: Row( children: [ const Icon(Icons.router), Padding( padding: const EdgeInsets.all(8.0), child: Text( router.description, style: TextStyle( fontWeight: widget.selectedRouter == router ? FontWeight.bold : FontWeight.normal, color: widget.selectedRouter == router ? Colors.blue : null, ), ), ), ], ), ), children: [ ...router.devicesBySubnet.entries.map((entry) { final subnet = entry.key; final subnetDevices = entry.value; final bool isSubnetSelected = widget.selectedWorkgroup == workgroup && widget.selectedRouter == router && widget.selectedSubnetNumber == subnet && widget.showingSubnetDetail; return TreeNode( content: GestureDetector( onDoubleTap: () { widget.setActiveNode( 'subnetDetail', workgroup: workgroup, router: router, subnetNumber: subnet, subnetDevices: subnetDevices, ); }, child: Row( children: [ Icon( Icons.hub, color: isSubnetSelected ? Colors.blue : null, ), Padding( padding: const EdgeInsets.all(8.0), child: Text( "Subnet $subnet (${subnetDevices.length} devices)", style: TextStyle( fontWeight: isSubnetSelected ? FontWeight.bold : FontWeight.normal, color: isSubnetSelected ? Colors.blue : null, ), ), ), ], ), ), children: subnetDevices .map( (device) => _buildDeviceTreeNode( device, context, workgroup, router, ), ) .toList(), ); }), ], ), ), ], ), ) .toList(), ), buildLogicComponentsNode(context), ], ), ], ), ); } TreeNode _buildDeviceTreeNode( HelvarDevice device, BuildContext context, Workgroup workgroup, HelvarRouter router, ) { final deviceName = device.description.isEmpty ? "Device_${device.deviceId}" : device.description; final bool isSelectedDevice = widget.selectedWorkgroup == workgroup && widget.selectedRouter == router && widget.selectedDevice == device && widget.showingDeviceDetail; final List<TreeNode> deviceChildren = []; if (device is HelvarDriverInputDevice && device.isButtonDevice && device.buttonPoints.isNotEmpty) { final bool isPointsSelected = widget.selectedWorkgroup == workgroup && widget.selectedRouter == router && widget.selectedDevice == device && widget.showingPointsDetail; deviceChildren.add( TreeNode( content: GestureDetector( onDoubleTap: () { widget.setActiveNode( 'pointsDetail', workgroup: workgroup, router: router, device: device, ); }, child: Row( children: [ Icon( Icons.add_circle_outline, size: 18, color: isPointsSelected ? Colors.blue : null, ), const SizedBox(width: 4), Text( "Points", style: TextStyle( fontWeight: isPointsSelected ? FontWeight.bold : FontWeight.normal, color: isPointsSelected ? Colors.blue : null, ), ), ], ), ), children: device.buttonPoints .map((point) => _buildDraggableButtonPointNode(point, device)) .toList(), ), ); } if (device is HelvarDriverOutputDevice) { if (device.outputPoints.isEmpty) { device.generateOutputPoints(); } if (device.outputPoints.isNotEmpty) { final bool isOutputPointsSelected = widget.selectedWorkgroup == workgroup && widget.selectedRouter == router && widget.selectedDevice == device && widget.showingOutputPointsDetail; deviceChildren.add( TreeNode( content: GestureDetector( onDoubleTap: () { widget.setActiveNode( 'outputPointsDetail', workgroup: workgroup, router: router, device: device, ); print('Output points tapped for ${device.address}'); }, child: Row( children: [ Icon( Icons.add_circle_outline, size: 18, color: isOutputPointsSelected ? Colors.blue : Colors.orange, ), const SizedBox(width: 4), Text( "Points", style: TextStyle( fontWeight: isOutputPointsSelected ? FontWeight.bold : FontWeight.normal, color: isOutputPointsSelected ? Colors.blue : null, ), ), ], ), ), children: device.outputPoints .map((point) => _buildOutputPointNode(point, device)) .toList(), ), ); } } if (device.helvarType == 'input' || device.emergency) { deviceChildren.add( TreeNode( content: const Row( children: [ Icon(Icons.warning_amber, size: 18), SizedBox(width: 4), Text("Alarm Source Info"), ], ), children: [ TreeNode( content: Padding( padding: const EdgeInsets.only(left: 16.0), child: Text('State: ${device.state}'), ), ), if (device.deviceStateCode != null) TreeNode( content: Padding( padding: const EdgeInsets.only(left: 16.0), child: Text( 'State Code: 0x${device.deviceStateCode!.toRadixString(16)}', ), ), ), ], ), ); } return TreeNode( content: GestureDetector( onDoubleTap: () { widget.setActiveNode( 'deviceDetail', workgroup: workgroup, router: router, device: device, ); }, onSecondaryTap: () => showDeviceContextMenu(context, device), child: Container( decoration: BoxDecoration( color: isSelectedDevice ? Colors.blue.withValues(alpha: 0.1) : null, borderRadius: BorderRadius.circular(4), border: isSelectedDevice ? Border.all(color: Colors.blue, width: 1) : null, ), child: buildDraggable(deviceName, device, context), ), ), children: deviceChildren.isEmpty ? null : deviceChildren, ); } TreeNode _buildOutputPointNode( OutputPoint outputPoint, HelvarDevice parentDevice, ) { final bool isOutputPointSelected = widget.selectedWorkgroup != null && widget.selectedRouter != null && widget.selectedDevice == parentDevice && widget.selectedOutputPoint == outputPoint && widget.showingOutputPointDetail; return TreeNode( content: GestureDetector( onDoubleTap: () { Workgroup? workgroup; HelvarRouter? router; for (final wg in widget.workgroups) { for (final r in wg.routers) { if (r.devices.any((d) => d.address == parentDevice.address)) { workgroup = wg; router = r; break; } } if (workgroup != null) break; } if (workgroup != null && router != null) { widget.setActiveNode( 'outputPointDetail', workgroup: workgroup, router: router, device: parentDevice, outputPoint: outputPoint, ); } }, child: Container( decoration: BoxDecoration( color: isOutputPointSelected ? Colors.blue.withValues(alpha: 0.1) : null, borderRadius: BorderRadius.circular(4), border: isOutputPointSelected ? Border.all(color: Colors.blue, width: 1) : null, ), child: Row( children: [ Icon( getOutputPointIcon(outputPoint), size: 16, color: isOutputPointSelected ? Colors.blue : Colors.orange, ), const SizedBox(width: 4), Text( outputPoint.function, style: TextStyle( color: isOutputPointSelected ? Colors.blue : null, fontWeight: isOutputPointSelected ? FontWeight.bold : FontWeight.normal, ), ), const SizedBox(width: 8), Container( padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2), decoration: BoxDecoration( color: getOutputPointValueColor(outputPoint), borderRadius: BorderRadius.circular(10), ), child: Text( formatOutputPointValue(outputPoint), style: const TextStyle( fontSize: 10, color: Colors.white, fontWeight: FontWeight.bold, ), ), ), ], ), ), ), ); } TreeNode _buildDraggableButtonPointNode( ButtonPoint buttonPoint, HelvarDevice parentDevice, ) { final bool isPointSelected = widget.selectedWorkgroup != null && widget.selectedRouter != null && widget.selectedDevice == parentDevice && widget.selectedPoint == buttonPoint && widget.showingPointDetail; return TreeNode( content: GestureDetector( onDoubleTap: () { Workgroup? workgroup; HelvarRouter? router; for (final wg in widget.workgroups) { for (final r in wg.routers) { if (r.devices.any((d) => d.address == parentDevice.address)) { workgroup = wg; router = r; break; } } if (workgroup != null) break; } if (workgroup != null && router != null) { widget.setActiveNode( 'pointDetail', workgroup: workgroup, router: router, device: parentDevice, point: buttonPoint, ); } }, child: Container( decoration: BoxDecoration( color: isPointSelected ? Colors.blue.withValues(alpha: 0.1) : null, borderRadius: BorderRadius.circular(4), border: isPointSelected ? Border.all(color: Colors.blue, width: 1) : null, ), child: Draggable<Map<String, dynamic>>( data: { "componentType": "BooleanPoint", "buttonPoint": buttonPoint, "parentDevice": parentDevice, "pointData": { "name": buttonPoint.name, "function": buttonPoint.function, "buttonId": buttonPoint.buttonId, "deviceAddress": parentDevice.address, "deviceId": parentDevice.deviceId, "isButtonPoint": true, }, }, feedback: Material( elevation: 4.0, child: Container( padding: const EdgeInsets.all(16.0), decoration: BoxDecoration( color: Colors.green[100], borderRadius: BorderRadius.circular(8.0), border: Border.all(color: Colors.green), ), child: Row( mainAxisSize: MainAxisSize.min, children: [ Icon( getButtonPointIcon(buttonPoint), color: Colors.green, size: 20, ), const SizedBox(width: 8.0), Text( getButtonPointDisplayName(buttonPoint), style: const TextStyle(fontWeight: FontWeight.bold), ), ], ), ), ), childWhenDragging: Row( children: [ Icon( getButtonPointIcon(buttonPoint), size: 16, color: Colors.grey[400], ), const SizedBox(width: 4), Text( getButtonPointDisplayName(buttonPoint), style: TextStyle(color: Colors.grey[600]), ), ], ), child: Row( children: [ Icon( getButtonPointIcon(buttonPoint), size: 16, color: isPointSelected ? Colors.blue : Colors.green, ), const SizedBox(width: 4), Text( getButtonPointDisplayName(buttonPoint), style: TextStyle( color: isPointSelected ? Colors.blue : null, fontWeight: isPointSelected ? FontWeight.bold : FontWeight.normal, ), ), ], ), ), ), ), ); } } 

// File: \lib\widgets\command_monitor.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/utils/date_utils.dart'; import '../providers/router_connection_provider.dart'; import '../comm/models/command_models.dart'; class CommandMonitor extends ConsumerWidget { const CommandMonitor({super.key}); @override Widget build(BuildContext context, WidgetRef ref) { final commandHistory = ref.watch(commandHistoryProvider); return Card( child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Text( 'Command History', style: Theme.of(context).textTheme.titleLarge, ), IconButton( icon: const Icon(Icons.refresh), tooltip: 'Clear History', onPressed: () { ref.read(routerCommandServiceProvider).clearHistory(); }, ), ], ), const SizedBox(height: 8), if (commandHistory.isEmpty) const Center( child: Padding( padding: EdgeInsets.all(16.0), child: Text('No commands executed yet'), ), ) else Expanded( child: ListView.builder( itemCount: commandHistory.length, itemBuilder: (context, index) { final command = commandHistory[index]; return _buildCommandItem(context, command); }, ), ), ], ), ), ); } Widget _buildCommandItem(BuildContext context, QueuedCommand command) { IconData icon; Color color; switch (command.status) { case CommandStatus.completed: icon = Icons.check_circle; color = Colors.green; break; case CommandStatus.executing: icon = Icons.pending; color = Colors.blue; break; case CommandStatus.queued: icon = Icons.hourglass_empty; color = Colors.orange; break; case CommandStatus.failed: icon = Icons.error; color = Colors.red; break; case CommandStatus.timedOut: icon = Icons.timer_off; color = Colors.red; break; case CommandStatus.cancelled: icon = Icons.cancel; color = Colors.grey; break; } return ExpansionTile( leading: Icon(icon, color: color), title: Text( command.command.length > 30 ? '${command.command.substring(0, 30)}...' : command.command, ), subtitle: Text( '${command.routerIp} - ${formatDateTime(command.queuedAt)}', ), trailing: command.attemptsMade > 1 ? Chip(label: Text('${command.attemptsMade} attempts')) : null, children: [ Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text('Full Command: ${command.command}'), const SizedBox(height: 8), Text('Status: ${command.status.toString().split('.').last}'), const SizedBox(height: 8), Text('Priority: ${command.priority.toString().split('.').last}'), const SizedBox(height: 8), if (command.groupId != null) Text('Group ID: ${command.groupId}'), if (command.groupId != null) const SizedBox(height: 8), Text('Queued At: ${formatDateTime(command.queuedAt)}'), if (command.executedAt != null) ...[ const SizedBox(height: 8), Text('Executed At: ${formatDateTime(command.executedAt!)}'), ], if (command.completedAt != null) ...[ const SizedBox(height: 8), Text('Completed At: ${formatDateTime(command.completedAt!)}'), ], if (command.response != null) ...[ const SizedBox(height: 8), Text('Response: ${command.response}'), ], if (command.errorMessage != null) ...[ const SizedBox(height: 8), Text( 'Error: ${command.errorMessage}', style: const TextStyle(color: Colors.red), ), ], ], ), ), ], ); } } 

// File: \lib\widgets\draggable_function_node.dart
import 'package:flutter/material.dart'; import 'package:grms_designer/models/helvar_models/helvar_device.dart'; import 'package:grms_designer/utils/device_icons.dart'; Widget buildDraggable( String label, HelvarDevice? device, BuildContext context, ) { return Draggable<Map<String, dynamic>>( data: { "componentType": label, "device": device, "deviceData": device != null ? { "deviceId": device.deviceId, "deviceAddress": device.address, "deviceType": device.helvarType, "description": device.description, } : null, }, feedback: Material( elevation: 4.0, child: Container( padding: const EdgeInsets.all(16.0), decoration: BoxDecoration( color: Colors.blue[100], borderRadius: BorderRadius.circular(8.0), ), child: Row( mainAxisSize: MainAxisSize.min, children: [ getDeviceIconWidget(device), const SizedBox(width: 8.0), Text(label), ], ), ), ), childWhenDragging: Row( children: [ getDeviceIconWidget(device, size: 20.0), const SizedBox(width: 8.0), Text(label, style: TextStyle(color: Colors.grey[600])), ], ), child: Row( children: [ getDeviceIconWidget(device), const SizedBox(width: 8.0), Text(label), ], ), ); } 

// File: \lib\widgets\logics_treenode.dart
import 'package:flutter/material.dart'; import 'package:flutter_simple_treeview/flutter_simple_treeview.dart'; import 'package:grms_designer/niagara/models/component_type.dart'; import 'package:grms_designer/utils/device_utils.dart'; import 'package:grms_designer/utils/general_ui.dart'; TreeNode buildLogicComponentsNode(BuildContext context) { return TreeNode( content: GestureDetector( onDoubleTap: () { }, child: const Padding( padding: EdgeInsets.all(8.0), child: Text( "Components", style: TextStyle(fontWeight: FontWeight.bold), ), ), ), children: [ TreeNode( content: const Padding( padding: EdgeInsets.all(8.0), child: Text("Logic", style: TextStyle(fontWeight: FontWeight.bold)), ), children: [ TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.AND_GATE), ), ), TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.OR_GATE), ), ), TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.IS_GREATER_THAN), ), ), ], ), TreeNode( content: const Padding( padding: EdgeInsets.all(8.0), child: Text("Math", style: TextStyle(fontWeight: FontWeight.bold)), ), children: [ TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.ADD), ), ), TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.SUBTRACT), ), ), TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.MULTIPLY), ), ), TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.DIVIDE), ), ), TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.MAX), ), ), TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.MIN), ), ), TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.POWER), ), ), TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.ABS), ), ), ], ), TreeNode( content: const Padding( padding: EdgeInsets.all(8.0), child: Text("UI", style: TextStyle(fontWeight: FontWeight.bold)), ), children: [ TreeNode( content: _buildDraggableComponentItem( const ComponentType("Button"), ), ), TreeNode( content: _buildDraggableComponentItem(const ComponentType("Text")), ), ], ), TreeNode( content: const Padding( padding: EdgeInsets.all(8.0), child: Text("Util", style: TextStyle(fontWeight: FontWeight.bold)), ), children: [ TreeNode( content: _buildDraggableComponentItem(const ComponentType("Ramp")), ), TreeNode( content: _buildDraggableComponentItem( const ComponentType("Toggle"), ), ), ], ), TreeNode( content: const Padding( padding: EdgeInsets.all(8.0), child: Text("Points", style: TextStyle(fontWeight: FontWeight.bold)), ), children: [ TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.BOOLEAN_POINT), ), ), TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.BOOLEAN_WRITABLE), ), ), TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.STRING_POINT), ), ), TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.STRING_WRITABLE), ), ), TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.NUMERIC_POINT), ), ), TreeNode( content: _buildDraggableComponentItem( const ComponentType(ComponentType.NUMERIC_WRITABLE), ), ), ], ), ], ); } Widget _buildDraggableComponentItem(ComponentType type) { final comp = Column( children: [ Icon(getIconForComponentType(type)), const SizedBox(height: 4.0), Text(getNameForComponentType(type), style: const TextStyle(fontSize: 12)), ], ); return Draggable<ComponentType>( data: type, feedback: Material( elevation: 4.0, child: Container( padding: const EdgeInsets.all(8.0), decoration: BoxDecoration( color: Colors.white, borderRadius: BorderRadius.circular(4.0), border: Border.all(color: Colors.indigo), ), child: Column( mainAxisSize: MainAxisSize.min, children: [ Icon(getIconForComponentType(type), size: 24), const SizedBox(height: 4.0), Text( getNameForComponentType(type), style: const TextStyle(fontSize: 12), ), ], ), ), ), childWhenDragging: Opacity( opacity: 0.3, child: Container( padding: const EdgeInsets.all(8.0), decoration: BoxDecoration( border: Border.all(color: Colors.grey), borderRadius: BorderRadius.circular(4.0), ), child: comp, ), ), child: Container( padding: const EdgeInsets.all(8.0), decoration: BoxDecoration( border: Border.all(color: Colors.grey), borderRadius: BorderRadius.circular(4.0), ), child: comp, ), ); } 

// File: \lib\widgets\project_treenode.dart
import 'package:flutter/material.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:flutter_simple_treeview/flutter_simple_treeview.dart'; import 'package:grms_designer/providers/flowsheet_provider.dart'; import 'package:grms_designer/screens/dialogs/flowsheet_actions.dart'; import 'package:grms_designer/widgets/app_tree_view.dart'; TreeNode buildProjectNode( AppTreeView widget, BuildContext context, WidgetRef ref, ) { return TreeNode( content: GestureDetector( onDoubleTap: () { widget.setActiveNode('project'); }, child: Padding( padding: const EdgeInsets.all(8.0), child: Text( "Project", style: TextStyle( fontWeight: widget.showingProject ? FontWeight.bold : FontWeight.normal, color: widget.showingProject ? Colors.blue : null, ), ), ), ), children: [ TreeNode( content: GestureDetector( onDoubleTap: () { widget.setActiveNode('settings'); }, child: Padding( padding: const EdgeInsets.all(8.0), child: Text( "Settings", style: TextStyle( fontWeight: widget.openSettings ? FontWeight.bold : FontWeight.normal, color: widget.openSettings ? Colors.blue : null, ), ), ), ), ), TreeNode( content: GestureDetector( onDoubleTap: () { widget.setActiveNode('files'); }, child: Padding( padding: const EdgeInsets.all(8.0), child: Text( "Files", style: TextStyle( fontWeight: widget.currentFileDirectory != null && !widget.showingImages ? FontWeight.bold : FontWeight.normal, color: widget.currentFileDirectory != null && !widget.showingImages ? Colors.blue : null, ), ), ), ), children: [ TreeNode( content: GestureDetector( onDoubleTap: () { widget.setActiveNode('images'); }, child: Padding( padding: const EdgeInsets.all(8.0), child: Text( "Images", style: TextStyle( fontWeight: widget.showingImages ? FontWeight.bold : FontWeight.normal, color: widget.showingImages ? Colors.blue : null, ), ), ), ), ), TreeNode( content: GestureDetector( onDoubleTap: () { widget.setActiveNode('graphics'); }, child: const Padding( padding: EdgeInsets.all(8.0), child: Text( "Graphics", style: TextStyle(fontWeight: FontWeight.normal), ), ), ), children: [ TreeNode( content: GestureDetector( onDoubleTap: () { widget.setActiveNode('graphicsDetail'); }, child: const Padding( padding: EdgeInsets.all(8.0), child: Text( "Graphics 1", style: TextStyle(fontWeight: FontWeight.normal), ), ), ), ), ], ), TreeNode( content: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ GestureDetector( onDoubleTap: () { widget.setActiveNode('wiresheets'); }, child: Padding( padding: const EdgeInsets.all(8.0), child: Text( "Flowsheets", style: TextStyle( fontWeight: widget.openWiresheet ? FontWeight.bold : FontWeight.normal, color: widget.openWiresheet ? Colors.blue : null, ), ), ), ), IconButton( icon: const Icon(Icons.add, size: 18), tooltip: 'Create New Flowsheet', onPressed: () => createNewFlowsheet(context, ref), ), ], ), children: [ ...widget.wiresheets.map( (wiresheet) => TreeNode( content: GestureDetector( onDoubleTap: () { final activeFlowsheetId = ref .read(flowsheetsProvider.notifier) .activeFlowsheetId; if (activeFlowsheetId != null && activeFlowsheetId != wiresheet.id) { ref .read(flowsheetsProvider.notifier) .saveActiveFlowsheet(); } widget.setActiveNode( 'wiresheet', wiresheetId: wiresheet.id, ); }, child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Padding( padding: const EdgeInsets.all(8.0), child: Text( wiresheet.name, style: TextStyle( fontWeight: widget.selectedWiresheetId == wiresheet.id ? FontWeight.bold : FontWeight.normal, color: widget.selectedWiresheetId == wiresheet.id ? Colors.blue : null, ), ), ), IconButton( icon: const Icon(Icons.delete, size: 18), tooltip: 'Delete Flowsheet', onPressed: () async { final result = await confirmDeleteFlowsheet( context, wiresheet.id, wiresheet.name, ref, ); if (result && context.mounted) { if (widget.selectedWiresheetId == wiresheet.id) { widget.setActiveNode('wiresheets'); } ScaffoldMessenger.of(context).showSnackBar( const SnackBar( content: Text('Flowsheet deleted'), ), ); } }, ), ], ), ), ), ), ], ), ], ), ], ); } 

// File: \lib\widgets\wiresheet_flow_editor.dart
import 'package:flutter/material.dart'; import 'package:flutter/services.dart'; import 'package:flutter_riverpod/flutter_riverpod.dart'; import 'package:grms_designer/models/flowsheet.dart'; import 'package:grms_designer/providers/flowsheet_provider.dart'; import 'package:grms_designer/utils/logger.dart'; import 'package:grms_designer/utils/canvas_dialog_utils.dart' as dialog_utils; import 'package:grms_designer/utils/component_factory.dart' as component_factory; import '../niagara/controllers/flow_editor_state.dart'; import '../niagara/controllers/clipboard_manager.dart'; import '../niagara/controllers/drag_operation_manager.dart'; import '../niagara/controllers/canvas_interaction_controller.dart'; import '../niagara/controllers/selection_manager.dart'; import '../niagara/home/command.dart'; import '../niagara/home/handlers.dart'; import '../niagara/models/command_history.dart'; import '../niagara/home/component_widget.dart'; import '../niagara/home/connection_painter.dart'; import '../niagara/home/grid_painter.dart'; import '../niagara/home/intents.dart'; import '../niagara/home/manager.dart'; import '../niagara/home/selection_box_painter.dart'; import '../niagara/models/component.dart'; import '../niagara/models/component_type.dart'; import '../niagara/models/connection.dart'; import '../services/flowsheet_storage_service.dart'; import '../utils/general_ui.dart'; import '../utils/persistent_helper.dart'; class WiresheetFlowEditor extends ConsumerStatefulWidget { final Flowsheet flowsheet; const WiresheetFlowEditor({super.key, required this.flowsheet}); @override WiresheetFlowEditorState createState() => WiresheetFlowEditorState(); } class WiresheetFlowEditorState extends ConsumerState<WiresheetFlowEditor> { late FlowEditorState _editorState; late ClipboardManager _clipboardManager; late PersistenceHelper _persistenceHelper; late FlowsheetStorageService _storageService; late SelectionManager _selectionManager; late FlowHandlers _flowHandlers; late DragOperationManager _dragManager; late CanvasInteractionController _canvasController; final Map<String, Map<String, dynamic>> _buttonPointMetadata = {}; final TransformationController _transformationController = TransformationController(); final Size _canvasSize = const Size(2000, 2000); @override void initState() { super.initState(); _initializeState(); } void _initializeState() { _transformationController.value = Matrix4.identity(); _canvasController = CanvasInteractionController(); final flowManager = FlowManager(); final commandHistory = CommandHistory(); _editorState = FlowEditorState( flowManager: flowManager, commandHistory: commandHistory, ); _selectionManager = SelectionManager(); _selectionManager.setOnSelectionChanged(_onSelectionChanged); _clipboardManager = ClipboardManager(); _dragManager = DragOperationManager(); _storageService = ref.read(flowsheetStorageServiceProvider); _flowHandlers = FlowHandlers( flowManager: _editorState.flowManager, commandHistory: _editorState.commandHistory, componentPositions: _editorState.componentPositions, componentKeys: _editorState.componentKeys, componentWidths: _editorState.componentWidths, setState: setState, updateCanvasSize: _updateCanvasSize, selectedComponents: _selectionManager.selectedComponents, clipboardComponents: _clipboardManager.clipboardComponents, clipboardPositions: _clipboardManager.clipboardPositions, clipboardConnections: _clipboardManager.clipboardConnections, setClipboardComponentPosition: (position) { _clipboardManager.setClipboardReferencePosition(position); }, ); _persistenceHelper = PersistenceHelper( flowsheet: widget.flowsheet, storageService: _storageService, flowManager: _editorState.flowManager, componentPositions: _editorState.componentPositions, componentWidths: _editorState.componentWidths, getMountedStatus: () => mounted, onFlowsheetUpdate: (updatedFlowsheet) { if (mounted) { ref .read(flowsheetsProvider.notifier) .updateFlowsheet(widget.flowsheet.id, updatedFlowsheet); } }, ); _initializeComponents(); } void _onSelectionChanged(Set<Component> selectedComponents) { if (mounted) { setState(() {}); } } @override void dispose() { _saveStateSync(); super.dispose(); } void _saveStateSync() { try { final updatedFlowsheet = widget.flowsheet.copy(); updatedFlowsheet.components = _editorState.flowManager.components; final List<Connection> connections = []; for (final component in _editorState.flowManager.components) { for (final entry in component.inputConnections.entries) { connections.add( Connection( fromComponentId: entry.value.componentId, fromPortIndex: entry.value.portIndex, toComponentId: component.id, toPortIndex: entry.key, ), ); } } updatedFlowsheet.connections = connections; for (final entry in _editorState.componentPositions.entries) { updatedFlowsheet.updateComponentPosition(entry.key, entry.value); } for (final entry in _editorState.componentWidths.entries) { updatedFlowsheet.updateComponentWidth(entry.key, entry.value); } _storageService.saveFlowsheet(updatedFlowsheet); } catch (e) { print('Error saving flowsheet state in dispose: $e'); } } @override void didUpdateWidget(WiresheetFlowEditor oldWidget) { super.didUpdateWidget(oldWidget); if (oldWidget.flowsheet.id != widget.flowsheet.id) { _saveStateSync(); _editorState.clear(); _selectionManager.clearSelection(); _clipboardManager.clear(); _flowHandlers = FlowHandlers( flowManager: _editorState.flowManager, commandHistory: _editorState.commandHistory, componentPositions: _editorState.componentPositions, componentKeys: _editorState.componentKeys, componentWidths: _editorState.componentWidths, setState: setState, updateCanvasSize: _updateCanvasSize, selectedComponents: _selectionManager.selectedComponents, clipboardComponents: _clipboardManager.clipboardComponents, clipboardPositions: _clipboardManager.clipboardPositions, clipboardConnections: _clipboardManager.clipboardConnections, setClipboardComponentPosition: (position) { _clipboardManager.setClipboardReferencePosition(position); }, ); _persistenceHelper = PersistenceHelper( flowsheet: widget.flowsheet, storageService: _storageService, flowManager: _editorState.flowManager, componentPositions: _editorState.componentPositions, componentWidths: _editorState.componentWidths, getMountedStatus: () => mounted, onFlowsheetUpdate: (updatedFlowsheet) { if (mounted) { ref .read(flowsheetsProvider.notifier) .updateFlowsheet(widget.flowsheet.id, updatedFlowsheet); } }, ); _initializeComponents(); } } void _updateCanvasSize() { if (_canvasController.updateCanvasSize( _editorState.componentPositions, _editorState.componentWidths, )) { setState(() {}); _updateCanvasSizeAsync(); } } Future<void> _updateCanvasSizeAsync() async { Future.microtask(() async { if (!mounted) return; await ref .read(flowsheetsProvider.notifier) .updateCanvasSize(widget.flowsheet.id, _canvasController.canvasSize); await ref .read(flowsheetsProvider.notifier) .updateCanvasOffset( widget.flowsheet.id, _canvasController.canvasOffset, ); for (var id in _editorState.componentPositions.keys) { await _persistenceHelper.saveComponentPosition( id, _editorState.getComponentPosition(id), ); } }); } Future<void> saveFullState() async { await _persistenceHelper.saveFullState(); } void _initializeComponents() { for (var component in widget.flowsheet.components) { _editorState.flowManager.addComponent(component); Offset position = Offset.zero; if (widget.flowsheet.componentPositions.containsKey(component.id)) { position = widget.flowsheet.componentPositions[component.id]!; } double width = 160.0; if (widget.flowsheet.componentWidths.containsKey(component.id)) { width = widget.flowsheet.componentWidths[component.id]!; } _editorState.initializeComponentState( component, position: position, width: width, ); } for (var connection in widget.flowsheet.connections) { _editorState.flowManager.createConnection( connection.fromComponentId, connection.fromPortIndex, connection.toComponentId, connection.toPortIndex, ); } _editorState.flowManager.recalculateAll(); _updateCanvasSize(); _editorState.commandHistory.clear(); } @override Widget build(BuildContext context) { return PopScope( canPop: true, onPopInvokedWithResult: (didPop, result) { if (didPop) { WidgetsBinding.instance.addPostFrameCallback((_) { if (mounted) { _persistenceHelper.saveFullState(); } }); } }, child: Shortcuts( shortcuts: getShortcuts(), child: Actions( actions: <Type, Action<Intent>>{ UndoIntent: CallbackAction<UndoIntent>( onInvoke: (UndoIntent intent) { if (_editorState.commandHistory.canUndo) { setState(() { _editorState.commandHistory.undo(); }); } return null; }, ), RedoIntent: CallbackAction<RedoIntent>( onInvoke: (RedoIntent intent) { if (_editorState.commandHistory.canRedo) { setState(() { _editorState.commandHistory.redo(); }); } return null; }, ), SelectAllIntent: CallbackAction<SelectAllIntent>( onInvoke: (SelectAllIntent intent) { _selectionManager.selectAll( _editorState.flowManager.components, ); return null; }, ), DeleteIntent: CallbackAction<DeleteIntent>( onInvoke: (DeleteIntent intent) { if (_selectionManager.selectedComponents.isNotEmpty) { setState(() { for (var component in _selectionManager.selectedComponents.toList()) { _handleDeleteComponent(component); } _selectionManager.clearSelection(); }); } return null; }, ), CopyIntent: CallbackAction<CopyIntent>( onInvoke: (CopyIntent intent) { if (_selectionManager.selectedComponents.length == 1) { _handleCopyComponent( _selectionManager.selectedComponents.first, ); } else if (_selectionManager.selectedComponents.isNotEmpty) { _handleCopyMultipleComponents(); } return null; }, ), MoveDownIntent: CallbackAction<MoveDownIntent>( onInvoke: (MoveDownIntent intent) { if (_selectionManager.selectedComponents.isNotEmpty) { for (var component in _selectionManager.selectedComponents) { _handleMoveComponentDown(component); } } return null; }, ), MoveLeftIntent: CallbackAction<MoveLeftIntent>( onInvoke: (MoveLeftIntent intent) { if (_selectionManager.selectedComponents.isNotEmpty) { for (var component in _selectionManager.selectedComponents) { _handleMoveComponentLeft(component); } } return null; }, ), MoveRightIntent: CallbackAction<MoveRightIntent>( onInvoke: (MoveRightIntent intent) { if (_selectionManager.selectedComponents.isNotEmpty) { for (var component in _selectionManager.selectedComponents) { _handleMoveComponentRight(component); } } return null; }, ), MoveUpIntent: CallbackAction<MoveUpIntent>( onInvoke: (MoveUpIntent intent) { if (_selectionManager.selectedComponents.isNotEmpty) { for (var component in _selectionManager.selectedComponents) { _handleMoveComponentUp(component); } } return null; }, ), PasteIntent: CallbackAction<PasteIntent>( onInvoke: (PasteIntent intent) { if (!_clipboardManager.isEmpty) { if (_clipboardManager.clipboardReferencePosition != null) { const double offsetAmount = 30.0; final Offset pastePosition = _clipboardManager.clipboardReferencePosition! + const Offset(offsetAmount, offsetAmount); _handlePasteComponent(pastePosition); } else { final RenderBox? viewerChildRenderBox = _editorState.interactiveViewerChildKey.currentContext ?.findRenderObject() as RenderBox?; if (viewerChildRenderBox != null) { final viewportSize = viewerChildRenderBox.size; final viewportCenter = Offset( viewportSize.width / 2, viewportSize.height / 2, ); final matrix = _transformationController.value; final inverseMatrix = Matrix4.inverted(matrix); final canvasPosition = MatrixUtils.transformPoint( inverseMatrix, viewportCenter, ); _handlePasteComponent(canvasPosition); } } } return null; }, ), }, child: Focus( autofocus: true, child: Scaffold( appBar: AppBar( title: const Text('Visual Flow Editor'), actions: [ Padding( padding: const EdgeInsets.symmetric(horizontal: 8.0), child: Center( child: Text( 'Canvas: ${_canvasController.canvasSize.width.toInt()} × ${_canvasController.canvasSize.height.toInt()}', style: const TextStyle(fontSize: 14), ), ), ), IconButton( icon: const Icon(Icons.undo), tooltip: _editorState.commandHistory.canUndo ? 'Undo: ${_editorState.commandHistory.lastUndoDescription}' : 'Undo', onPressed: _editorState.commandHistory.canUndo ? () { setState(() { _editorState.commandHistory.undo(); }); } : null, ), IconButton( icon: const Icon(Icons.redo), tooltip: _editorState.commandHistory.canRedo ? 'Redo: ${_editorState.commandHistory.lastRedoDescription}' : 'Redo', onPressed: _editorState.commandHistory.canRedo ? () { setState(() { _editorState.commandHistory.redo(); }); } : null, ), ], ), body: ClipRect( child: InteractiveViewer( transformationController: _canvasController.transformationController, boundaryMargin: const EdgeInsets.all(1000), minScale: 0.1, constrained: false, maxScale: 3.0, panEnabled: true, scaleEnabled: true, child: CustomPaint( key: _editorState.interactiveViewerChildKey, foregroundPainter: ConnectionPainter( flowManager: _editorState.flowManager, componentPositions: _editorState.componentPositions, componentKeys: _editorState.componentKeys, componentWidths: _editorState.componentWidths, tempLineStartInfo: _dragManager.currentDraggedPort, tempLineEndPoint: _dragManager.tempLineEndPoint, ), child: GestureDetector( onTapDown: (details) { final canvasBox = _editorState.canvasKey.currentContext ?.findRenderObject() as RenderBox?; if (canvasBox != null) { final canvasPosition = _canvasController .getCanvasPosition( details.globalPosition, canvasBox, ); if (canvasPosition != null) { _selectionManager.clearSelection(); } } }, onPanStart: (details) { final canvasBox = _editorState.canvasKey.currentContext ?.findRenderObject() as RenderBox?; if (canvasBox != null) { final canvasPosition = _canvasController .getCanvasPosition( details.globalPosition, canvasBox, ); if (canvasPosition != null) { bool isClickOnComponent = _editorState .isPointOverComponent(canvasPosition); if (!isClickOnComponent) { _selectionManager.startSelectionBox( canvasPosition, ); } } } }, onPanUpdate: (details) { final canvasBox = _editorState.canvasKey.currentContext ?.findRenderObject() as RenderBox?; if (canvasBox != null) { final canvasPosition = _canvasController .getCanvasPosition( details.globalPosition, canvasBox, ); if (canvasPosition != null) { if (_selectionManager.isDraggingSelectionBox) { setState(() { _selectionManager.updateSelectionBox( canvasPosition, ); }); } else if (_dragManager.isPortDragInProgress()) { setState(() { _dragManager.updatePortDragPosition( canvasPosition, ); }); } } } }, onPanEnd: (details) { if (_selectionManager.isDraggingSelectionBox) { setState(() { _selectionManager.endSelectionBoxWithSizes( _editorState.flowManager.components, _editorState.componentPositions, _editorState.componentWidths, 150.0, ); }); } }, onDoubleTapDown: (TapDownDetails details) { final canvasBox = _editorState.canvasKey.currentContext ?.findRenderObject() as RenderBox?; if (canvasBox != null) { final canvasPosition = _canvasController .getCanvasPosition( details.globalPosition, canvasBox, ); if (canvasPosition != null) { bool isClickOnComponent = _editorState .isPointOverComponent(canvasPosition); if (!isClickOnComponent) { _showCanvasContextMenu( context, details.globalPosition, ); } } } }, child: DragTarget<Object>( onAcceptWithDetails: (DragTargetDetails<dynamic> details) { final canvasBox = _editorState.canvasKey.currentContext ?.findRenderObject() as RenderBox?; if (canvasBox != null) { final canvasPosition = _canvasController .getCanvasPosition( details.offset, canvasBox, ); if (canvasPosition != null) { _handleCanvasDropAccept( details.data, canvasPosition, ); } } }, builder: (context, candidateData, rejectedData) { return Container( key: _editorState.canvasKey, width: _canvasController.canvasSize.width, height: _canvasController.canvasSize.height, color: Colors.grey[50], child: Stack( clipBehavior: Clip.none, children: [ CustomPaint( painter: GridPainter(), size: _canvasSize, ), if (_selectionManager.isDraggingSelectionBox && _selectionManager.selectionBoxStart != null && _selectionManager.selectionBoxEnd != null) CustomPaint( painter: SelectionBoxPainter( start: _selectionManager.selectionBoxStart, end: _selectionManager.selectionBoxEnd, ), size: _canvasSize, ), if (_editorState.flowManager.components.isEmpty) const Center( child: Text( 'Add components to the canvas', style: TextStyle( color: Colors.grey, fontSize: 18, ), ), ), ..._editorState.flowManager.components.map(( component, ) { return Positioned( left: _editorState .getComponentPosition(component.id) .dx, top: _editorState .getComponentPosition(component.id) .dy, child: Draggable<String>( data: component.id, feedback: Material( elevation: 5.0, color: Colors.transparent, child: ComponentWidget( component: component, height: component.allSlots.length * rowHeight, isSelected: _selectionManager .isComponentSelected(component), widgetKey: _editorState .getComponentKey(component.id), position: _editorState .getComponentPosition( component.id, ), width: _editorState.getComponentWidth( component.id, ), onValueChanged: _handleValueChanged, onSlotDragStarted: _handlePortDragStarted, onSlotDragAccepted: _handlePortDragAccepted, onWidthChanged: _handleComponentResize, ), ), childWhenDragging: Opacity( opacity: 0.3, child: ComponentWidget( component: component, height: component.allSlots.length * rowHeight, isSelected: _selectionManager .isComponentSelected(component), widgetKey: GlobalKey(), position: _editorState .getComponentPosition( component.id, ), width: _editorState.getComponentWidth( component.id, ), onValueChanged: _handleValueChanged, onSlotDragStarted: _handlePortDragStarted, onSlotDragAccepted: _handlePortDragAccepted, onWidthChanged: _handleComponentResize, ), ), onDragStarted: () { _dragManager.startComponentDrag( _editorState.getComponentPosition( component.id, ), ); }, onDragEnd: (details) { _handleComponentDragEnd( component, details, ); }, child: GestureDetector( onSecondaryTapDown: (details) { _showContextMenu( context, details.globalPosition, component, ); }, onTap: () { if (HardwareKeyboard .instance .isControlPressed) { _selectionManager .toggleComponentSelection( component, ); } else { _selectionManager.selectComponent( component, ); } }, child: ComponentWidget( component: component, height: component.allSlots.length * rowHeight, width: _editorState.getComponentWidth( component.id, ), onWidthChanged: _handleComponentResize, isSelected: _selectionManager .isComponentSelected(component), widgetKey: _editorState .getComponentKey(component.id), position: _editorState .getComponentPosition( component.id, ), onValueChanged: _handleValueChanged, onSlotDragStarted: _handlePortDragStarted, onSlotDragAccepted: _handlePortDragAccepted, ), ), ), ); }), ], ), ); }, ), ), ), ), ), floatingActionButton: Column( mainAxisAlignment: MainAxisAlignment.end, children: [ FloatingActionButton( mini: true, onPressed: () { setState(() { _canvasController.resetView(); }); }, tooltip: 'Reset View', child: const Icon(Icons.center_focus_strong), ), ], ), ), ), ), ), ); } void _showCanvasContextMenu(BuildContext context, Offset globalPosition) { dialog_utils.showCanvasContextMenu( context, globalPosition, _editorState.canvasKey, _clipboardManager, _canvasController, _handlePasteComponent, _showAddComponentDialogAtPosition, _showPasteSpecialDialog, () => _selectionManager.selectAll(_editorState.flowManager.components), ); } void _showPasteSpecialDialog(Offset pastePosition) { dialog_utils.showPasteSpecialDialog( context, _clipboardManager, pastePosition, _handlePasteSpecialComponent, ); } void _addNewComponent(ComponentType type, {Offset? clickPosition}) { setState(() { component_factory.addNewComponent( type, _editorState.flowManager, _editorState, _persistenceHelper, _canvasController, _updateCanvasSize, clickPosition: clickPosition, ); }); } void _showAddComponentDialogAtPosition(Offset position) { dialog_utils.showAddComponentDialogAtPosition( context, position, _addNewComponent, ); } void _showContextMenu( BuildContext context, Offset position, Component component, ) { dialog_utils.showComponentContextMenu( context, position, component, _clipboardManager, _handleCopyComponent, _handleEditComponent, _handleDeleteComponent, _handleCopyMultipleComponents, _selectionManager.selectedComponents.length > 1, ); } void _addNewDeviceComponent( Map<String, dynamic> deviceData, { Offset? clickPosition, }) { setState(() { component_factory.addNewDeviceComponent( deviceData, _editorState.flowManager, _editorState, _persistenceHelper, _canvasController, _updateCanvasSize, clickPosition: clickPosition, ); }); } void _addNewButtonPointComponent( Map<String, dynamic> buttonPointData, { Offset? clickPosition, }) { setState(() { component_factory.addNewButtonPointComponent( buttonPointData, _editorState.flowManager, _editorState, _persistenceHelper, _canvasController, _updateCanvasSize, clickPosition: clickPosition, buttonPointMetadata: _buttonPointMetadata, ); }); } void _handleComponentResize(String componentId, double newWidth) { _flowHandlers.handleComponentResize(componentId, newWidth); _editorState.setComponentWidth(componentId, newWidth); _persistenceHelper.saveComponentWidth(componentId, newWidth); _updateCanvasSize(); } void _handleValueChanged( String componentId, int slotIndex, dynamic newValue, ) { _flowHandlers.handleValueChanged(componentId, slotIndex, newValue); final comp = _editorState.flowManager.findComponentById(componentId); if (comp != null) { _persistenceHelper.savePortValue(componentId, slotIndex, newValue); _persistenceHelper.saveUpdateComponent(componentId, comp); } } void _handlePortDragStarted(SlotDragInfo slotInfo) { setState(() { _dragManager.startPortDrag(slotInfo); }); } void _handlePortDragAccepted(SlotDragInfo targetSlotInfo) { if (_dragManager.currentDraggedPort != null) { Component? sourceComponent = _editorState.flowManager.findComponentById( _dragManager.currentDraggedPort!.componentId, ); Component? targetComponent = _editorState.flowManager.findComponentById( targetSlotInfo.componentId, ); if (sourceComponent != null && targetComponent != null) { if (_editorState.flowManager.canCreateConnection( _dragManager.currentDraggedPort!.componentId, _dragManager.currentDraggedPort!.slotIndex, targetSlotInfo.componentId, targetSlotInfo.slotIndex, )) { setState(() { final command = CreateConnectionCommand( _editorState.flowManager, _dragManager.currentDraggedPort!.componentId, _dragManager.currentDraggedPort!.slotIndex, targetSlotInfo.componentId, targetSlotInfo.slotIndex, ); _editorState.commandHistory.execute(command); _persistenceHelper.saveAddConnection( Connection( fromComponentId: _dragManager.currentDraggedPort!.componentId, fromPortIndex: _dragManager.currentDraggedPort!.slotIndex, toComponentId: targetSlotInfo.componentId, toPortIndex: targetSlotInfo.slotIndex, ), ); }); } else { logWarning( 'Cannot connect these slots - type mismatch or invalid connection', ); } } } setState(() { _dragManager.endPortDrag(); }); } void _handleCanvasDropAccept(dynamic data, Offset canvasPosition) { if (data is ComponentType) { _addNewComponent(data, clickPosition: canvasPosition); } else if (data is Map<String, dynamic>) { if (data.containsKey("buttonPoint") && data.containsKey("pointData")) { _addNewButtonPointComponent(data, clickPosition: canvasPosition); } else if (data.containsKey("device")) { _addNewDeviceComponent(data, clickPosition: canvasPosition); } } } void _handleComponentDragEnd(Component component, DraggableDetails details) { final RenderBox? viewerChildRenderBox = _editorState.interactiveViewerChildKey.currentContext ?.findRenderObject() as RenderBox?; if (viewerChildRenderBox != null) { final Offset localOffset = viewerChildRenderBox.globalToLocal( details.offset, ); if (_dragManager.dragStartPosition != null && _dragManager.dragStartPosition != localOffset) { setState(() { if (_selectionManager.isComponentSelected(component) && _selectionManager.selectedComponents.length > 1) { _handleMultiComponentDrag(localOffset); } else { _handleSingleComponentDrag(component, localOffset); } _dragManager.endComponentDrag(); _updateCanvasSize(); }); } } } void _handleMultiComponentDrag(Offset localOffset) { final offset = localOffset - _dragManager.dragStartPosition!; final updatedPositions = _dragManager.moveComponentsByOffset( _editorState.componentPositions, _selectionManager.selectedComponents, offset, ); for (var selectedComponent in _selectionManager.selectedComponents) { final newPos = updatedPositions[selectedComponent.id]!; final command = MoveComponentCommand( selectedComponent.id, newPos, _editorState.getComponentPosition(selectedComponent.id), _editorState.componentPositions, ); _editorState.commandHistory.execute(command); _persistenceHelper.saveComponentPosition(selectedComponent.id, newPos); } } void _handleSingleComponentDrag(Component component, Offset localOffset) { final command = MoveComponentCommand( component.id, localOffset, _dragManager.dragStartPosition!, _editorState.componentPositions, ); _editorState.commandHistory.execute(command); _persistenceHelper.saveComponentPosition(component.id, localOffset); _selectionManager.selectComponent(component); } void _handleCopyMultipleComponents() { if (_selectionManager.selectedComponents.isEmpty) return; _clipboardManager.copyMultipleComponents( _selectionManager.selectedComponents, _editorState.componentPositions, _editorState.flowManager.connections, ); } void _handlePasteComponent(Offset position) { if (_clipboardManager.isEmpty) return; final pastePositions = _clipboardManager.calculatePastePositions(position); Map<String, String> idMap = {}; for (int i = 0; i < _clipboardManager.clipboardComponents.length; i++) { var originalComponent = _clipboardManager.clipboardComponents[i]; var newPosition = pastePositions[i]; String newName = '${originalComponent.id} (Copy)'; int counter = 1; while (_editorState.flowManager.components.any( (comp) => comp.id == newName, )) { counter++; newName = '${originalComponent.id} (Copy $counter)'; } Component newComponent = _editorState.flowManager.createComponentByType( newName, originalComponent.type.type, ); for (var sourceProperty in originalComponent.properties) { if (!originalComponent.inputConnections.containsKey( sourceProperty.index, )) { for (var targetProperty in newComponent.properties) { if (targetProperty.index == sourceProperty.index) { targetProperty.value = sourceProperty.value; break; } } } } Map<String, dynamic> state = { 'position': newPosition, 'key': _editorState.getComponentKey(newComponent.id), 'positions': _editorState.componentPositions, 'keys': _editorState.componentKeys, }; idMap[originalComponent.id] = newComponent.id; final command = AddComponentCommand( _editorState.flowManager, newComponent, state, ); _editorState.commandHistory.execute(command); _editorState.initializeComponentState( newComponent, position: newPosition, width: 160.0, ); } for (var connection in _clipboardManager.clipboardConnections) { String? newFromId = idMap[connection.fromComponentId]; String? newToId = idMap[connection.toComponentId]; if (newFromId != null && newToId != null) { final command = CreateConnectionCommand( _editorState.flowManager, newFromId, connection.fromPortIndex, newToId, connection.toPortIndex, ); _editorState.commandHistory.execute(command); } } setState(() { _updateCanvasSize(); }); } void _handlePasteSpecialComponent( Offset position, int numberOfCopies, bool keepAllLinks, ) { if (_clipboardManager.isEmpty) return; const double offsetX = 50.0; const double offsetY = 50.0; for (int copyIndex = 0; copyIndex < numberOfCopies; copyIndex++) { final double baseOffsetX = copyIndex * offsetX; final double baseOffsetY = copyIndex * offsetY; Map<String, String> idMap = {}; final basePastePositions = _clipboardManager.calculatePastePositions( Offset(position.dx + baseOffsetX, position.dy + baseOffsetY), ); for (int i = 0; i < _clipboardManager.clipboardComponents.length; i++) { var originalComponent = _clipboardManager.clipboardComponents[i]; var newPosition = basePastePositions[i]; String newName = '${originalComponent.id} (Copy)'; int counter = 1; while (_editorState.flowManager.components.any( (comp) => comp.id == newName, )) { counter++; newName = '${originalComponent.id} (Copy $counter)'; } Component newComponent = _editorState.flowManager.createComponentByType( newName, originalComponent.type.type, ); for (var sourceProperty in originalComponent.properties) { if (!originalComponent.inputConnections.containsKey( sourceProperty.index, ) || !keepAllLinks) { for (var targetProperty in newComponent.properties) { if (targetProperty.index == sourceProperty.index) { targetProperty.value = sourceProperty.value; break; } } } } Map<String, dynamic> state = { 'position': newPosition, 'key': _editorState.getComponentKey(newComponent.id), 'positions': _editorState.componentPositions, 'keys': _editorState.componentKeys, }; idMap[originalComponent.id] = newComponent.id; final command = AddComponentCommand( _editorState.flowManager, newComponent, state, ); _editorState.commandHistory.execute(command); _editorState.initializeComponentState( newComponent, position: newPosition, width: 160.0, ); } if (keepAllLinks) { for (var connection in _clipboardManager.clipboardConnections) { String? newFromId = idMap[connection.fromComponentId]; String? newToId = idMap[connection.toComponentId]; if (newFromId != null && newToId != null) { final command = CreateConnectionCommand( _editorState.flowManager, newFromId, connection.fromPortIndex, newToId, connection.toPortIndex, ); _editorState.commandHistory.execute(command); } } } } setState(() { _updateCanvasSize(); }); } void _handleCopyComponent(Component component) { final position = _editorState.getComponentPosition(component.id); _clipboardManager.copyComponent(component, position); } void _handleEditComponent(BuildContext context, Component component) { _flowHandlers.handleEditComponent(context, component); } void _handleDeleteComponent(Component component) { final componentId = component.id; final List<Connection> connectionsToDelete = []; for (final comp in _editorState.flowManager.components) { for (final entry in comp.inputConnections.entries) { if (entry.value.componentId == componentId) { connectionsToDelete.add( Connection( fromComponentId: entry.value.componentId, fromPortIndex: entry.value.portIndex, toComponentId: comp.id, toPortIndex: entry.key, ), ); } } } for (final entry in component.inputConnections.entries) { connectionsToDelete.add( Connection( fromComponentId: entry.value.componentId, fromPortIndex: entry.value.portIndex, toComponentId: componentId, toPortIndex: entry.key, ), ); } _flowHandlers.handleDeleteComponent(component); _persistenceHelper.saveRemoveComponent(componentId); for (final connection in connectionsToDelete) { _persistenceHelper.saveRemoveConnection( connection.fromComponentId, connection.fromPortIndex, connection.toComponentId, connection.toPortIndex, ); } } void _handleMoveComponentDown(Component component) { _flowHandlers.handleMoveComponentDown(component); } void _handleMoveComponentUp(Component component) { _flowHandlers.handleMoveComponentUp(component); } void _handleMoveComponentLeft(Component component) { _flowHandlers.handleMoveComponentLeft(component); } void _handleMoveComponentRight(Component component) { _flowHandlers.handleMoveComponentRight(component); } } 

